## $Id: ifhp.conf.in,v 1.57 2002/07/12 23:27:04 papowell Exp papowell $
## VERSION=3.5.10

###   Supported Printers

###   SUPPORTED START
### default - HP 4M Plus, PostScript, PJL, PCL, status, pagecount support
### apple - PostScript printer, text to PS conversion, status, pagecount support
### postscript - PostScript printer, text to PS conversion, status, pagecount support
### ps - PostScript printer, text to PS conversion, status, pagecount support
### pcl - PCL only printer, no status
### pcl_gs - HP Laserjet 4 PCL only printer, write only, no status
### hpiiisi - HP LaserJet III (PCL and PostScript Interpreter)
### hp3si - HP LaserJet III (PCL and PostScript Interpreter)
### ljet3 - HP LaserJet III (PCL and PostScript Interpreter)
### lj3 - HP LaserJet III (PCL and PostScript Interpreter)
### hpiiisi.gs - HP LaserJet III (PCL, PostScript via GhostScript)
### hp3si.gs - HP LaserJet III (PCL, PostScript via GhostScript)
### ljet3.gs - HP LaserJet III (PCL, PostScript via GhostScript)
### lj3.gs - HP LaserJet III (PCL, PostScript via GhostScript)
### hp4 - HP LaserJet 4 Family, HP LaserJet 4 (PostScript Interpreter)
### hp4m - HP LaserJet 4 Family, HP LaserJet 4m (PostScript Interpreter)
### hp4si - HP LaserJet 4 Family, HP LaserJet 4si (PostScript Interpreter)
### hp4simx - HP LaserJet 4 Family, HP LaserJet 4simx (PostScript Interpreter)
### hp4plus - HP LaserJet 4 Family, HP LaserJet 4plus (PostScript Interpreter)
### hp4mplus - HP LaserJet 4 Family, HP LaserJet 4mplus (PostScript Interpreter)
### hp4v - HP LaserJet 4 Family, HP LaserJet 4v (PostScript Interpreter)
### hp4mv - HP LaserJet 4 Family, HP LaserJet 4mv (PostScript Interpreter)
### hp4p - HP LaserJet 4 Family, HP LaserJet 4p (PostScript Interpreter)
### hp4mp - HP LaserJet 4 Family, HP LaserJet 4mp (PostScript Interpreter)
### hp4pj - HP LaserJet 4 Family, HP LaserJet 4pj (PostScript Interpreter)
### hpljpro - HP LaserJet 4 Family, HP LaserJet ljpro (PostScript Interpreter)
### hp4lc - HP LaserJet 4 Family, HP LaserJet 4lc (PostScript Interpreter)
### hp4mplus - HP LaserJet 4MPlus
### hp5l - HP LaserJet 5 Family, Hp Laserjet 5l
### hp6l - HP LaserJet 6 Family, Hp Laserjet 6l
### hp1100 - HP LaserJet 6 Family, Hp Laserjet 1100
### hp1100 - HP LaserJet 1000 Family, Hp Laserjet 1100
### hp4l - Hp LaserJet 4L, PCL only
### hp4ml - HP LaserJet 4ml
### hp5p - HP LaserJet 5p
### hp5mp - HP LaserJet 5mp
### hp6p - HP LaserJet 6p
### hp6mp - HP LaserJet 6mp
### hp5 - HP LaserJet 5
### hp5si - HP LaserJet 5si
### hp5simx - HP LaserJet 5simx
### hp5m - HP LaserJet 5m
### hp5simopier - HP LaserJet 5simopier
### hp4000 - HP LaserJet 4000
### hpcolorlj - HP Color LaserJet 
### hpcolorlj5 - HP Color LaserJet 5
### hpcolorlj5m - HP Color LaserJet 5m
### hpdj1200 - HP Design Jet 1200 Family
### hppjxl300 - HP Paint Jet XL 300 Family
### hpdj1600 - HP Design Jet 1600 Family
### hpdj200 - HP DeskJet 200
### hpdj220 - HP DeskJet 220
### hpdj600 - HP DeskJet 600
### hpdj650 - HP DeskJet 650
### hpdj230 - HP DeskJet 230
### hpdj250c - HP DeskJet 250c
### hpdj330 - HP DeskJet 330
### hpdj350c - HP DeskJet 350c
### hpdj430 - HP DeskJet 430
### hpdj450c - HP DeskJet 450c
### hpdj455ca - HP DeskJet 455ca
### hpdj700 - HP DeskJet 700
### hpdj750c - HP DeskJet 750c
### hpdj750cplus - HP DeskJet 750cplus
### hpdj755cm - HP DeskJet 755cm
### hpdj2000cp - HP DeskJet 2000cp
### hp2500 - HP Design Jet 2500 - No PCL, PostScript Only
### hp2500cm - HP Design Jet 2500cm - No PCL, PostScript Only
### hp2500c - HP Design Jet 2500c - No PCL, PostScript Only
### hp2500cm - HP Design Jet 2500cm - PCL and PostScript
### hpdj2500cp - HP DesignJet 2500CP, not HP2500, HP2500c, HP2500cm
### hp4500 - HP Color LaserJet Printer 4500
### hp8500 - HP Color LaserJet Printer 8500
### hp8550 - HP Color LaserJet Printer 8550
### hp5000 - HP5000  Model number: C4111A (LaserJet 5000N)
### hp5000 - HP5000 Model C4111A (LaserJet 5000)
### hp8000 - HP Laserjet 8000 Series, HP8000
### hp8100 - HP Laserjet 8000 Series, HP8100
### hp8150 - HP Laserjet 8000 Series, HP8150
### hp2100 - HP LaserJet 2100 Series
### hp2200 - HP LaserJet 2200 Series
### hp4050 - HP4050 Series
### hp4050 - HP4050 Series Printers
### qms1725 - QMS 1725, uses appsocket, no status, PostScript only
### qms2025 - QMS Laser Printer QMS 2025, appsocket, no status, PostScript and PCL
### qms860 - QMS Laser Printer QMS 860, appsocket, no status, PostScript and PCL
### qms2060 - QMS Laser Printer QMS 2060, appsocket, no status, PostScript and PCL
### phaser - Generic Tektronics Phaser Color Printer, appsocket, PostScript only
### phaser360 - Tektronics Phaser 360 Color Printer, appsocket, PostScript only
### phaser740 - Tektronics Phaser 740 Color Printer, appsocket, PostScript only
### phaser750 - Tektronics Phaser 750 Color Printer, appsocket, PostScript only
### phaser850 - Tektronics Phaser 850 Color Printer, appsocket, PostScript only
### phaser5400 - Phaser 5400, understands PCL and PostScript, needs appsocket
### lexmark4039 - Lexmark 4039, Postscript only
### lexmark_optra_e312 - Lexmark Optra e312, Postscript, PCL and PJL
### ln15s - Digital Laser LN15, LN17ps, Compaq Laser LN 16
### ln16s - Digital Laser LN15, LN17ps, Compaq Laser LN 16
### ln17pss - Digital Laser LN15, LN17ps, Compaq Laser LN 16
### hpij2250s - HP Business Inkjet 2250
### gs_bj10 - Canon BubbleJet BJ10e 
### gs_bj10 - Canon BubbleJet BJ20 
### gs_bj200 - Canon BubbleJet BJ200 
### gs_bj200 - Canon BubbleJet BubbleJet BJC-210 B/W only 
### gs_bj200 - Canon BubbleJet BubbleJet BJC-240 B/W only 
### gs_bj200 - Canon BubbleJet BubbleJet BJC-250 B/W only 
### gs_bj200 - Canon BubbleJet BubbleJet BJC-70 B/W only 
### gs_bjc600 - Canon BubbleJet BubbleJet BJC-600 
### gs_bjc600 - Canon BubbleJet BubbleJet BJC-610
### gs_bjc600 - Canon BubbleJet BubbleJet BJC-50
### gs_bjc600 - Canon BubbleJet BubbleJet BJC-70 
### gs_bjc600 - Canon BubbleJet BubbleJet BJC-80 
### gs_bjc600 - Canon BubbleJet BubbleJet BJC-210 Color only
### gs_bjc600 - Canon BubbleJet BubbleJet BJC-240 Color only
### gs_bjc600 - Canon BubbleJet BubbleJet BJC-250 
### gs_bjc600 - Canon BubbleJet BubbleJet BJC-1000
### gs_bjc600 - Canon BubbleJet BubbleJet BJC-2000
### gs_bjc600 - Canon BubbleJet BubbleJet BJC-4000 
### gs_bjc600 - Canon BubbleJet BubbleJet BJC-4100 B/W only
### gs_bjc600 - Canon BubbleJet BubbleJet BJC-4200
### gs_bjc600 - Canon BubbleJet BubbleJet BJC-4300
### gs_bjc600 - Canon BubbleJet BubbleJet BJC-4550 
### gs_bjc600 - Canon BubbleJet BubbleJet BJC-6000
### gs_bjc600 - Canon MultiPASS C2500 color printer/fax/copier 
### gs_bjc800 - Canon BubbleJet BubbleJet BJC-800 
### gs_bjc800 - Canon BubbleJet BubbleJet BJC-7000 Color. 
### gs_bjc800 - Canon BubbleJet BubbleJet BJC-4300 Color
### gs_bjc800 - Canon BubbleJet BubbleJet BJC-4650 
### gs_deskjet - HP DeskJet 
### gs_deskjet - HP DeskJet Plus 
### gs_djet500 - HP DeskJet 500 B/W
### gs_djet500 - HP DeskJet Portable B/W
### gs_djet500 - HP OfficeJet 590 B/W
### gs_cdj500 - HP DeskJet 400
### gs_cdj500 - HP DeskJet 500C 
### gs_cdj500 - HP DeskJet 540C 
### gs_cdj500 - HP DeskJet 690C
### gs_cdj500 - HP DeskJet 693C
### gs_cdj550 - HP DeskJet 550C 
### gs_cdj550 - HP DeskJet 560C 
### gs_cdj550 - HP DeskJet 600
### gs_cdj550 - HP DeskJet 660C 
### gs_cdj550 - HP DeskJet 660C 
### gs_cdj550 - HP DeskJet 682C
### gs_cdj550 - HP DeskJet 683C
### gs_cdj550 - HP DeskJet 693C 
### gs_cdj550 - HP DeskJet 694C 
### gs_cdj550 - HP DeskJet 690C 
### gs_cdj550 - HP DeskJet 692C 
### gs_cdj550 - HP DeskJet 693C 
### gs_cdj550 - HP DeskJet 694C 
### gs_cdj550 - HP DeskJet 695C 
### gs_cdj550 - HP DeskJet 850 
### gs_cdj550 - HP DeskJet 870Cse 
### gs_cdj550 - HP DeskJet 895Cxi
### gs_cdj550 - HP DeskJet 970 
### gs_cdj550 - HP OfficeJet 590 
### gs_cdj550 - Olivetti jp450 
### gs_cdj550 - Xerox XJ6C 
### gs_cdj850 - HP DeskJet 850 
### gs_cdj850 - HP DeskJet 855 
### gs_cdj850 - HP DeskJet 870Cse 
### gs_cdj850 - HP DeskJet 870Cxi 
### gs_cdj850 - HP DeskJet 890C 
### gs_cdj850 - HP DeskJet 670C 
### gs_cdj850 - HP DeskJet 680 
### gs_cdeskjet - HP DeskJet 500C
### gs_cdeskjet - GhostScript with -sDEVICE=cdj500 -dBitsPerPixel=3 
### gs_cdjcolor - GhostScript with -sDEVICE=cdj500 -dBitsPerPixel=24 
### gs_cdjmono - HP DeskJet 500C 
### gs_cdjmono - HP DeskJet 510 
### gs_cdjmono - HP DeskJet 520 
### gs_cdjmono - HP DeskJet 540C 
### gs_cdjmono - HP DeskJet 693C 
### gs_cdjmono - GhostScript with -sDEVICE=cdj500 -dBitsPerPixel=1 
### gs_epsonc - Fujitsu DL-1100 
### gs_epsonc - Fujitsu DL-2400 
### gs_hl7x0 - Brother HL-720 
### gs_hl7x0 - Brother HL-730 
### gs_hl7x0 - Do not use hl7x0 with PCL compliant Brother HL-760. Use ljet4. 
### gs_laserjet - Bull Compuprint Pagemaster 415 
### gs_lips3 - Canon LBP4+
### gs_lj4dith - HP DeskJet 600 
### gs_ljet2 - HP LaserJet II 
### gs_ljet2 - Xerox 4030 
### gs_ljet3 - Tandy LP800 With LaserJet III emulation. 
### gs_ljet4 - Brother HL-660 
### gs_ljet4 - Brother HL-760 600dpi 
### gs_ljet4 - Epson EPL5700 300dpi OK
### gs_ljet4 - HP DeskJet 600 margins wrong 
### gs_ljet4 - HP DeskJet 870Cse 
### gs_ljet4 - HP LaserJet 5 300dpi or 600dpi 
### gs_ljet4 - HP LaserJet 5L 300dpi or 600dpi
### gs_ljet4 - HP LaserJet 6L 600dpi
### gs_ljet4 - HP LaserJet 1100 600dpi OK. 
### gs_ljet4 - IBM Network Printer 17 
### gs_ljet4 - IBM/Lexmark 4029 Margins wrong. 
### gs_ljet4 - Lexmark Optra E+ 
### gs_ljet4 - Lexmark Optra SC 1275 B/W only. 
### gs_ljet4 - Oki OL410ex LED printer 300dpi or 600dpi 
### gs_ljetplus - HP LaserJet Plus 
### gs_ljetplus - Canon Laser LBP-600 
### gs_ljetplus - NEC SuperScript 860 
### gs_pjxl300 - HP PaintJet XL300 
### gs_pjxl300 - HP DeskJet 600
### gs_pjxl300 - HP DeskJet 1200C 
### gs_pjxl300 - HP DeskJet 1600C
### gs_r4081 - Ricoh 4081 laser printer 
### gs_r4081 - Ricoh 6000 laser printer 
### bjc610a0.upp - Canon BubbleJet BJC 610 (color, rendered) 360x360dpi plain paper, high speed
### bjc610a1.upp - Canon BubbleJet BJC 610 (color, rendered) 360x360dpi plain paper
### bjc610a2.upp - Canon BubbleJet BJC 610 (color, rendered) 360x360dpi coated paper
### bjc610a3.upp - Canon BubbleJet BJC 610 (color, rendered) 360x360dpi transparency film
### bjc610a4.upp - Canon BubbleJet BJC 610 (color, rendered) 360x360dpi back print film
### bjc610a5.upp - Canon BubbleJet BJC 610 (color, rendered) 360x360dpi fabric sheet
### bjc610a6.upp - Canon BubbleJet BJC 610 (color, rendered) 360x360dpi glossy paper
### bjc610a7.upp - Canon BubbleJet BJC 610 (color, rendered) 360x360dpi high gloss film
### bjc610a8.upp - Canon BubbleJet BJC 610 (color, rendered) 360x360dpi high resolution paper
### bjc610b1.upp - Canon BubbleJet BJC 610 (color, rendered) 720x720dpi plain paper
### bjc610b2.upp - Canon BubbleJet BJC 610 (color, rendered) 720x720dpi coated paper
### bjc610b3.upp - Canon BubbleJet BJC 610 (color, rendered) 720x720dpi transparency film
### bjc610b4.upp - Canon BubbleJet BJC 610 (color, rendered) 720x720dpi back print film
### bjc610b6.upp - Canon BubbleJet BJC 610 (color, rendered) 720x720dpi glossy paper
### bjc610b7.upp - Canon BubbleJet BJC 610 (color, rendered) 720x720dpi high-gloss paper
### bjc610b8.upp - Canon BubbleJet BJC 610 (color, rendered) 720x720dpi high resolution paper
### cdj550.upp - HP DeskJet 550C 300x300dpi 32-bit CMYK
### necp2x.upp - NEC P2X 360x360dpi 8-bit (Floyd-Steinberg)
### stcany.upp - Epson Stylus Color (Any) 360x360dpi 4-bit, PostScript halftoning
### stc.upp - Epson Stylus (Original) and Stylus Pro Color 360x360dpi 32-bit CMYK, 15-pin 
### stc_l.upp - Epson Stylus (Original) and Stylus Pro Color 360x360dpi 4-bit, PostScript halftoning, weaved noWeave
### stc_h.upp - Epson Stylus (Original) and Stylus Pro Color 720x720dpi 32-bit CMYK, 15-pin Weave
### stc2.upp - Epson Stylus (Original) and Stylus Pro Color 360x360dpi 32-bit CMYK, 20-pin, Epson Stylus Color II(s)
### stc2_h.upp - Epson Stylus (Original) and Stylus Pro Color 720x720dpi 32-bit CMYK, 20-pin, Epson Stylus Color II 
### stc2s_h.upp - Epson Stylus (Original) and Stylus Pro Color 720x720dpi 32-bit CMYK, 20-pin, Epson Stylus Color IIs
### stc500p.upp - Epson Stylus Color 500 360x360dpi 32-bit CMYK, noWeave, plain paper
### stc500ph.upp - Epson Stylus Color 500 720x720dpi 32-bit CMYK, noWeave, plain paper
### stc600pl.upp - Epson Stylus Color 600, 360x360dpi, 32/90-inch weaving 32-bit CMYK, 32-pin, plain paper
### stc600p.upp - Epson Stylus Color 600, 720x720dpi, 32/90-inch weaving 32-bit CMYK, 32-pin, plain paper
### stc600ih.upp - Epson Stylus Color 600, 1440x720dpi, 32/90-inch weaving 32-bit CMYK, 30-pin, inkjet paper
### stc800pl.upp - Epson Stylus Color 800, 64/180-inch weaving 360x360dpi 32-bit CMYK, 64-pin, plain paper
### stc800p.upp - Epson Stylus Color 800, 64/180-inch weaving 720x720dpi 32-bit CMYK, 64-pin, plain paper   
### stc800ih.upp - Epson Stylus Color 800, 64/180-inch weaving 1440x720dpi 32-bit CMYK, 62-pin, inkjet paper
### stc1520h.upp - Epson Stylus Color 800, 64/180-inch weaving 1440x720dpi 32-bit CMYK, 62-pin, inkjet paper
### imagerunner550 - Canon imageRUNNER 550/600 iR600-550-60 
### imagerunner600 - Canon imageRUNNER 550/600 iR600-550-60 
###   SUPPORTED END

### From Section 3 of the IFHP-HOWTO Document:
###
###   3. Recommended -Z options for Users
###   
###   Due to the general nature of the ifhp filter, there is no standard
###   set of -Z user options because there is no standard set of user
###   facilities. However, the following are recommended for use by
###   implementors of new configurations or printer support.
###   
###   3.1 Input Tray Selection
###   
###   If a printer supports an input tray selection mechanism, then the
###   following options are recommended for use. Local conditions or
###   printer type may require addition options.
###   
###   inupper, inlower, intray1, intray2, ..., manual, envelope
###   
###          The input tray selection options should start with the in
###          prefix and correspond to the various trays, if possible.
###          The manual and envelope options are included to select manual
###          feed or envelope feed. There is a possible source of conflict
###          here as there may be an envelope feeder as well as an envelope
###          media. This is a printer specific dependency.
###   
###   source=name
###   
###          The source=name option allows users to use options such as
###          -Zsource=inbin1, which may be useful for systems that have
###          an unusual or nonstandard input selection mechanism.
###   
###   3.2 Output Bin Selection
###   
###   If a printer has an output bin selection mechanism or some other
###   finishing mechanism, then the following are recommended for use.
###   
###   outupper, outlower, outbin1, ...
###   
###          The output bin selection should start with the out prefix.
###   
###   outbin=name
###   
###          The outbin=name form allow users to use options such as
###          -Zoutbin=stapler, which may be useful for systems that have
###          an unusual or nonstandard output selection mechanism.
###   
###   3.3 Media Size (Paper) Selection
###   
###   The paper size selection facilities usually are quite printer
###   dependent, and the input tray selection and paper size selection
###   mechanisms may interact in strange and mysterious ways.
###   
###   letter, legal, ledger, oversize, a0, a1, ...
###   
###          These are standard paper size names.
###   
###   11x17, tabloid
###   
###          These are usually aliases for ledger, but depending on local
###          conditions can select different types of paper.
###   
###   paper=name
###   
###          The paper=name form allow users to use options such as
###          -Zpaper=b3, which may be useful for systems that have an
###          unusual or nonstandard input media selection mechanism.
###   
###   3.4 Media Type Selection
###   
###   Media Type is not the same as paper size, and corresponds to the
###   name assigned to a particular media. Of course, the issue is
###   complicated by the fact that some media have standard sizes as
###   well. Again, the input tray selection, media size, and media type
###   selection will interact in confusing and mysterious ways, depending
###   on the whim of the printer firmware iplementors.
###   
###   You will notice that there is no generic mediatype=name facility.
###   This is due to the radically different way that PostScript,
###   PJL, PCL, etc., each handle media name and selection.  While
###   it is possible to determine the various strings, numbers, escape
###   codes, etc., that need to be sent for each mediatype,  a general
###   mechanism is too fragile and fraught with peril for the unwary
###   administrator to provide.  You have been warned.  Been there and
###   have the scars to prove it.
###   
###   plain, preprinted, letterhead, transparency, glossy, prepunched,
###   labels
###   
###          These are commonly used media type names gleaned from various
###          PostScript Printer Description Files, Microsoft printer
###          drivers, and arcane lore of the Printer Working Group. Note
###          that these are not accepted terms in the paper industry for
###          any of these type of media. You are warned.
###   
###   3.5 Duplex and Simplex
###   
###   Duplex printing is when impressions are placed on both sides of a
###   sheet of media. Due to a general lack of conventions, the orientation
###   of each of the impressions varies from vendor to vendor, and has
###   changed over the years.
###   
###   duplex, lduplex
###   
###          Print on both sides using the default orientation. The
###          lduplex is an alias for duplex.
###   
###   duplexshort, sduplex
###   
###          Print on both sides but reverse the orientation of one page.
###          The sduplex is an alias for duplex Which page is reversed
###          it at the whim of the firmware implementors and conventions
###          for the printer.
###   simplex
###   
###          Print on a single side of a page.
###   
###   tumble, shortedge
###   
###          This is use to print a single page on one side of the media,
###          but using the (nonstandard) orientation for the duplexshort.
###          This is usually done when a single impression must be
###          generated on the alternative side of the media, rather than
###          the default side. Again, this is dependent on the whims and
###          whimsys of the printer firmware implementors, and may have
###          some unexpected side effects.
###   
###   3.6 Copies
###   
###   This option has been provided to effectively allow the printer to
###   make multiple copies of a single page or job. This option tends to
###   be misimplemented on almost all known printers, and it is strongly
###   recommended that users do not use it. However, for completeness,
###   compatibility, and implementor consideration, this is included,
###   even against the better judgement of the implementors of the ifhp
###   software.
###   
###   copies=nnn
###   
###          Attempt to make nnn copies of each impression. This usually
###          fails with catastrophic problems unless you have a system
###          that supports all of the various options required, has enough
###          memory to handle rasterization, you do not have a paper
###          outage, and the printer does not stop with operator
###          intervention. You have been warned.
###   
###   

#########
#########   Default Printer Entry
#########    This describes the various supported options that are
#########   to be used in the ifhp.conf file.  There are others but
#########   these are reserved strictly for command line use.
#########

#  
# PRINTER default - HP 4M Plus, PostScript, PJL, PCL, status, pagecount support

## Status file limits in K bytes
##
statusfile_max=8
statusfile_min=2

#--- START language setup
## default is to turn everything on
## We assume that we have PostScript, PJL, PCL, and text support
## Text is just PCL without any control sequences
##

pjl
pcl
ps
text

## if you have a text file do LF to CRLF translation.
## This is dangerous and should not be used unless you are
## absolutely desperate AND have read the warnings in the
## source code.
# crlf

## These are for very ugly printers that have some strange problems
##  with PCL and PS end of job at the start of jobs.  If it is present,
##  the PJL settings are ignored,  or the rest of the job may be
##  ignored.
##
## PCL EOJ at start and end of job when PCL supported.
## If you set pcl_eoj@ you do NOT put an EOJ at start
## of job.  This violates the recommendations of the PCL
## Reference Manual.
## pcl_eoj_at_start   - (default), EOJ at start of job
## pcl_eoj_at_start@  - no EOJ
## pcl_eoj_at_end   - (default), EOJ at end of job
## pcl_eoj_at_end@  - no EOJ

pcl_eoj_at_start
pcl_eoj_at_end


## PS EOJ is usually put at start of PS when PS is being printed.
## You may not want this.
## ps_eoj   - ^D at start and end of job (default)
## ps_eoj_at_start   - (default), EOJ at start of job
## ps_eoj_at_end     - (default), EOJ at end of job

ps_eoj
ps_eoj_at_start
ps_eoj_at_end

## Some printers get very upset when PostScript jobs contain ^T or ^C
## characters.  You can remove various control character by setting
## their values in this string:
##  remove_ctrl=TC   will remove CTRL-T and CTRLC characters
##  This is only done for PostScript jobs.  You will usually find
## this when a job was generated on a system where it expects to
## communicate dynamically with a monitoring system,  and is being
## printed on another printer or system.
##
# remove_ctrl=TC
# 

## Some printers insist on using the Tagged Binary Commmunication Protocol
## to support sending embedded PS file.  If you need to use TBCP, enable this.
## This flag is inherently evil,  and is for desperate uses only,
## and should not be generally enabled. 
##
## If you don't know what this is about,  don't mess with it.
## As they say, You have been warned.  Read the code, read the
## TBCP documentation, and get ready to experiment with this
## before blindly enabling it.
##
# tbcp

#--- END lanuage setup


#--- START accounting extra information
## For those little moments of quiet desperation when you need to have the
## actual printing filter do some accounting.  Why?  because you may need to
## check with some specialized database,  update the information in it.
##
## Again,  this is inherently evil,  and is for desperate sysadmins who are
## trying to placate the bean counters in administration...
## If you don't know what this is about,  don't mess with it.
## You, as they say,  have been warned.  Read the IFHP-HOWTO for
## more details.

## accounting script
# accounting=accounting.sh
#--- END accounting extra information

#--- START connection
## The conventional use of the ifhp filter is to have the spooler open
## a connection.  However, the ifhp filter can also open the connection
## and must do so for the APPSOCKET protocol.  The following flags are
## used to control this.
## 
## dev=XXXX        - the device to open
##   dev=/dev/xxx   - open a device
##     if status@ then it is opened Write only
##     if status  then it is opened Read/Write
##   dev=host%port  - open a TCP/IP connection
## 
## appsocket      - use the appsocket protocol
##   This requires that a network connection be made to the printer for
##   each major stage in printing.
## 
## shutdown_appsocket - this special flag is used with the appsocket
##   protocol to cause a TCP/IP 'shutdown' to be done at the end of each
##   stage of printing processing,  rather than a network close.  This
##   also causes the connection to be monitored for a network close by
##   the device.
#--- END connection

#--- START printer status, sync, and pagecount

## 
## status
## 
## If you have a bi-directional channel to your printer,  it may or
## may not provide status information.  See the IFHP-HOWTO for details
## about this.
##  
## status  - printer has bidirectional communications,  and will provide
##   status information that MUST be read.  The ifhp filter will do
##   non-blocking reads and writes to the printer.
##
## status@ - the ifhp filter will NOT attempt to read from the
##   printer and will do only (blocking) writes.
## 
##  Setting status@ can have
##  unexpected side effects if your printer sends status back on a
##  TCP/IP connectio.  If it is not read,  the printer's output buffer
##  may becomes full and the printer will lock up.
##
##  If your printer has a bidirectional connection (network connection)
##  but does not provide status or interactive information,
##  use sync@ and pagecount@ to prevent the ifhp filter from interrogating
##  the printer.
##

status

##
## sync
##
## If you have a bidirectional communication port and your printer supports
## PJL ECHO, PJL JOB, or PostScript,  then you can send a small job to the
## printer that will effectively check on its health and clear out any problems
## it may have had from the last job.  This operation is called 'sync' because
## when it completes you have synchronized communication with the printer
## and are getting the current status information
##
## If you are not worried about this,  you can turn 'sync' off - sync@
##
## sync@     - no sync operations
## sync      - Use PJL JOB, PJL ECHO, or PostScript, depending on
##             what is supported by the printer.
## sync=ps   - use PostScript
## sync=pjl  - use PJL method
## sync=|/....  - run this program to get status (see STATUS HELPERS below) 


sync

## try sending sync requests at these intervals
#
sync_interval=20

##
## pagecount
##
## If your printer suppors a hardware page counter,  then this operation
## gets the value of the pagecounter both before and after the job has been
## printed.  This information is written to the accounting log file.
##

##
## pagecount@     - no pagecount
## pagecount      - if pjl availble us it, then if ps available use it
##             this is best method to sync
## pagecount=ps   - use ps method
## pagecount=pjl  - use pjl method
## pagecount=|/....  - run this program to get pagecount (see STATUS HELPERS below) 
pagecount

##  If your printer does not have a reliable way to determine that
## the last job has finished,  you can 'poll' it at intervals.
##
## The page count will be sampled 'pagecount_poll' times (0 or 1 is once)
## until it is stable, at pagecount_interval seconds.
## The pagecount_poll is for desperation only
##   - default is pagecount_poll
##      - pagecount_poll_start specifies number of polls at start
##      - pagecount_poll_end specifies number of polls at end
##  You can specify a non-zero pagecount timeout that will limit
##  the amount of time that you try to get pagecounts
##  This is dangerous if you are trying to get status by polling
##  However, if your printer goes off line,  then you may have
##  similar problems.
#pagecount_poll=5
#pagecount_poll_end=5
#pagecount_poll_start=1
pagecount_interval=1
pagecount_timeout=0

##  We will send a 'sync' query at then end of job to determine if a job has
##  finished.  However, if you do not want to do this, then set
##  waitend@ . Suppressing waitend is DANGEROUS if you expect to
##  get error status back.  You can also set waitend=ps to force
##  using a small PostScript job to be run to indicate that the processing
##  of the job has been completed.  Unfortunately,  this will only tell
##  about the print engine.  You will also have to use ps_ctrl_t to force
##  the printing status to be delivered
## waitend@     - no waitend operations
## waitend      - Use PJL JOB, PJL ECHO, or PostScript, depending on
##             what is supported by the printer.
## waitend=ps   - use PostScript
## waitend=pjl  - use PJL method
## waitend=|/....  - run this program to get status (see STATUS HELPERS below) 
waitend

##  When you use waitend=ps (or have a PostScript only printer),  you can
##  send a ^T (control T) to ask the printer for status.  This will cause
##  the actual printer status to be returned in the format:
##    %%[ status: value ]%%
##  If the value returned is one listed in the end_status list,
##  then this indicates that the last page has been printed.
##  The values are separated by colon, semicolon, or whitespace.
##  You can also use the !value to indicate that when this value does NOT
##  occur as a status,  then you have a done condition.  For example,
##  !printing will accept any status BUT printing as a done condition.
##
##  To suppress sending CTRL_T use ps_ctrl_t@

ps_ctrl_t
end_status=busy idle

##  If you are getting status using postscript,  you may need to
##  prompt the printer at intervals to send status.  You may wait
##  a long time without getting any status,  so you could periodically
##  request status.   This is dangerous if the printer is offline,
##  and on some legacy (defective?) network printers has resulted in
##  the printer locking up to the point where a powerup reset had
##  to be done.  This is rare and should not happen.  If it does
##  then turn ps_ctrl_t@  or you will have problems.
##
##  Interval to prompt for status after job has been sent
waitend_interval=300

## interval between PostScript CTRL_T queries after you have gotten
## a response from the printer that it is finished with the previous
## job.  Used only if ps_ctrl_t has a non-null value,  and after a
## small PostScript job has been processed that sends back an echo
## response.  You may find that these CTRL_T's may get ignored if
## the PostScript engine is busy,  so do not send too fast
waitend_ctrl_t_interval=3

##  STATUS HELPERS
## The sync, pagecount, and waitend functions can be implemented by
## running a 'status helper' program.  These programs are run with:
##  STDIN = printing device
##  STDOUT = for reporting
##  STDERR = for errors
## 
## Information written to STDERR will be put into the error log.
## Information written to STDOUT should have the format: key=value
##   KEY     VALUE
##   sync    1 (or nonzero)  - sync is done
##   waitend 1 (or nonzero)  - waitend is done
##   pagecount nnn           - pagecounter value
## 
## Note: you can use a single program to do all 3 operations,
## in which case simply write 3 lines with sync, waitend, and pageount
## values.
## 
## Alternatively,  if the sync,waitend, or pagecount
## program exits with 0 status, then success is assumed,
## otherwise IFHP will exit with the same error status,
## except for coredumps, etc., in which case it will exit
## with JABORT status.
## 
## If no pagecount information is returned, then a 0 (no pagecounter
## available) is assumed.
##
##
## 
## how often to report progress - minimum of percent or
##  amount written (in Kbytes)
##  report when you have done this much more percent of the job
progress_pc=25
##  report when you have done this much more Kbytes of job
progress_k=1000

#--- END printer status, sync, and pagecount

#--- START paper size for conversion purposes

## This is basically a nasty hack to allow users to pass paper
## sizes through to GhostScript.  The idea is that you define
## the set of paper sizes that GhostScript can handle in this
## list,  and then user the -M \%s{papersize} entry on the
## command line.
## 'papersize' is a 'Built In' function that will
## look through the 'papersize' list of values and check to see
## if one of them appears in the command line -Z or -T options values.
## If not, then it will check for a 'paper=' or 'papersize='
## option, and finally use the value of 'papersize_default'
## if all the tests fail.  If it is invoked for a 'number' then it
## will translate the name to a number corresponding to the PCL
## selection code. See pcl_papersize
## This allows you to use -Za0 on the lpr command line
##  or -Zpapersize=a0 or -Zpaper=a0
##
papersize= 
 a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 b0 b1 b2 b3 b4 b5
 archA archB archC archD archE flsa flse halfletter
 note letter legal 11x17 ledger tabloid
papersize_default= letter


## START PJL configuration

## only allow these PJL commands
##
pjl_only=[
    COMMENT DEFAULT DINQUIRE ECHO ENTER EOJ
    FSAPPEND FSDIRLIST FSQUERY FSUPLOAD FSDELETE FSDOWNLOAD FSINIT FSMKDIR
    INFO INITIALIZE INQUIRE JOB OPMSG PJL RDYMSG
    RESET SET STMSG USTATUS USTATUSOFF
## special builtins that expand variables correctly
    COPIES
  ]

## do NOT allow these PJL commands, even if they are in pjl_only
pjl_except=[ ]

## BUILTIN PJL Support
##  pjl_enter - printer supports language selection
pjl_enter
##  pjl_job -   printer supports PJL JOB 
pjl_job
##  pjl_console -   printer supports PJL console setting 
##  (you can use the console@ as well)
pjl_console
## Set console message during job  
##  This is also used as a unique string to identify job
## values you want - \%s{n} is user name -
pjl_ready_msg = \%s{n} \%s{J}:\%s{P}
## Set console message when job is done
##  Set this to empty string if you do not want a ready message
##  at end of job
pjl_done_msg = Done: \%s{n} \%s{J}:\%s{P}
## maximum number of characters on the console display for messages
##  (you can use the display_size=nnn option as well)
pjl_display_size= 20

## expand the following on startup,  after the builtin
pjl_init=[ info=id ustatus teoj ]

## expand the following on termination,  after the builtin
pjl_term=[ ustatus teoj ]

## You can, if you are feeling very odd, force a file
##  to be send as part of the PJL setup
##  1. add setup to pjl_user_opts if you want user specified files
##    specify this with -Tsetup=filename
##  2. put setup=filename in pjl_init=[ ... ] list
##    if you want it permanently set up
##  The setup will get expanded to font_download=filename
##    and the actual file will come from ${pjl_fontdir}/filename
##  This keeps users from downloading /etc/passwd to your printer 

pjl_fontdir=/dev/env/DJDIR/etc/filters/fonts/pjl
pjl_setup=[ font_download=\%s{setup} ]
## default value for testing or insurance
setup=test

##   PJL USTATUS command string
##    This usually will force job status to be sent at 10
##   second intervals,  which is pretty useful for a keepalive
pjl_ustatus=
    @PJL USTATUSOFF
    @PJL USTATUS JOB = ON
    @PJL USTATUS DEVICE = ON
    @PJL USTATUS PAGE = ON
    @PJL USTATUS TIMED = 10

##   If your printer has 'True End of Job'  then this is useful.
##  The TEOJ is an undocumented option for PJL that forces JOB
##  status to be delayed until the job has been totally printed.
##  Sometimes it works,  usually does not
##
pjl_teoj= @PJL TEOJ = ON


## PJL Variables supposedly supported by HP and others
##  Your milage may vary.  More may be added as time goes on
##  Note:  the pjl_vars_set += [ ... ] format may soon
##  allow additional values to be added

pjl_vars_set= [
    AUTOCONF AUTOSELECT BINDING=LONGEDGE BITSPERPIXEL CLEARABLEWARNINGS
    CONTEXTSWITCH COPIES COURIER=REGULAR CPCLOCK DENSITY DISKLOCK
    DUPLEX ECONOMODE FINISH FORMLINES=60 HOLD HOLDTYPE
    IMAGEADAPT INTRAY1 INTRAY2 
    INTRAY1SIZE INTRAY2SIZE INTRAY3SIZE INTRAY4SIZE
    INTRAY5SIZE INTRAY6SIZE INTRAY7SIZE INTRAY8SIZE
    IOBUFFER IOSIZE JOBATTR JOBOFFSET
    LANG=ENGLISH LOWTONER MANUALFEED
    MEDIASOURCE MEDIATYPE MPTRAY ORIENTATION=PORTRAIT OUTBIN=UPPER
    OUTLINEPOINTSIZE PAGEPROTECT
    PAPER=LETTER PARALLEL PERSONALITY=AUTO POWERSAVE POWERSAVETIME=30
    PRINTQUALITY=NORMAL QTY=1 RENDERMODE REPRINT=AUTO RESOLUTION
    RESOURCESAVE RESOURCESIZE RET TIMEOUT=600 WIDEA4 TUMBLE
	PAPERLENGTH PAPERWIDTH
  ]

## PJL options - format is PJL option [value]
##  Your milage may vary.  More may be added as time goes on
##  Note:  the pjl_vars_set += [ ... ] format allows
##  additional values to be added

pjl_options_set = [ info ]

##
## PJL Options in -Z opts
##

pjl_user_opts = [
	11x17 1200 1200dpi 300 300dpi 600 600dpi a0 a1 a2 a3 a4 b5
	bond cardstock color duplex duplexshort env10 envb5 envc5
	envmonarch executive glossy heavy inlower intray1 intray2
	intray3 inupper labels landscape lduplex ledger legal letter
	letterhead manual outlower outupper plain portrait preprinted
	prepunched recycle sduplex shortedge simplex source tabloid
	transparency tray1 tray2 tray3 tumble

## Variables PJL var = value
    AUTOCONF AUTOSELECT BINDING=LONGEDGE BITSPERPIXEL
    COPIES COURIER=REGULAR DENSITY
    DUPLEX ECONOMODE FINISH FORMLINES=60
    IMAGEADAPT INTRAY1 INTRAY2 
    INTRAY1SIZE INTRAY2SIZE INTRAY3SIZE INTRAY4SIZE
    INTRAY5SIZE INTRAY6SIZE INTRAY7SIZE INTRAY8SIZE
    JOBATTR JOBOFFSET
    LANG=ENGLISH MANUALFEED
    MEDIASOURCE MEDIATYPE MPTRAY ORIENTATION=PORTRAIT OUTBIN=UPPER
    OUTLINEPOINTSIZE
    PAPER=LETTER PERSONALITY=AUTO
    PRINTQUALITY=NORMAL QTY=1 RENDERMODE REPRINT=AUTO RESOLUTION
    WIDEA4 TUMBLE
	PAPERLENGTH PAPERWIDTH
## Options PJL option value
	INFO
]

## Your milage may vary on these,  but supposedly most PJL aware
## printers will either support or ignore them
##
pjl_source=@PJL SET MEDIASOURCE = \%s{source}
#pjl_outbin=[ \%s{outbin} ]
# pjl_paper=[ \%s{paper} ]
# pjl_papersize=[ \%s{papersize} ]
# pjl_pagesize=[ \%s{pagesize} ]

# - these are pretty standard - DEFAULTS
pjl_duplex=@PJL SET DUPLEX = ON
pjl_duplexshort=
  @PJL SET DUPLEX = ON
  @PJL SET TUMBLE = ON
pjl_lduplex=[ duplex ]
pjl_sduplex=[ duplexshort ]
pjl_simplex=
  @PJL SET DUPLEX = OFF
pjl_tumble=@PJL SET TUMBLE = ON
pjl_shortedge=[ tumble ]

pjl_inupper=@PJL SET MEDIASOURCE = TRAY1
pjl_inlower=@PJL SET MEDIASOURCE = TRAY2
pjl_outupper=@PJL SET OUTBIN = UPPER
pjl_outlower=@PJL SET OUTBIN = LOWER
pjl_tray1=@PJL SET MEDIASOURCE = TRAY3
pjl_intray1=[ pjl_tray1 ]
pjl_tray2=@PJL SET MEDIASOURCE = TRAY0
pjl_intray2=[ pjl_tray2 ]
pjl_tray3=@PJL SET MEDIASOURCE = TRAY1
pjl_intray3=[ pjl_tray3 ]

pjl_landscape=@PJL SET ORIENTATION = LANDSCAPE
pjl_portrait=@PJL SET ORIENTATION = PORTRAIT

pjl_letter=@PJL SET PAPER = LETTER
pjl_legal=@PJL SET PAPER = LEGAL
pjl_ledger=@PJL SET PAPER = LEDGER
pjl_11x17=[ ledger ]
pjl_tabloid=[ ledger ]
pjl_executive=@PJL SET PAPER = EXECUTIVE
pjl_a0=@PJL SET PAPER = A0
pjl_a1=@PJL SET PAPER = A1
pjl_a2=@PJL SET PAPER = A2
pjl_a3=@PJL SET PAPER = A3
pjl_a4=@PJL SET PAPER = A4
pjl_b5=@PJL SET PAPER = B5
pjl_envb5=@PJL SET PAPER = EnvISOB5
pjl_env10=@PJL SET PAPER = Env10
pjl_envc5=@PJL SET PAPER = EnvC5
pjl_envmonarch=@PJL SET PAPER = EnvMonarch

pjl_transparency=@PJL SET MEDIATYPE = TRANSPARENCY
pjl_plain=@PJL SET MEDIATYPE = PLAIN
pjl_preprinted=@PJL SET MEDIATYPE = PREPRINTED
pjl_letterhead=@PJL SET MEDIATYPE = LETTERHEAD
pjl_glossy=@PJL SET MEDIATYPE = GLOSS
pjl_prepunched=@PJL SET MEDIATYPE = PREPUNCHED
pjl_labels=@PJL SET MEDIATYPE = LABELS
pjl_bond=@PJL SET MEDIATYPE = BOND
pjl_recycle=@PJL SET MEDIATYPE = RECYCLE
pjl_heavy=@PJL SET MEDIATYPE = HEAVY
pjl_cardstock=@PJL SET MEDIATYPE = CARDSTOCK
pjl_color=@PJL SET MEDIATYPE = COLOR
pjl_manual=@PJL SET MANUALFEED = ON

pjl_300=@PJL SET RESOLUTION = 300
pjl_300dpi=[ 300 ]
pjl_600=@PJL SET RESOLUTION = 600
pjl_600dpi=[ 600 ]
pjl_1200=@PJL SET RESOLUTION = 1200
pjl_1200dpi=[ 1200 ]

## PJL USTATUS information will include a lot of
## codes that are just not interesting,  such as 'printer on line',
## or 'power up'.  You can suppress reporting status for these codes
## by putting their code numbers in this list

pjl_quiet_codes=[
    10001
    10023
    10030
    40000
  ]

## Special error messages
##  One per line
##  The idea is that you may get an error code,  but you
## it is not 'standard'.  You can add additional codes here
## or override the default strings in the ifhp source.
## 
pjl_error_codes=[
    10006=Toner Low 
  ]

## Inform operator if this error number occurs
pjl_alert_codes=[
  15* 40* 41* 42* 44*
  ]

# use this program to write error to operator
# error will be read from STDIN.  You can play games with
# mail or whatever you want here.
#
pjl_alert_handler=


#--- END of PJL

#--- START of PostScript

## PostScript Information
##    WARNING - YOUR POSTSCRIPT PRINTER MAY NOT ACCEPT
##  SOME OF THE COMMANDS HERE.  Check the printer PostScript Printer
##  Description File for details.

## use the following string to cause the printer to echo
## ifhp will replace NAME by a unique identifier to make sure
## that the latest echo was detected


#  put the PostScript out immediately before the start of the job
# and before user options
# example:
#ps_init = [ nocopypage ]
#ps_nocopypage = /copypage {showpage} def


# ps_term:
# put the PostScript out immediately AFTER the job and BEFORE the
#  PostScript EOF
# example:
#ps_term = [ stopduplex ]
#ps_stopduplex = statusdict begin false setduplexmode end


ps_status_code=
    %!PS-Adobe-2.0
## for PS Level 3 add:
#   false 0 startjob pop
    ( %%[ echo: NAME ]%% ) print () = flush

##  PageCount
##   This is a very nasty piece of PostScript that will
##  get the current pagecount value out of the statusdict
##  Note: you really should use the PS Level 3 if you have it
##  Note: some printers INSIST on ignoring the startjob stuff,
##    and will report the current pagecount.  You sometimes need
##    to sit in a loop and wait until it stops changing.
##    See pagecount_interval

ps_pagecount_code=
    %!PS-Adobe-2.0
## for PS Level 3 add:
#   false 0 startjob pop
    /p{print}def ( %%[ pagecount: ) p
    statusdict begin pagecount end 20 string cvs p
    ( ]%% ) p () = flush

## PostScript options in -Z
##  defaults - for HP Laserjet4Mplus
## support for font download
##  use:  -Tfont=name1,font=name2
##  This will get expanded to fontdownload 
##  and fontdownload will get the ${font} value set by font=
##  the ps_fontdir value will be prefixed,  and
##   ${ps_fontdir}/name1  and ${ps_fontdir}/name2 will be downloaded
##  to the printer
##   
ps_fontdir=/dev/env/DJDIR/etc/filters/fonts/ps
ps_font=[ font_download ]


## Support for PostScript based page settings 
## YOU NEED TO CHECK YOUR PPD FILE FOR THIS STUFF
##
## You can also use tray=xx, source=xx, paper=xx, papersize=xx, pagesize=xx
## These are also passed as the PJL values so you can make them work
## with PostScript or PJL
ps_source=[ \%s{source} ]
ps_outbin=[ \%s{outbin} ]
ps_paper=[ \%s{paper} ]
## this gets the value of the pagesize variable and then uses
## it as an index or key to find the corresponding string
ps_papersize=[ \%s{papersize} ]
ps_pagesize=[ \%s{pagesize} ]

##

ps_duplex=   statusdict begin true setduplexmode false settumble end
ps_lduplex=[ duplex ]
ps_duplexshort=  statusdict begin true setduplexmode true settumble end
ps_sduplex=[ duplexshort ]
ps_simplex=  statusdict begin false setduplexmode end
ps_inupper=  statusdict begin 0 setpapertray end
ps_inlower=  statusdict begin 1 setpapertray end
ps_manual=   statusdict begin /manualfeed true store end
ps_envelope= statusdict begin com10envelopetray end
ps_outupper= statusdict begin 0 setoutputtray end
ps_outlower= statusdict begin 1 setoutputtray end
ps_transparency= <</MediaType (Transparency)>> setpagedevice
ps_tumble=  statusdict begin true settumble end
ps_shortedge=[ tumble ]

# paper size selection
ps_a0=
ps_a1=
ps_a2=
ps_a3=
ps_a4=
ps_letter=
ps_ledger=
ps_11x17=[ ledger ]
ps_tabloid=[ ledger ]
ps_executive=
ps_oversize=

# PageSize Letter/US Letter: 
# from HP4Mplus PPD file
ps_letter =
    2 dict 
    dup /Policies 1 dict dup /PageSize 1 put put 
    dup /DeferredMediaSelection true put setpagedevice
    2 dict dup /PageSize [612 792] put dup /ImagingBBox null put setpagedevice
# End
# PageSize Legal/US Legal: 
ps_legal =
    2 dict 
    dup /Policies 1 dict dup /PageSize 1 put put 
    dup /DeferredMediaSelection true put setpagedevice
    2 dict dup /PageSize [612 1008] put dup /ImagingBBox null put setpagedevice
# End
# PageSize A4/A4 : 
ps_a4 =
    2 dict 
    dup /Policies 1 dict dup /PageSize 1 put put 
    dup /DeferredMediaSelection true put setpagedevice
    2 dict dup /PageSize [595 842] put dup /ImagingBBox null put setpagedevice
# End
# PageSize Executive/Executive : 
ps_executive =
    2 dict 
    dup /Policies 1 dict dup /PageSize 1 put put 
    dup /DeferredMediaSelection true put setpagedevice
    2 dict dup /PageSize [522 756] put dup /ImagingBBox null put setpagedevice
# End
# PageSize Comm10/Env Comm10: 
ps_comm10 =
    2 dict 
    dup /Policies 1 dict dup /PageSize 1 put put 
    dup /DeferredMediaSelection true put setpagedevice
    2 dict dup /PageSize [297 684] put dup /ImagingBBox null put setpagedevice
# End
# PageSize Monarch/Env Monarch: 
ps_monarch =
    2 dict 
    dup /Policies 1 dict dup /PageSize 1 put put 
    dup /DeferredMediaSelection true put setpagedevice
    2 dict dup /PageSize [279 540] put dup /ImagingBBox null put setpagedevice
# End
# PageSize DL/Env DL: 
ps_env_dl =
    2 dict 
    dup /Policies 1 dict dup /PageSize 1 put put 
    dup /DeferredMediaSelection true put setpagedevice
    2 dict dup /PageSize [312 624] put dup /ImagingBBox null put setpagedevice
# End
# PageSize C5/Env C5: 
ps_env_c5 =
    2 dict 
    dup /Policies 1 dict dup /PageSize 1 put put 
    dup /DeferredMediaSelection true put setpagedevice
    2 dict dup /PageSize [459 649] put dup /ImagingBBox null put setpagedevice
# End
# PageSize B5/Env ISO B5: 
ps_env_b5
    2 dict 
    dup /Policies 1 dict dup /PageSize 1 put put 
    dup /DeferredMediaSelection true put setpagedevice
    2 dict dup /PageSize [499 708] put dup /ImagingBBox null put setpagedevice
# End

mediaselect=3
ps_mediaselect=<</DeferredMediaSelection true /MediaPosition \%d{mediaselect}>> setpagedevice

ps_user_opts=[
	11x17 300x300 600x600 a0 a1 a2 a3 a3 a3fb a4 a4fb a5 async autoscale_36x60
	autoscale_a0 autoscale_a3 autoscale_a4 autoscale_letter autoselect b4 b5 b5 
	b6 bond bond c5 c9 cardstock cardstock cmykinkseuro cmykinksfast cmykinksswop
	cmykinkstoyo collate color color colorascolor
	colorasgray comm10 converter custom1 custom2 
	custom3 custom4 custom5 custom6 dl 
	draft duplex duplexshort duplexshortedge enhance 
	enhanced env10 envb5 envc5 envdl
	envelope envelope envmonarch executive executive 
	fast font fourup fourupl
	gamma glossy grayscale halftone halftoneenhanced
	halftonestandard heavy high init inlarge
	inlargecapacity inlower inmiddle intray1 intray1 
	intray10 intray2 intray3 intray4 intray5
	intray6 intray7 intray8 intray9 inupper
	isob5 labels labels landscape lduplex
	ledger leftbin legal legal letter
	letter letterhead letterhead lxcollate manual
	manual manualfeed mediacolor mediaselect monarch 
	nearestsizeadjust nearestsizenoadjust nineuo nineupl noenhance 
	nolxcollate normal nosmoothing nosmoothing oneup
	oneupl other outbin outbin2 outbin3
	outbin4 outbin5 outbin6 outbin7 outbin8
	outbin9 outleft outlower outputbin outupper
	oversize pagecount_code pagesize paper papersize
	plain plain policya4 policyletter portrait
	preprinted preprinted prepunched printquality promptuser
	recycled rough scalepatterns sduplex shortedge
	simplex sixteenup sixteenupl sixup sixupl
	smoothing smoothing smoothingoff smoothingon source
	standard status_code sync tabloid topbin
	transparancy transparency transparency tumble twoup
	twoupl universal w558h774 w612h935 wmallpages
	wmangle wmfirstpage wmfont wmsize wmtext
	wmtextstylehalo wmtextstylemedium wmtextstylenarrow wmtextstylewide
	11x17 a0 a1 a2 a3 a4 a5 duplex duplexshort envelope executive
	font inlower inupper lduplex ledger legal letter manual mediaselect
	outlower outupper oversize sduplex simplex tabloid transparency
  ]

#--- END PostScript

#--- START PCL


## PCL options in -Z

pcl_user_opts=[
	a3 a4 a5 autoselect bold bond cardstock 
	clearmargins color converter courier crlf delete_fonts duplex
	duplexback duplexfront duplexselect duplexshort fixed font font_id
	font_op font_primary gloss height helvetica hmi inhighcapacity
	init inlower inright intray1 intray2 intray3 intray4
	inupper italic jobseparation labels landscape lduplex ledger
	leftmargin leftoffset legal letter letterhead lf_stacker lineprinter
	linesperpage linewrap lpi manual nolinewrap normalpage orientation
	outbin outlower outupper pagesize paper papersize pc8 pitch plain 
	portrait preprinted prepunched proportional recycled rightmargin rough 
	sduplex simplex source stacker1 stacker2 stacker3 stacker4
	stacker5 stacker6 stacker7 stacker8 style symbol_set topmargin
	topoffset transparency typeface user_opts vellum vmi weight
  ]

## turn LF into CRLF
pcl_crlf=\033&k2G
## turn line wrap on
pcl_linewrap=\033&s0C
pcl_nolinewrap=\033&s1C

## paper (job) size
##  use -Zpapersize=size gets translated to pcl code to select paper
## 1 - executive, 2 - letter, 3 - legal, 6 - ledger, 25 - A5, 26 - A4, 27 - A3
## 80 - Monarch Envelope, 81 - Comm. 10 Envelope, 90 - Intl. DL Envelope
## 91 - Intl. C5 Envelope, 100 - Intl. D5 Envelope, 101 - Custom
## 71 - Hagaki Postcard, 72 - Oufuku-Hagaki Postcard
##   Note that the papersize key is specially interpreted

## name to number tranlsation
pcl_papersize_codes =  [
 executive=1 letter=2 legal=3
 ledger=6 a5=25 a4=26
 a3=27 monarch_envelope=80 comm_10_envelope=81
 intl_dl_envelope=90 intl_c5_envelope=91 intl_d5_envelope=100
 custom=101 hagaki_postcard=71 oufuku=72
 ]

# use the 'translate this value' facility
#  to get the corresponding numberical value
pcl_papersize=\033&l\%d{papersize,pcl_papersize_codes}A
pcl_letter=[ papersize=letter ]
pcl_legal=[ papersize=legal ]
pcl_ledger=[ papersize=ledger ]
pcl_a5=[ papersize=a5 ]
pcl_a4=[ papersize=a4 ]
pcl_a3=[ papersize=a3 ]
pcl_pagesize=[ papersize=%s{pagesize} ]
pcl_paper=[ papersize=%s{paper} ]


## paper source selection
##   use -Zsource=n
## 0 - current, 1 - upper, 2 - manual paper, 3 - manual envelope
## 4 - lower,   5 - optional paper, high capacity
## 6 - optional manual or envelope feeder, 7 - autoselect, 8 right side
## 20-39 high capacity input trays 2-21

source=0
pcl_source=\033&l\%d{source}H
pcl_inupper=\033&l1H
pcl_manual=\033&l2H
pcl_inlower=\033&l4H
pcl_inhighcapacity=\033&l5H
pcl_autoselect=\033&l7H
pcl_inright=\033&l8H

## orientation
##  0 - portrait, 1, landscape, 2 - reverse portrait, 3 reverse landscape
pcl_orientation=\033&l\%d{orientation}O
pcl_portrait=\033&l0O
pcl_landscape=\033&l1O

## simplex or duplex
##  0 - simplex,  1 - duplex long edge, 2 - duplex short edge
pcl_simplex=\033&l0S
pcl_duplex=\033&l1S
pcl_lduplex=[ duplex ]
pcl_duplexshort=\033&l2S
pcl_sduplex=[ duplexshort ]

## offsets
##  these are specified in 1/720 inch units
##  i.e. - if you want 1/2 inch, you need  720 x .5 = 360 units
leftoffset=0
pcl_leftoffset=\033&l\%d{leftoffset}U
topoffset=0
pcl_topoffset=\033&l\%d{topoffset}Z

## duplex page side selection
duplex_select=1
pcl_duplexselect=\033&a\%d{duplexselect}G
pcl_duplexfront=\033&a1G
pcl_duplexback=\033&a2G

## job separaton
pcl_jobseparation=\033&l1T

## output bin 
## 0 - auto, 1 - bin 1,top/facedown 2 - bin 2,left/faceup
## 3 - bin 3 (HCO faceup)
## 4 - bin 4 (HCO 1, facedown)
## 5 - bin 5 (HCO 2, facedown)
## 6 - bin 6 (HCO 3, facedown)
## 7 - bin 7 (HCO 4, facedown)
## 8 - bin 8 (HCO 5, facedown)
## 9 - bin 9 (HCO 6, facedown)
## 10 - bin 10 (HCO 7, facedown)
## 11 - bin 11 (HCO 8, facedown)

outbin=1
pcl_outbin=\033&l\%d{outbin}G
pcl_outupper=\033&l1G
pcl_outlower=\033&l2G

## margins
pcl_clearmargins=\0339
leftmargin=0
pcl_leftmargin=\033&a\%d{leftmargin}L
rightmargin=80
pcl_rightmargin=\033&a\%d{rightmargin}M
topmargin=0
pcl_topmargin=\033&l\%d{topmargin}E
linesperpage=66
pcl_linesperpage=\033&l\%d{linesperpage}F

## the HMI (Horizontal Motion Index)
##  this is dangerous...
##  This is the number of 1/120 inch unit per character
##  i.e. - 120 unit per inch
##  If you want 10 cpi, you want HMI = 120/10 = 12
hmi=12
pcl_hmi=\033&k\%d{hmi}H

## the VMI (Vertical Motion Index)
##  this is dangerous...
##  This is the number of 1/48 inch unit per line
##  i.e. - 48 unit per inch
##  If you want 6 lines per inch, you want HMI = 48/6 = 8
vmi=8
pcl_vmi=\033&l\%d{vmi}C

## the LPI (Lines Per Inch) - inverse of VMI
##  This is the lines per line
##  If you want 6 lines per inch, you want LPI = 6
lpi=6
pcl_lpi=\033&l\%d{lpi}D

## symbol set
##  - don't fool around with this one...
## 10U = PC 8 - shows the funny PC characters???
##
symbol_set=8U
pcl_symbol_set=\033(\%s{symbol_set}
pcl_pc8=\033(10U

## spacing
##  0 - fixed, 1 - proportional
pcl_fixed=\033(s0P
pcl_proportional=\033(s1P

## pitch for fixed spaced font
##  in characters per inch
pitch=10
pcl_pitch=\033(s\%3.2f{pitch}H

## height for proportional spaced font
##  in points
height=10
pcl_height=\033(s\%3.2f{height}V

## style for proportional spaced font
##  0 - normal, 1 - italic, 4 condensed, etc
style=0
pcl_style=\033(s\%d{style}S
pcl_italic=\033(s1S


## weight -
##  ranging from -7 (ultra thin) to 7 (ultra black)
weight=0
pcl_weight=\033(s\%d{weight}B
pcl_bold=\033(s3B

## Typeface Family
## See Appendic C in the PCL 5 comparison guide
##   consists of foundary * 4096 + fontid
##   foundary = 1 - AGFA, 2- Bitstream, etc 
##   fontid   = 0 - line printer, 3 = courier, 4 = helvetica
##   id 4099 - Courier
##      4100 - Helvetica
##
typeface=4099
pcl_typeface=\033(s\%d{typeface}T
pcl_courier=\033(s4099T
pcl_helvetica=\033(s4100T
pcl_lineprinter=\033(s0T


##
## Fonts and Font Downloading
##  fontid is used to set the current font
font_id=1
pcl_font_id=\033*c\%d{font_id}D
## set primary font
font_primary=1
pcl_font_primary=\033(\%d{font_primary}X

## font control
##
font_op=0
pcl_font_op=\033*c\%d{font_op}F
pcl_delete_fonts=\033*c0F

## font directory
font=c1201b.10
pcl_fontdir=/dev/env/DJDIR/etc/filters/fonts/pcl

## combination command
pcl_font=[ delete_fonts font_id font_download font_primary ]

## canned setup
pcl_normalpage=[ letter crlf linewrap portrait clearmargins fixed pitch=10 courier ]

pcl_init=[ normalpage ]
# put things here that should go at the VERY end of the PCL job
# but before the PCL EOJ
#pcl_term=[ ]

##
## Forced processing of all files
##  (option: forceprocessing)
##
##  Problem:  you want to process all files that pass through ifhp
##   including literal files. Basically, you want to ignore the -c
##   option which LPRng has passed in.
##
##  Setting forceprocessing to true will force ifhp to process all files
##  which are passed to it, ignoring the -c option. Jobs for autodetect
##  printers are not processed.
##  This can be useful when you want to process all print jobs which arrive.
##  eg: to add a 'colorasgray' before all jobs to force colour printouts to
##  come out in grayscale. Without forceprocessing users can specify -b|-l
##  to lpr and get around the conversion.
##
# Set forceprocessing to process all files.

forceprocessing@

##
## Text and Incompatible file type conversion control
##
##  Problem:  you get files of very odd type and want to print
##   them,  but you need a converter program to do so
##
## Step 0:  set default file language type.  This is used if the
##   the language type is explicitly determined.
##    default_language=unknown
##
## Step 1:  determine file type
##
##  Method 1 - SIMPLE, BUT LIMITED - let ifhp detect the file type
##  this will be pjl, ps, text, or unknown
##  (option: forceconversion@, file_util_path=)
##
##  Method 2 - POWERFUL, BUT MORE COMPLEX
##   Force the file utility to find the file type
##       - the file utility's output is lower cased,
##       multiple whitespace is removed, and all white space
##       (blanks, tabs, LF, HT, etc) are replaced
##       by underscores
##  (option: forceconversion, file_util_path=/path_to_file_utility)
##
##  Method 3: - let ifhp try to find the simple ones,
##     and then use file utiltyh.  (default)
##  (option: forceconversion@, file_util_path=/path_to_file_utility)
##
## Step 2:  do conversion
##
## file_output_match = [
##   *pcl*        pcl \%s{pcl_converter}
##   *ps*         ps  \%s{ps_converter}
##   *postscript* ps  \%s{ps_converter}
##   *pjl*        pjl \%s{pjl_converter}
## # if your printer understands PCL, use the next line
## # *text*       pcl \%s{pcl_converter}
## # if your printer only understands PostScript, use the next line
##   *text*       ps  \%s{text_converter}
##   *pdf*        ps  \%s{pdf2ps_converter}
##   *_gif_*  pcl /dev/env/DJDIR/etc/filters/gif2pcl --autosize -x 2400 -y 3300 -d=300 -o-
##   *            unknown
## # for rasterizing
## # if you need to rasterize, use: 
##   *text*       raw  \%s{text_converter}
##   *ps*         raw  \%s{ps_converter}
##   *postscript* raw  \%s{ps_converter}
##   *gif*        filter \%s{gif_to_ps_converter}
##   *            msg  no_converter
## ]
##   *text*       ps  /dev/d/usr/djgpp/bin/a2ps -q -B -1 -M Letter --borders=no -o-
##   ^^^ glob match
##                ^^ result type
##                    ^^ optional conversion program
##
## 
## We match the (method 1) determined file type file or (method 2)
## file utility output against a 'glob' pattern.  This pattern is URL
## encoded so that it can include spaces or other characters.
## 
## The if there is a match,  the resulting conversion output type is set to
## the second entry.  If this is 'unknown', then the file is not
## printed.
##
## If the conversion output type is 'filter',  then the converter is
## run on the file and the converted output is used again.  For example:
##   *gzip_compressed* filter gzip -c -d
## This would cause the gzip program to be used to uncompress the file
##
## If the file type is "msg" then the message value is sent
## and the ifhp exits with a 0 (successful) status.  The converter name
## is used to select the type of error message.  If the converter name is xx,
## If PostScript is available then the contents of ps_xxx will be sent to the
## standard output; if PCL is available then pcl_xx will
## be sent,  the value of xx will be sent. See below for a typical value and
## way to use this.
##  The following values are available:
## \%s{file_output} is set to the output of the the 'file' program
## \%s{pgm} is set to the converter program value
## \%s{msg} to the error message for file conversion failure
##   - this is the value of the command line -e option if it was specified
##     as LPRng passes the input file as the value of the -e option
##     OR /dev/fd/0 if no -e value was specified
##     OR - if the operating system does not support the /dev/fd facility
##
## The third entry (and rest of line) is the conversion program and
## options to use.  As shown above, this can be an option whose
## value is expanded and substituted.  For example:
##
## gs_converter= /dev/d/usr/djgpp/bin/gs -dSAFER -dPARANOIDSAFER -dBATCH -dNOPAUSE -q '-sOutputFile=/dev/fd3' 3>&1 1>&2
##   -sDEVICE=\%s{gs_device} \%s{gs_options} \%s{inputfile}
##
## Note: the above clever trick was used by the Foomatic (www.linuxprinting.org)
##   but has been since spotted in the wild in other scripts.
##
## \%s{inputfile} is set to the input file path
##   - this is the value of the command line -e option if it was specified
##     as LPRng passes the input file as the value of the -e option
##     OR /dev/fd/0 if no -e value was specified
##     OR - if the operating system does not support the /dev/fd facility
##
##
## ps_converter= [ \%s{gs_converter} ]
##
##
## a2ps_converter= /dev/d/usr/djgpp/bin/a2ps -q -B -1 -M Letter --borders=no -o-
## text_converter= [ \%s{a2ps_converter} ]
##
## If no conversion is specified,  then the original
## file is used.  If the program has pipe or meta characters,  then
## it is executed using /bin/sh -C 'program spec',   allowing you to
## pipe output of one program to another.
##
## 
##  The converter program command line ZOPTS and TOPTS words are replaced with
##  the values of the -Z flag and options and -T flag and options respectively,
##  and the ARGV word with the entire set of ifhp filter command line options.
##  For example,  if the filter was /dev/env/DJDIR/etc/filters/mystuff ZOPTS
##  and you did lpr -Zlandscape,  then you would get
##     /dev/env/DJDIR/etc/filters/mystuff -Zlandscape.
##  This allows you to pass options to the converter
##
##  The conversion program exit status must be 0 for successful conversion.
##  Please note that programs such as enscript exit with non-zero
##  exit status when they perform conversions correctly but need to wrap lines,
##  or have some minor difficulty with non-ascii characters in the input.
##  The use of a wrapper such as shown below is recommended,  and is the
##  default with ifhp:
##    #!/bin/sh
##    # /dev/env/DJDIR/etc/filters/wrapper path [options]
##    # wrapper script for enscript and others
##    #   path is the path to the program and options are the
##    #   options to pass.  The program is run and then the exit
##    #   code is corrected
##    program=$1
##    status=1;
##    shift
##    if test -n "$program" ; then
##      $program "$@"
##      status=$?
##    fi;
##    case "$status" in
##      1 ) exit $status;;
##    esac
##    exit 0
## 
##  Spaces in the file utility output can be matched with %20
##  (URL escaped space)
## 
##  file - utility to determine file type
##     ftp://ftp.astron.com/pub/file/
##     ftp.deshaw.com/pub/file/
##   OR
##	    ftp://ftp.lpng.com/pub/LPRng/UNIXTOOLS/file/
##     Also available from the RedHat.com SRPMS in (of course) rpm format

# set forceconversion to force the file(1) utility to be used
default_language=text
forceconversion@

##  UNIX File utility path
file_util_path= /dev/d/usr/djgpp/bin/file \%s{inputfile}
##  Patterns and Converters
# example conversion program
file_output_match = [
  *postscript*  ps   \%s{ps_converter}
  *pdf*         ps   \%s{pdf2ps_converter}
  *pcl*         pcl  \%s{pcl_converter}
  *pjl*         pjl  \%s{pjl_converter}
  *printer*job*language* pjl
  *text*  pcl  \%s{text_converter}
  *gzip_compressed*  filter  \%s{gzip_decompress}
  *             msg  no_converter
  ]

ps_no_converter = %!PS-Adobe-3.0
  /Courier
  findfont 10 scalefont setfont
  72 500 moveto
  (No conversion available for type '\%s{file_output}') show
  showpage

no_converter = No conversion available for type '\%s{file_output}'

ps_conversion_error = %!PS-Adobe-3.0
  /Courier
  findfont 10 scalefont setfont
  72 500 moveto
  (Conversion failed for type '\%s{file_output}') show
  72 480 moveto
  (Using '\%s{pgm}') show
  72 460 moveto
  (Error: '\%s{msg}') show
  showpage

conversion_error =  Conversion failed for type '\%s{file_output}'
  Using '\%s{pgm}'
  Error: '\%s{msg}'

# gs_device=epsonc
# gs_options=-r240x72
# gs_converter= /dev/d/usr/djgpp/bin/gs -dSAFER -dPARANOIDSAFER -dBATCH -dNOPAUSE -q '-sOutputFile=/dev/fd3' 3>&1 1>&2
#   \%s{gs_options} \%s{inputfile}
# 
#
gs_converter=  /dev/d/usr/djgpp/bin/gs -dSAFER -dPARANOIDSAFER -dBATCH -dNOPAUSE -q '-sOutputFile=/dev/fd3' 3>&1 1>&2 -sPAPERSIZE=\%L{papersize} -sDEVICE=\%s{gs_device} \%s{gs_options} \%s{inputfile}
gs_unidriver=  /dev/d/usr/djgpp/bin/gs -dSAFER -dPARANOIDSAFER -dBATCH -dNOPAUSE -q '-sOutputFile=/dev/fd3' 3>&1 1>&2 -sPAPERSIZE=\%L{papersize} @\%s{gs_device} \%s{gs_options} \%s{inputfile}
a2ps_options= -q -B -1 -M \%M{papersize} --borders=no -o-
a2ps_converter= /dev/d/usr/djgpp/bin/a2ps \%s{a2ps_options} \%s{inputfile}

pdf2ps_converter=  /dev/d/usr/djgpp/bin/gs -dSAFER -dPARANOIDSAFER -dBATCH -dNOPAUSE -q '-sOutputFile=/dev/fd3' 3>&1 1>&2 -sDEVICE=pswrite \%{pdf2ps_options} -c save pop -f \%s{inputfile}


ps_converter=
pcl_converter=
pjl_converter=
text_converter=

## you may need a temp file location
##
##  This will be extended to ..ifhpXXXXX
##   for use by the unix mktemp() routine
##
#tempfile=/var/tmp/ifhp

## Printer Specific Configurations

## Apple or PostScript Printers
# PRINTER % - PostScript printer, text to PS conversion, status, pagecount support
[ apple postscript ps ]
pjl@
pcl@
ps
text@
file_output_match = [
  *postscript*       ps
  *text*             ps  \%s{a2ps_converter}
  *pdf*              ps  \%s{pdf2ps_converter}
  *gzip_compressed*  filter  \%s{gzip_decompress}
  ]


## Apple or PostScript Printers
## PRINTER % - PostScript printer connected using appletalk
#  Note 1: you need to use the updated version of pap that
#   puts out status messages with "%%[ ... ]%%" around them
#   See the ifhp/UTILS/pap.c and ifhp.UTILS/README.pap files
#
# Here is the printcap that we started with:
# ps
#	:sd=/var/tmp/LPD/%P
#	:filter=/usr/libexec/filters/ifhp
#	:ifhp=model=ps,ps_eoj@,debug=4,ps_ctrl_t@,\
#    end_status=idle waiting,pagecount_poll_start=1\
#    pagecount_poll_end=5
#	:mx=0
#	:lp=| $- /usr/local/bin/pap -p "PET\:LaserJet 2200"
#
# Use: ifhp=model=ps_appletalk
# 
# 
[ ps_appletalk ]
tc=ps
ps_eoj@
ps_ctrl_t@
end_status=idle waiting
pagecount_poll_start=1
pagecount_poll_end=5

## PCL Only Printer
# PRINTER % - PCL only printer, no status
[ pcl ]
status@
pjl@
pcl
ps@
text@
file_output_match = [
  *pcl*  pcl
  *text*  pcl
  *gzip_compressed*  filter  \%s{gzip_decompress}
 ]

# PRINTER % - HP Laserjet 4 PCL only printer, write only, no status
[ pcl_gs ]
status@
pjl@
pcl
ps@
text@
gs_device=ljet4
file_output_match = [
  *pcl*  raw
  *text*  pcl
#  postscript to PCL conversion
  *postscript*  raw \%s{gs_converter}
  *pdf*   filter \%s{pdf2ps_converter}
  *gzip_compressed*  filter  \%s{gzip_decompress}
 ]

# TEMPLATE % - GhostScript PostScript to raster conversion, write only, no status
[ ghostscript gs ]
status@
pcl@
pjl@
ps
text@
# something for a default
gs_device=ljet4
file_output_match = [
  *postscript*       raw     \%s{gs_converter}
  *pdf*              filter  \%s{pdf2ps_converter}
  *text*             filter  \%s{a2ps_converter}
  *gzip_compressed*  filter  \%s{gzip_decompress}
 ]

## HP Printers

## These all support PJL to a limited extent and PCL
##  WARNING: PCL versions differ,  and some PCL is actually
##  the dreaded 'raster format' for PPA (no,  I don't know
##  what the acronym means) format.
##  PCL now comes in versions 3, 4, 5.  Enjoy.
##  Patrick Powell
### 

# PRINTER % - HP LaserJet III (PCL and PostScript Interpreter)
[ hpiiisi hp3si ljet3 lj3 ]
pjl_only=[
    COMMENT ENTER
  ]

### 
# PRINTER % - HP LaserJet III (PCL, PostScript via GhostScript)
[ hpiiisi.gs hp3si.gs ljet3.gs lj3.gs ]
tc=pcl_gs
gs_device=ljet3
pjl_only=[
    COMMENT ENTER
  ]


# PRINTER % - HP LaserJet 4 Family, HP LaserJet {/hp(.*)/$1/} (PostScript Interpreter)
[ hp4 hp4m hp4si hp4simx hp4plus hp4mplus hp4v hp4mv hp4p hp4mp hp4pj hpljpro hp4lc ]

pjl_except=[
    FSAPPEND FSDIRLIST FSQUERY FSUPLOAD FSDELETE FSDOWNLOAD FSINIT FSMKDIR
  ]

# HP LaserJet 4M, has limited pagecount capability
[ hp4m ]
pagecount=ps

#
# Provided by Wilfried.Gaensheimer@infineon.com
#   --- Note: see also the HP5000 and HP8000 entries
# If you know "more", let me (Wilfried.Gaensheimer@infineon.com) know
#
# PRINTER hp4mplus - HP LaserJet 4MPlus
[ hp4mplus ]

pjl_only=[
    COMMENT DEFAULT DINQUIRE ECHO ENTER EOJ
    FSAPPEND FSDIRLIST FSQUERY FSUPLOAD FSDELETE FSDOWNLOAD
    FSINIT FSMKDIR
    INFO INITIALIZE INQUIRE JOB OPMSG PJL RDYMSG
    RESET SET STMSG USTATUS USTATUSOFF
    COPIES
  ]

#
# Some options do not really apply to the hp4mplus
# (I used that entry to try the new 4500 DN, too).
# - select tray (I left all of them in, of course the hp4mplus
#   doesn't have all of them ....)
# - manual feed
# - duplex, shortedge, ....
# - select a4 or letter or legal paper
# - set printquality and/or resolution (I guess that will
#    interact if you use both)
# - select rendermode (does not apply to the hp4mplus ...
#
# If you know "more", let me (wig or Wilfried.Gaensheimer@infineon.com)
# know. Or if I got it wrong (i'm still trying to figure out
# how this works) ... wig
#


pjl_printquality=@PJL SET PRINTQUALITY = \%s{printquality}
pjl_draft=@PJL SET PRINTQUALITY = DRAFT
pjl_normal=@PJL SET PRINTQUALITY = NORMAL
pjl_high=@PJL SET PRINTQUALITY = HIGH

pjl_rendermode=@PJL SET RENDERMODE = \%s{rendermode}
pjl_color=@PJL SET RENDERMODE = COLOR
pjl_grayscale=@PJL SET RENDERMODE = GRAYSCALE

pjl_user_opts += [
	color draft grayscale
	high normal printquality rendermode
  ]


# HP LaserJet 4 Family, HP LaserJet {/hp(.*)/$1/}
[ hp4v hp4mv ]
# Paper Selection By Size

ps_letter= <</DeferredMediaSelection true /PageSize [612 792] /ImagingBBox null>> setpagedevice
ps_legal= <</DeferredMediaSelection true /PageSize [612 1008] /ImagingBBox null>> setpagedevice
ps_ledger=<</DeferredMediaSelection true /PageSize [792 1224] /ImagingBBox null>> setpagedevice
ps_oversize=<</DeferredMediaSelection true /PageSize [842 1274] /ImagingBBox null>> setpagedevice
ps_a3 = <</DeferredMediaSelection true /PageSize [842 1191] /ImagingBBox null>> setpagedevice
ps_a4 = <</DeferredMediaSelection true /PageSize [595 842] /ImagingBBox null>> setpagedevice


# PRINTER % - HP LaserJet 5 Family, Hp Laserjet {/hp(.*)/$1/}
[ hp5l ]
pjl_except=[
    EOJ JOB OPMSG RDYMSG STMSG
    FSAPPEND FSDIRLIST FSQUERY FSUPLOAD FSDELETE FSDOWNLOAD FSINIT FSMKDIR
  ]

# PRINTER % - HP LaserJet 6 Family, Hp Laserjet {/hp(.*)/$1/}
[ hp6l hp1100 ]
pjl_except=[
    EOJ JOB OPMSG RDYMSG STMSG
    FSAPPEND FSDIRLIST FSQUERY FSUPLOAD FSDELETE FSDOWNLOAD FSINIT FSMKDIR
  ]

# PRINTER % - HP LaserJet 1000 Family, Hp Laserjet {/hp(.*)/$1/}
[ hp1100 ]
pjl_except=[
    EOJ JOB OPMSG RDYMSG STMSG
    FSAPPEND FSDIRLIST FSQUERY FSUPLOAD FSDELETE FSDOWNLOAD FSINIT FSMKDIR
  ]


# PRINTER % - Hp LaserJet 4L, PCL only
[ hp4l ]
status@
pjl@
pcl
ps@
text@
#Using 'laserjet', the printed area is shifted to the right on a 'portrait
#letter' piece of paper.  Using 'ljet4', it prints centered.  I.e., it
#looks better.
# 
#  Luca Filipozzi, Debian Developer
#gs_device=laserjet
gs_device=ljet4

gs_options=-r300x300
file_output_match = [
  *pcl*  pcl
  *text*  pcl
#  postscript to PCL conversion
  *postscript*  pcl \%s{gs_converter}
  *pdf*              filter  \%s{pdf2ps_converter}
  *gzip_compressed*  filter  \%s{gzip_decompress}
 ]



# PRINTER % - HP LaserJet {/hp(.*)/$1/}
[ hp4ml hp5p hp5mp hp6p hp6mp ]
pjl_except=[
    OPMSG RDYMSG STMSG
    FSAPPEND FSDIRLIST FSQUERY FSUPLOAD FSDELETE FSDOWNLOAD FSINIT FSMKDIR
  ]

# PRINTER % - HP LaserJet {/hp(.*)/$1/}
[ hp5 hp5si hp5simx hp5m ]

pjl_except=[
    FSAPPEND FSDIRLIST FSQUERY FSUPLOAD
  ]

# There may be problems with the copypage and EOJ interaction
#ps_init = [ nocopypage ]
#ps_nocopypage = /copypage {showpage} def

# put things here that should appear at the very very end
#  of the PostScript job,  but BEFORE the ^D at end

#ps_term = [ stopduplex ]
#ps_stopduplex = statusdict begin false setduplexmode end


ps_manual=<</ManualFeed true>> setpagedevice
ps_envelope=<</DeferredMediaSelection true /MediaPosition 2>> setpagedevice

ps_inupper=[ intray1 ]
ps_inlower=[ intray2 ]

## *InputSlot Tray1/Tray 1:
ps_intray1=<</DeferredMediaSelection true /MediaPosition 3>> setpagedevice

##InputSlot Tray2/Tray 2: 
ps_intray2=<</DeferredMediaSelection true /MediaPosition 0>> setpagedevice

##InputSlot Tray3/Tray 3: 
ps_intray3=<</DeferredMediaSelection true /MediaPosition 1>> setpagedevice

##InputSlot Tray4/Tray 4: 
ps_intray4=<</DeferredMediaSelection true /MediaPosition 4>> setpagedevice

# Paper Selection By Size
ps_letter= <</DeferredMediaSelection true /PageSize [612 792] /ImagingBBox null>> setpagedevice
ps_legal= <</DeferredMediaSelection true /PageSize [612 1008] /ImagingBBox null>> setpagedevice
ps_ledger=<</DeferredMediaSelection true /PageSize [792 1224] /ImagingBBox null>> setpagedevice
ps_oversize=<</DeferredMediaSelection true /PageSize [842 1274] /ImagingBBox null>> setpagedevice
ps_a3 = <</DeferredMediaSelection true /PageSize [842 1191] /ImagingBBox null>> setpagedevice
ps_a4 = <</DeferredMediaSelection true /PageSize [595 842] /ImagingBBox null>> setpagedevice


## *OutputBin Upper/Top Output Bin (Face Down):
##ps_outupper=<</Staple 0 /OutputType (TOP OUTPUT BIN)>> setpagedevice
## *OutputBin Left/Left Output Bin (Face Up):
##ps_outlower=
##   currentpagedevice /OutputAttributes get
##   5 known
##         {<</Staple 0 /OutputType (FACE UP BIN)>> setpagedevice}
##         {<</Staple 0 /OutputType (LEFT OUTPUT BIN)>> setpagedevice}
##       ifelse
##
## *OutputBin Stacker/Stacker (Face Down):
ps_outbin2=<</Staple 0 /OutputType (OPTIONAL OUTBIN 2)>> setpagedevice

## *OutputBin Separator/Job Separator (Face Down): 
ps_outbin3=<</Staple 0 /OutputType (OPTIONAL OUTBIN 2)>> setpagedevice

## *OutputBin Stapler/Stapler (Face Down):         
ps_outbin4=<</Staple 2>> setpagedevice

## *OutputBin OutputBin1/Mailbox 1 (Face Down):    
ps_outbin5=<</Staple 0 /OutputType (OPTIONAL OUTBIN 2)>> setpagedevice

## *OutputBin OutputBin2/Mailbox 2 (Face Down):    
ps_outbin6=<</Staple 0 /OutputType (OPTIONAL OUTBIN 3)>> setpagedevice

## *OutputBin OutputBin3/Mailbox 3 (Face Down):    
ps_outbin7=<</Staple 0 /OutputType (OPTIONAL OUTBIN 4)>> setpagedevice

## *OutputBin OutputBin4/Mailbox 4 (Face Down):    
ps_outbin8=<</Staple 0 /OutputType (OPTIONAL OUTBIN 5)>> setpagedevice

## *OutputBin OutputBin5/Mailbox 5 (Face Down):    
ps_outbin9=<</Staple 0 /OutputType (OPTIONAL OUTBIN 6)>> setpagedevice

## *Duplex None/Off: 
ps_simplex=
     <</Duplex false /Tumble false>> setpagedevice
## *Duplex DuplexNoTumble/Long-Edge Binding: 
ps_duplex=
	<</Duplex true /Tumble false>> setpagedevice
ps_lduplex= [ duplex ]
## *Duplex DuplexTumble/Short-Edge Binding: 
ps_duplexshort=
	<</Duplex true /Tumble true>> setpagedevice
ps_sduplex= [ duplexshort ]

ps_tumble=<</Tumble true>> setpagedevice
ps_shortedge=[ tumble ]

ps_user_opts += [
	letter ledger simplex duplex
    intray1 intray2 intray3 intray4
    outbin2 outbin3 outbin4 outbin5 outbin6 outbin7 outbin8 outbin9
 ]


## We have printcap information
[ hp4000_pcl ]
## pcl paper source selection
##   use -Zsource=n
## 0 - current, 1 - tray 2 (first cassette), 2 - manual
## 3 - ????
## 4 - tray 1 (Multipurpose), 5 - tray 3 (second cassete)
## 6 - envelope    8 - tray 4 (third cassette)
## 20-39 high capacity input trays 2-21
##

pcl_intray1=\033&l4H
pcl_intray2=\033&l1H
pcl_intray3=\033&l5H
pcl_intray4=\033&l8H

pcl_bond         = \033&n5WdBond
pcl_plain        = \033&n6WdPlain
pcl_color        = \033&n6WdColor
pcl_labels       = \033&n7WdLabels
pcl_recycled     = \033&n9WdRecycled
pcl_letterhead   = \033&n11WdLetterhead
pcl_cardstock    = \033&n10WdCardstock
pcl_prepunched   = \033&n11WdPrepunched
pcl_transparency = \033&n13WdTransparency

pcl_user_opts += [
    intray1 intray2 intray3 intray4
    bond plain color labels recycled
    letterhead cardstock prepunched transparency
 ]

# now we define the additional goodies that we have

# PRINTER % - HP LaserJet {/hp(.*)/$1/}
[ hp5simopier hp4000 ]
tc=hp4000_pcl


# PRINTER % - HP Color LaserJet {/hpcolorlj(.*)/$1/}
[ hpcolorlj hpcolorlj5 hpcolorlj5m ]
pjl_only=[
    COMMENT ECHO ENTER EOJ
    INFO INITIALIZE INQUIRE JOB PJL RDYMSG
    USTATUS USTATUSOFF
  ]

# PRINTER hpdj1200 - HP Design Jet 1200 Family
[ hpdj1200 ]
pjl_only=[
    COMMENT ENTER
    PJL
  ]
status@


# PRINTER hppjxl300 - HP Paint Jet XL 300 Family
[ hppjxl300 ]
pjl_only=[
    COMMENT ENTER
    PJL
  ]
status@

# PRINTER hpdj1600 - HP Design Jet 1600 Family
[ hpdj1600 ]
pjl_only=[
    COMMENT DEFAULT DINQUIRE ECHO ENTER EOJ
    JOB PJL
    RESET SET
  ]

# PRINTER % - HP DeskJet {/hpdj(.*)/$1/}
[ hpdj200 hpdj220 hpdj600 hpdj650 ]

pjl_only=[
    COMMENT ECHO ENTER
    INFO 
    USTATUS USTATUSOFF
  ]

# PRINTER % - HP DeskJet {/hpdj(.*)/$1/}
[ hpdj230 hpdj250c hpdj330 hpdj350c hpdj430 hpdj450c hpdj455ca hpdj700 hpdj750c hpdj750cplus hpdj755cm hpdj2000cp ]
pjl_only=[
    COMMENT ECHO ENTER EOJ
    INFO JOB RESET SET
    USTATUS USTATUSOFF
  ]


#
# The HP Design Jet 2500 CP and the HP2500 (hp2500) are NOT the same
#
# hp2500 hp2500cm chp2500c
# HP 2500C, HP 2500C+ and HP 2500CM - What's the Difference?
# 
# HP 2500C
# 
# The HP 2500C with 4MB RAM is a network capable printer for Windows
# and DOS. This is the base model in the HP 2500C series printer
# family. The printer is designed to leverage existing hardware
# investments with the flexibility to install a HP MIO print server,
# upgrade with Adobe PostScript 3 or PCL 5Ce and memory up to 84MB
# RAM when you need it.
# 
# HP 2500C+2
# 
# The HP 2500C+ with 12 MB RAM and PCL 5Ce, is a network capable
# printer designed to serve users who have standardized on a PCL 5Ce
# printing solution or require a replacement for the DeskJet 1200C
# or DeskJet 1600C series of color inkjet printers. This printer also
# offers the flexibility to install a HP MIO print server, upgrade
# with Adobe Postscript 3 and memory up to 84 MB RAM, when you need
# it.
# 
# HP 2500CM 
# 
# The HP 2500CM with 20 MB RAM and Adobe PostScript 3 is a network
# ready printer for Macintosh, Windows and DOS. This printer is
# designed for immediate workgroup connectivity with built-in HP MIO
# print server and true Adobe PostScript 3, upgradable to a total of
# 84MB RAM for maximum document portability.
# 

# PRINTER % - HP Design Jet {/hp(.*)/$1/} - No PCL, PostScript Only
[ hp2500 hp2500cm hp2500c ]

# no PCL, only PostScript and limited PJL
pcl@
ps
pjl
# some firmware releases for this printer do not like ^D
ps_eoj@

pjl_only=[
    COMMENT ECHO ENTER EOJ
    INFO JOB RESET SET
    USTATUS USTATUSOFF
  ]

# PRINTER % - HP Design Jet {/hp(.*)/$1/} - PCL and PostScript
[ hp2500cm ]
tc=hp2500
pcl

# PRINTER hpdj2500cp - HP DesignJet 2500CP, not HP2500, HP2500c, HP2500cm
[ hpdj2500cp ]

# Supplied by: Wilfried.Gaensheimer@infineon.com
# my try to get most out of our HP DesignJet 2500 ...
# please let me (Wilfried.Gaensheimer@infineon.com) know when I got it wrong  ...
#wig19990813
#   Modified Patrick Powell Fri Aug 13 11:14:35 PDT 1999

pjl_only=[
    COMMENT ECHO ENTER EOJ
    INFO JOB RESET SET
    USTATUS USTATUSOFF
  ]

# This device does not support pagecount (obvious ...)
pagecount@

#
# According to my copy of the PJL reference guide it supports
# only the DEVICE and the TIMED USTATUS commands ...
# I just don't know what these are for ... ?
#
pjl_ustatus=
    @PJL USTATUSOFF
    @PJL USTATUS DEVICE = ON
    @PJL USTATUS TIMED = 10

#
# setting orientation, printqualtity, rendermode with PJL did not work ...
# I left them in, but PostScript seems to be the better place ...
#
#
# DesignJet does not honor these PJLs???
# O.k., so we resort to ps_ (see below) ....
# I left them in because they might work one day ....
#
pjl_a3=@PJL SET PAPERLENGTH = 8420
       @PJL SET PAPERWIDTH = 11910

pjl_draft=@PJL SET PRINTQUALITY = DRAFT
pjl_normal=@PJL SET PRINTQUALITY = NORMAL
pjl_high=@PJL SET PRINTQUALITY = HIGH

pjl_color=@PJL SET RENDERMODE = COLOR
pjl_grayscale=@PJL SET RENDERMODE = GRAYSCALE

pjl_user_opts += [ 
    autoselect autoconf
    paperlength paperwidth printquality draft normal high
    gamma color greyscale rendermode 
    ]
  
#
# We need to use the PostScript options ...
# Some of them might be there because of copy&paste ...
#
#
# The options allow to:
#   - choose manualfeed
#   - choose certain papersizes ( fb is for full bleed)
#   - scale on papersize to another (use -Za4,autoscale_a3)
#   - choose rendermode (color vs. grayscale)
#   - set gamma (defaults to 0.333, allows to reduce intensity
#     for ink based printing of "real" pictures
#   - set orientation
#   - set printquality
#   - set resolution (t.b.d.)
#   
# BTW.: If you want to have a A3 printed in endless paper, combine that
#   with the "landscape" option

ps_autoscale_letter=/HPDict /ProcSet findresource /SetAutoScale get
        true exch exec /HPDict /ProcSet findresource /SetDestinationPageSize
        get [612 792 ] exch exec <<>> setpagedevice

ps_autoscale_a4=/HPDict /ProcSet findresource /SetAutoScale get
        true exch exec /HPDict /ProcSet findresource /SetDestinationPageSize
        get [595 842] exch exec <<>> setpagedevice

ps_autoscale_a3=/HPDict /ProcSet findresource /SetAutoScale get
        true exch exec /HPDict /ProcSet findresource /SetDestinationPageSize
        get [842 1191] exch exec <<>> setpagedevice

ps_autoscale_a0=/HPDict /ProcSet findresource /SetAutoScale get
        true exch exec /HPDict /ProcSet findresource /SetDestinationPageSize
        get [2384 3370] exch exec <<>> setpagedevice

ps_autoscale_36x60=/HPDict /ProcSet findresource /SetAutoScale get
        true exch exec /HPDict /ProcSet findresource /SetDestinationPageSize
        get [2592 4320] exch exec <<>> setpagedevice

ps_a4=<</PageSize[595 842]/ImagingBBox null>> setpagedevice

# full bleed ...
ps_a4fb=<</PageSize[760 1059]/ImagingBBox null>> setpagedevice

ps_a3=<</PageSize[842 1191]/ImagingBBox null>> setpagedevice

ps_a3fb=<</PageSize[1007 1408]/ImagingBBox null>> setpagedevice

ps_a0=<</PageSize[2384 3370]/ImagingBBox null>> setpagedevice

ps_grayscale=<< /ProcessColorModel /DeviceGray >> setpagedevice

ps_color=<< /ProcessColorModel /DeviceCMYK >> setpagedevice

ps_landscape=userdict /HPCustTrans known
  {
    (<<) cvx exec
    /Orientation
    userdict /HPCustTrans get 
    1 eq 
    { 0 }
    { 1 } ifelse 
    (>>) cvx exec setpagedevice
  }
  {
    <</Orientation 1>> setpagedevice
  } ifelse

ps_portrait=userdict /HPCustTrans known
  {
    (<<) cvx exec
    /Orientation
    userdict /HPCustTrans get 
    (>>) cvx exec setpagedevice
  }
  {
     <</Orientation 0>> setpagedevice
  } ifelse

# set gamma correction to reduce color intensity for InkJets ..
gamma=0.333
ps_gamma={ \%6.3f{gamma} exp } dup dup currenttransfer set colortransfer

ps_printquality=[ \%s{printquality} ]

ps_draft=  << /HWResolution [300 300]
    /PostRenderingEnhance true
    /PostRenderingEnhanceDetails
    << /PrintQuality 1
    /Type 11 >>
    >> setpagedevice

ps_normal= << /HWResolution [300 300]
    /PostRenderingEnhance true
    /PostRenderingEnhanceDetails
    << /PrintQuality 2
      /Type 11 >>
  >> setpagedevice

ps_fast= [ high ]
ps_high= << /HWResolution [600 600]
    /PostRenderingEnhance true
    /PostRenderingEnhanceDetails
    << /PrintQuality 3
      /Type 11 >>
    >> setpagedevice

ps_user_opts += [
	a0 a3 a3fb a4 a4fb autoscale_36x60 autoscale_a0 autoscale_a3
	autoscale_a4 autoscale_letter color draft fast
	gamma grayscale high landscape normal portrait printquality
    font
 ]

#
# O.K., here we are the end of the story, at least today ...
#wig19990813
#


# PRINTER % - HP Color LaserJet Printer {/hp(.*)/$1/}
[ hp4500 hp8500 hp8550 ]

# Apparently this printer does not like ^D at start of job
ps_eoj_at_start@
pjl_inupper=@PJL SET MEDIASOURCE = TRAY0
pjl_inlower=@PJL SET MEDIASOURCE = TRAY1

## paper source selection
##   use -Zsource=n
## 0 - current, 1 - lower, tray2, 2 - manual paper, 3 - manual envelope
## 4 - upper tray1,   5 - optional paper, high capacity - tray3

pcl_intray1=\033&l4H
pcl_intray2=\033&l1H
pcl_intray3=\033&l5H

pcl_bond         = \033&n5WdBond
pcl_plain        = \033&n6WdPlain
pcl_color        = \033&n6WdColor
pcl_labels       = \033&n7WdLabels
pcl_recycled     = \033&n9WdRecycled
pcl_letterhead   = \033&n11WdLetterhead
pcl_cardstock    = \033&n10WdCardstock
pcl_prepunched   = \033&n11WdPrepunched
pcl_preprinted   = \033&n11WdPreprinted
pcl_transparency = \033&n13WdTransparency
pcl_rough        = \033&n6WdRough
pcl_vellum       = \033&n7WdVellum
pcl_gloss        = \033&n7WdGloss

pcl_user_opts += [
	intray1 intray2 intray3
    bond plain color labels
	recycled letterhead cardstock prepunched
	preprinted transparency rough vellum gloss
 ]
#duplex (optional)
ps_simplex= <</Duplex false /Tumble false>> setpagedevice
ps_duplex= <</Duplex true /Tumble false>> setpagedevice
ps_lduplex=[ duplex ]
ps_duplexshort= <</Duplex true /Tumble true>> setpagedevice
ps_sduplex=[ duplexshort ]

ps_tumble= <</Tumble false>> setpagedevice
ps_shortedge=[ tumble ]

#Tray
#  This is totally bizzare and does not make sense
#  but this is what the PPD file says.
ps_inupper=  <</MediaPosition 0>> setpagedevice
ps_intray1=  <</MediaPosition 0>> setpagedevice
ps_inlower= <</MediaPosition 3>> setpagedevice
ps_intray2= <</MediaPosition 3>> setpagedevice
ps_intray3= <</MediaPosition 1>> setpagedevice

ps_manual= <</ManualFeed true>> setpagedevice

#PageSize
ps_letter= <</PageSize [612 792] /ImagingBBox null>> setpagedevice
ps_legal= <</PageSize [612 1008] /ImagingBBox null>> setpagedevice
ps_executive= <</PageSize [522 756] /ImagingBBox null>> setpagedevice
ps_a3= <</PageSize [842 1191] /ImagingBBox null>> setpagedevice
ps_a4= <</PageSize [595 842] /ImagingBBox null>> setpagedevice
ps_a5= <</PageSize [420 595] /ImagingBBox null>> setpagedevice
ps_b5= <</PageSize [516 729] /ImagingBBox null>> setpagedevice
ps_envb5= <</PageSize [499 709] /ImagingBBox null>> setpagedevice
ps_env10= <</PageSize [297 684] /ImagingBBox null>> setpagedevice
ps_envc5= <</PageSize [459 649] /ImagingBBox null>> setpagedevice
ps_envmonarch= <</PageSize [312 624] /ImagingBBox null>> setpagedevice
#MediaType
ps_plain= <</MediaType (Plain)>> setpagedevice
ps_preprinted= <</MediaType (Preprinted)>> setpagedevice
ps_letterhead= <</MediaType (Letterhead)>> setpagedevice
ps_transparency= <</MediaType (Transparency)>> setpagedevice
ps_glossy= <</MediaType (Gloss)>> setpagedevice
ps_prepunched=  <</MediaType (Prepunched)>> setpagedevice
ps_labels= <</MediaType (Labels)>> setpagedevice
ps_bond= <</MediaType (Bond)>> setpagedevice
ps_recycled= <</MediaType (Recycled)>> setpagedevice
ps_color= <</MediaType (Color)>> setpagedevice
ps_heavy= <</MediaType (Heavy)>> setpagedevice
ps_cardstock= <</MediaType (Cardstock)>> setpagedevice
# Print Color as Gray
ps_colorasgray= <</ProcessColorModel /DeviceGray>> setpagedevice
ps_colorascolor= <</ProcessColorModel /DeviceCMY>> setpagedevice
# CMYK Ink Space
ps_cmykinksfast= << /CMYKInkSet 0 >> setpagedevice
ps_cmykinksswop= << /CMYKInkSet 1 >> setpagedevice
ps_cmykinkseuro= << /CMYKInkSet 2 >> setpagedevice
ps_cmykinkstoyo= << /CMYKInkSet 3 >> setpagedevice

ps_user_opts +=[
    a3 a4 a5 b5 bond cardstock cmykinkseuro cmykinksfast cmykinksswop
    cmykinkstoyo color colorascolor colorasgray duplex duplexshort
    env10 envb5 envc5 envmonarch executive glossy heavy inlower
    inupper labels legal letter letterhead manual plain preprinted
    prepunched recycled simplex transparency tray1 tray2 tray3
	lduplex sduplex tumble shortedge
]

# PRINTER hp5000 - HP5000  Model number: C4111A (LaserJet 5000N)
#
# Hewlett Packard 5000 Series
# Model number: C4111A (LaserJet 5000N)
# Printer short description: Letter/Legal/A4/A3, PostScript Level3
#
# Input taken from
# hp5000_6.ppd
#
# Author: Wilfried.Gaensheimer@infineon.com
# wig19991020
#
# Status: untested
#
# Open Issues:
#
# Implemented commands:
#
# PJL:
#
# paper: A3,A4,Letter,Legal,Ledger/Tabloid/11x17
# resolution: 300/300dpi | 600/600dpi | 1200/1200dpi
# ??bitsperpixel: ( 2 | 1 )
# ??economode: ( ON | OFF )
# 
# Postscript:
#
# ?? collate: ( true | false )
# ?? smoothing: ( true | false )
# pagesize/papersize/paper:
#        letter | executive | legal | ledger/tabloid/11x17 | a3 | a4 | a5
#   not implemented: ....
# source/tray: upper/tray1 | manual/manualfeed | middle/tray2 |
#             lower/tray3 |largecapacity/tray4/large |
# media type: plain | transparency | preprinted
#   not implemented: | letterhead | prepunched | labels | bond | recycled |
#              colorpaper (*) | cardstock | rough
# (*) color in PPD
# ?? scalepattern (not implemented)
# ?? halftone: enhanced | standard (not implemented)
# duplex | sduplex/duplexshort | simplex | shortedge/tumble

# PRINTER hp5000 - HP5000 Model C4111A (LaserJet 5000)
[ hp5000 ]

pjl_only=[
    COMMENT DEFAULT DINQUIRE ECHO ENTER EOJ
    FSAPPEND FSDIRLIST FSQUERY FSUPLOAD FSDELETE FSDOWNLOAD
    FSINIT FSMKDIR
    INFO INITIALIZE INQUIRE JOB OPMSG PJL RDYMSG
    RESET SET STMSG USTATUS USTATUSOFF
    COPIES
]

economode=ON
pjl_economode=@PJL SET ECONOMODE = \%s{economode}
pjl_economodeoff=@PJL SET ECONOMODE = OFF

pjl_user_opts += [
	bitsperpixel economode economodeoff
    ]

# we have the same PCL as the HP4000
tc=hp4000_pcl

# now we do the PostScript

collate=true
ps_collate=<</Collate \%s{collate}>> setpagedevice

# smoothing: ( true | false )
smoothing=true
ps_smoothing=
   << /PostRenderingEnhance true /PostRenderingEnhanceDetails << /REValue 2 /Type 8 >>
    >> setpagedevice
ps_nosmoothing=
   << /PostRenderingEnhance true /PostRenderingEnhanceDetails << /REValue 0 /Type 8 >>
    >> setpagedevice

#
# Paper size selection ...
#
ps_letter=<</PageSize [612 792] /ImagingBBox null>> setpagedevice
ps_executive= <</PageSize [522 756] /ImagingBBox null>> setpagedevice
ps_legal= <</PageSize [612 1008] /ImagingBBox null>> setpagedevice
ps_ledger= <</PageSize [792 1224] /ImagingBBox null>> setpagedevice
ps_a3= <</PageSize [842 1191] /ImagingBBox null>> setpagedevice
ps_a4= <</PageSize [595 842] /ImagingBBox null>> setpagedevice
ps_a5= <</PageSize [420 595] /ImagingBBox null>> setpagedevice

#
# source ...
#
ps_inupper=<</ManualFeed false /MediaPosition 3>> setpagedevice
ps_intray1=[ inupper ]
ps_manual=<</ManualFeed true /MediaPosition 3>> setpagedevice
ps_manualfeed=[ manual ]
ps_inmiddle=<</ManualFeed false /MediaPosition 0>> setpagedevice
ps_intray2=[ inmiddle ]
ps_inlower=<</ManualFeed false /MediaPosition 1>> setpagedevice
ps_intray3=[ inlower ]
ps_inlargecapacity=<</ManualFeed false /MediaPosition 4>> setpagedevice
ps_inlarge=[ inlargecapacity ]
ps_intray4=[ inlargecapacity ]

#
# Media type ...
#
ps_plain=<</MediaType (Plain)>> setpagedevice
ps_preprinted=<</MediaType (Preprinted)>> setpagedevice
ps_transparency=<</MediaType (Transparency)>> setpagedevice

#
# Duplex control ..
#
ps_duplex=<</Duplex true>> setpagedevice
ps_lduplex=[ duplex ]
ps_duplexshort=<</Duplex true /Tumble true>> setpagedevice
ps_sduplex=[ duplexshort ]
ps_simplex=<</Duplex false /Tumble false>> setpagedevice

ps_tumble=<</Tumble true>> setpagedevice
ps_shortedge=[ tumble ]

ps_user_opts += [
	collate executive inlarge inlargecapacity
	inmiddle intray intray1 intray2 intray3 intray4
	nosmoothing pagesize paper
	papersize plain preprinted smoothing
	source
    ]

#
# Take PCL from generic section ....
#

#!End of [ hp5000 ]

#
# Hewlett Packard 8000 Series, 8100 Series
#
# Printer short description: Letter/Legal/A4, PostScript Level3
#                            300/600
#
# Input taken from
# hp8000_5.ppd
#
# Author: Wilfried.Gaensheimer@infineon.com
# wig19990921
#
# Status: untested
#
# Open Issues:
#
# Implemented commands:
#
# PJL:
#
# resolution: 300/300dpi | 600/600dpi
# bitsperpixel: ( 2 | 1 )
# economode: ( ON | OFF )
# 
# Postscript:
#
# outputbin: upper/topbin | left/leftbin | 
#   not implemented: stacker | collator |separator | stapler | ....
# collate: ( true | false )
# smoothing: ( true | false )
# pagesize/papersize/paper:
#        letter | executive | legal | tabloid/11x17 | a3 | a4 | a5
#   not implemented: w842h1274 | b4 | b5 | doublepostcard |
#                    w612h935 | w558h774 | w774h1116 |
#                    env10 envmonarch envdl envc5 envisob5
# source/tray: upper/tray1 | manual/manualfeed | middle/tray2 |
#             lower/tray3 |largecapacity/tray4/large |
#             tray5 | envelope | plain | preprinted | 
#             transparency 
#   not implemented: | letterhead | prepunched | labels | bond | recycled |
#              colorpaper (*) | cardstock | rough
# (*) color in PPD
# scalepattern (not implemented)
# halftone: enhanced | standard
# duplex | sduplex/duplexshort | simplex | shortedge/tumble

# PRINTER % - HP Laserjet 8000 Series, {/hp(.*)/HP$1/}

[ hp8000 hp8100 hp8150 ]

pjl_only=[
    COMMENT DEFAULT DINQUIRE ECHO ENTER EOJ
    FSAPPEND FSDIRLIST FSQUERY FSUPLOAD FSDELETE FSDOWNLOAD
    FSINIT FSMKDIR
    INFO INITIALIZE INQUIRE JOB OPMSG PJL RDYMSG
    RESET SET STMSG USTATUS USTATUSOFF
    COPIES
]

pjl_economodeoff=@PJL SET ECONOMODE = OFF
#ExtractedKey: JCLEconomode True/Save Toner
pjl_economode=@PJL SET ECONOMODE = ON
#ExtractedKey: JCLFastRes True/On
pjl_fastres=@PJL SET BITSPERPIXEL = 2
#ExtractedKey: JCLFastRes False/Off
pjl_fastresoff=@PJL SET BITSPERPIXEL = 1

pjl_user_opts += [
    economode economodeoff fastres fastresoff
 ]

# the HP8000 has the same PCL as the hp4000
tc=hp4000_pcl

## but different large capacity definition !
## 20-39 high capacity input trays 2-21
##
## the large capacity tray 4 has a different pcl definition

pcl_intray4=\033&l20H
pcl_lf_stacker=\033&l3G
pcl_stacker1=\033&l4G
pcl_stacker2=\033&l5G
pcl_stacker3=\033&l6G
pcl_stacker4=\033&l7G
pcl_stacker5=\033&l8G
pcl_stacker6=\033&l9G
pcl_stacker7=\033&l10G
pcl_stacker8=\033&l11G

pcl_user_opts += [
	lf_stacker stacker1 stacker2 stacker3 stacker4
	stacker5 stacker6 stacker7 stacker8
 ]

# now for the PostScript

ps_outputbin=[ \%s{outputbin} ]

ps_outupper=<</Staple 0 /OutputType (TOP OUTPUT BIN)>> setpagedevice
ps_topbin=[ outupper ]

ps_leftbin=
   currentpagedevice /OutputAttributes get
   4 known
         {<</Staple 0 /OutputType (FACE UP BIN)>> setpagedevice}
         {<</Staple 0 /OutputType (LEFT OUTPUT BIN)>> setpagedevice}
       ifelse
ps_outleft=[ leftbin ]
ps_outlower=[ leftbin ]

collate=true
ps_collate=<</Collate \%s{collate}>> setpagedevice

# smoothing: ( true | false )
smoothing=true
ps_smoothing=
   << /PostRenderingEnhance true /PostRenderingEnhanceDetails << /REValue 2 /Type 8 >>
    >> setpagedevice
ps_nosmoothing=
   << /PostRenderingEnhance true /PostRenderingEnhanceDetails << /REValue 0 /Type 8 >>
    >> setpagedevice

#
# Paper size selection ...
#
ps_letter=<</DeferredMediaSelection true /PageSize [612 792] /ImagingBBox null>> setpagedevice
ps_executive=
    <</DeferredMediaSelection true /PageSize [522 756] /ImagingBBox null>> setpagedevice
ps_legal=
    <</DeferredMediaSelection true /PageSize [612 1008] /ImagingBBox null>> setpagedevice
ps_ledger=
  <</DeferredMediaSelection true /PageSize [792 1224] /ImagingBBox null>> setpagedevice
ps_a3=
    <</DeferredMediaSelection true /PageSize [842 1191] /ImagingBBox null>> setpagedevice
ps_a4=
    <</DeferredMediaSelection true /PageSize [595 842] /ImagingBBox null>> setpagedevice
ps_a5=
    <</DeferredMediaSelection true /PageSize [420 595] /ImagingBBox null>> setpagedevice

#
# source ...
#

ps_inupper=<</ManualFeed false /MediaPosition 3>> setpagedevice
ps_intray1=[ inupper ]
ps_manual=<</ManualFeed true /MediaPosition 3>> setpagedevice
ps_manualfeed=[ manual ]
ps_inmiddle=<</ManualFeed false /MediaPosition 0>> setpagedevice
ps_intray2=[ inmiddle ]
ps_inlower=<</ManualFeed false /MediaPosition 1>> setpagedevice
ps_intray3=[ inlower ]
ps_inlargecapacity=<</ManualFeed false /MediaPosition 5>> setpagedevice
ps_inlarge=[ inlargecapacity ]
ps_intray4=[ inlargecapacity ]
ps_intray5=<</ManualFeed false /MediaPosition 6>> setpagedevice

ps_bond= <</ManualFeed false /MediaType (Bond)>> setpagedevice
ps_cardstock= <</ManualFeed false /MediaType (Card Stock)>> setpagedevice
ps_color= <</ManualFeed false /MediaType (Color)>> setpagedevice
ps_envelope= <</ManualFeed false /MediaPosition 2>> setpagedevice
ps_labels= <</ManualFeed false /MediaType (Labels)>> setpagedevice
ps_letterhead= <</ManualFeed false /MediaType (Letterhead)>> setpagedevice
ps_plain=<</ManualFeed false /MediaType (Plain)>> setpagedevice
ps_preprinted= <</ManualFeed false /MediaType (Preprinted)>> setpagedevice
ps_prepunched=  <</ManualFeed false /MediaType (Prepunched)>> setpagedevice
ps_recycled= <</ManualFeed false /MediaType (Recycled)>> setpagedevice
ps_rough=  <</ManualFeed false /MediaType (Rough)>> setpagedevice
ps_transparency=<</ManualFeed false /MediaType (Transparency)>> setpagedevice

ps_halftone=[ \%s{halftone} ]
ps_enhanced=
  << /Install {
     currentpagedevice /HWResolution get
     dup 0 get 600 eq exch 1 get 600 eq and
     { /EnhancedColorRendering600 } { /EnhancedColorRendering } ifelse
     /ColorRendering findresource setcolorrendering
     /EnhancedHalftone /Halftone findresource sethalftone
     { } settransfer false setstrokeadjust
   }
   >> setpagedevice
   currentpagedevice /HWResolution get dup 0 get 600 eq exch 1 get 600 eq and
   {
       << /PostRenderingEnhance true
            /PostRenderingEnhanceDetails << /REValue 0 /Type 8 >>
       >> setpagedevice
   } if
   /setscreen { pop pop pop } def
   /setcolorscreen { pop pop pop pop pop pop pop pop pop pop pop pop } def
   /sethalftone { pop } def 
ps_standard=
     << /Install {
     currentpagedevice /HWResolution get
     dup 0 get 600 eq exch 1 get 600 eq and dup
     currentpagedevice /PostRenderingEnhance get
     currentpagedevice /PostRenderingEnhanceDetails get /REValue get 0 ne and
     { {/DefaultColorRenderingRE600} {/DefaultColorRenderingRE} ifelse}
     { {/DefaultColorRendering600} {/DefaultColorRendering} ifelse} ifelse
     /ColorRendering findresource setcolorrendering
     { /DefaultHalftone600 } {/DefaultHalftone} ifelse
     /Halftone findresource sethalftone
     {} settransfer false setstrokeadjust
   } >> setpagedevice
   currentpagedevice /HWResolution get dup 0 get 600 eq exch 1 get 600 eq and
   {
     << /PostRenderingEnhance true /PostRenderingEnhanceDetails
     << /REValue 0 /Type 8 >> >> setpagedevice
   } if    

#
# Duplex control ..
#
ps_duplex=<</Duplex true>> setpagedevice
ps_lduplex=[ duplex ]
ps_sduplex=<</Duplex true /Tumble true>> setpagedevice
ps_duplexshort=[ sduplex ]
ps_simplex=<</Duplex false /Tumble false>> setpagedevice

ps_tumble=<</Tumble true>> setpagedevice
ps_shortedge=[ tumble ]

ps_user_opts += [
	collate enhanced halftone inlarge inlargecapacity inmiddle intray
	intray1 intray2 intray3 intray4 intray5 leftbin nosmoothing outleft
	outputbin pagesize paper papersize plain preprinted smoothing source
	standard topbin
	bond cardstock color envelope labels letterhead plain
	preprinted prepunched recycled rough transparency
    ]

#!End of [ hp8000 ]


# same feature set as the HP4000
# but no outbins, no media selection

# PRINTER hp2100 - HP LaserJet 2100 Series
[ hp2100 ]

## pcl paper source selection
##   use -Zsource=n
## 0 - current, 1 - tray 2 (first cassette), 2 - manual
## 3 - ????
## 4 - tray 1 (Multipurpose), 5 - tray 3 (second cassete)

pcl_intray1=\033&l4H
pcl_intray2=\033&l1H
pcl_intray3=\033&l5H

pcl_user_opts += [
    intray1 intray2 intray3
 ]

# minimalist low end laserjet printer
#  like HP4MP, but has some tray selection

# PRINTER hp2200 - HP LaserJet 2200 Series
[ hp2200 ]

## paper source selection
##   use -Zsource=n
## 1 - upper, 2 - manual paper, 3 - manual envelope
## 4 - manual,   5 - lower
## 6 - lower
 
pcl_inupper=\033&l1H
pcl_inlower=\033&l5H
pcl_manual=\033&l2H

# PRINTER hp4050 - HP4050 Series
#
# Hewlett Packard 4050 Series
#
# Model number: C4253A (LaserJet 4050N)
#
# Printer short description: Letter/Legal/A4, PostScript Level3
#                            300/600/1200
#
# Input taken from
# HP4050_6.ppd
#
# Author: Wilfried.Gaensheimer@infineon.com
# wig20000124
#
# Status: untested
#
# Open Issues:
#
# Implemented commands:
#
# PJL:
#
# paper: A4,Letter,Legal
# resolution: 300/300dpi | 600/600dpi | 1200/1200dpi
# fastres
# bitsperpixel: ( 2 | 1 )
# economode: ( ON | OFF )
# retention: ( on | off ) | quickcopy private proof store
# 
# Postscript:
#
# collate: ( true | false )
# smoothing: ( true | false ) smoothingon smoothingoff
# pagesize/papersize/paper:
#        letter | executive | legal | a4 | a5 |
#        b5 | w612h935 | w558h774 |
#        env10 | envmonarch | envdl | envc5 | envb5
# oneup oneupl twoup twoupl fourup fourupl sixup sixupl
#         nineup nineupl sixteenup sixteenupl
# Watermarks:
#   wmtext wmfont wmsize wmangle
#   wmtextstylenarrow wmtextstylemedium wmtextstylewide wmtextstylehalo
#   wmallpages wmfirstpage
# tray|source: upper/tray1 | manualfeed/manual | middle/tray2
#    lower/tray3 | large/largecapacity/tray4
#    tray5 | tray6 | tray7 | tray8 | tray9 | tray10 | envelope
# media type: plain | transparency | preprinted
# media type:
#  plain | preprinted | letterhead | transparancy | prepunched |
#  labels | bond | recycled | mediacolor(*) | cardstock | rough
# (*) color in PPD
# promptuser
#   nearestsizeadjust
#   nearestsizenoadjust
#   policyletter
#   policya4
# scalepatterns
# halftone: halftoneenhanced | halfetonestandard
# duplex | sduplex/duplexshort/duplexshortedge | simplex | shortedge/tumble

# PRINTER % - HP4050 Series Printers
[ hp4050 ]

pjl_only=[
    COMMENT DEFAULT DINQUIRE ECHO ENTER EOJ
    FSAPPEND FSDIRLIST FSQUERY FSUPLOAD FSDELETE FSDOWNLOAD
    FSINIT FSMKDIR
    INFO INITIALIZE INQUIRE JOB OPMSG PJL RDYMSG
    RESET SET STMSG USTATUS USTATUSOFF
    COPIES
 ]

# use the HP4000 PCL - it is identical
tc=hp4000_pcl

# You can set retention to ON or OFF ... quickcopy, private and store are
# predefined ...
retention=OFF
pjl_retention=@PJL SET HOLD = \%s{retention}
#ExtractedKey: JCLRetention JCLRetentionQuickCopy/Quick Copy
pjl_quickcopy=@PJL SET HOLD = ON

#ExtractedKey: JCLRetention JCLRetentionProof/Proof and Hold
pjl_proof=@PJL SET HOLD = PROOF

#ExtractedKey: JCLRetention JCLRetentionPrivate/Private Job
pjl_private=
    @PJL SET HOLD = ON
    @PJL SET HOLDTYPE = PRIVATE

#ExtractedKey: JCLRetention JCLRetentionStore/Stored Job
pjl_store=@PJL SET HOLD = STORE

#ExtractedKey: JCLFastRes True/On
pjl_fastres=@PJL SET BITSPERPIXEL = 2
#ExtractedKey: JCLFastRes False/Off
pjl_fastresoff=@PJL SET BITSPERPIXEL = 1

# Set economode
economode=ON
pjl_economode=@PJL SET ECONOMODE = \%s{economode}
#ExtractedKey: JCLEconomode False/Highest Quality
pjl_economodeoff=@PJL SET ECONOMODE = OFF
#ExtractedKey: JCLEconomode True/Save Toner
#pjl_economode=
#    @PJL SET ECONOMODE = ON

pjl_user_opts += [
    retention quickcopy proof private store 
    fastres bitsperpixel economode economodeoff fastresoff
 ]
pjl_vars_set += [ bitsperpixel ]


### PostScript


#ExtractedKey: HPNup OneUp/1 (Portrait)
ps_oneup=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
      end
    
      <<
      /EndPage {userdict begin
      userdict /HPwmText known HPwm /HPwmOn get and
        {initmatrix
         0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
         currentpagedevice /PageSize get aload pop 2 div exch 2 div exch translate
         HPwmAngle rotate /HPwmFont userdict /HPppScale known {HPwmSize HPppScale mul}{HPwmSize}ifelse selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch
           userdict /HPppScale known {HPwmSize HPppScale mul}{HPwmSize}ifelse .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
        2 eq {pop false}{pop HPwm begin HPwmEOP end} ifelse
        end } bind
      >> setpagedevice

#ExtractedKey: HPNup OneUpL/1 (Landscape)
ps_oneupl=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
      end
    
      <<
      /EndPage {userdict begin
      userdict /HPwmText known HPwm /HPwmOn get and
        {initmatrix
         0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
         currentpagedevice /PageSize get aload pop 2 div exch 2 div exch translate
         HPwmAngle 90 add rotate /HPwmFont userdict /HPppScale known {HPwmSize HPppScale mul}{HPwmSize}ifelse selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch
           userdict /HPppScale known {HPwmSize HPppScale mul}{HPwmSize}ifelse .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
        2 eq {pop false}{pop HPwm begin HPwmEOP end} ifelse
        end } bind
      >> setpagedevice

#ExtractedKey: HPNup TwoUp/2 (Portrait)
ps_twoup=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      userdict /HPwmPgWidth known not
        {/HPwmPgWidth currentpagedevice /PageSize get aload pop /HPwmPgHeight exch def def} if
      /HPwmShWidth currentpagedevice /PageSize get aload pop /HPwmShHeight exch def def
    
      /HPwmCTM {
        /HPwmScale HPwmShWidth 32 sub HPwmPgHeight div dup HPwmShHeight 32 sub 2 div 
          HPwmPgWidth div dup 3 1 roll lt {pop} {exch pop} ifelse def
        /HPwmX1 HPwmShWidth HPwmPgHeight HPwmScale mul sub 2 div HPwmPgHeight HPwmScale mul add def
        /HPwmY1 HPwmShHeight HPwmPgWidth HPwmScale mul 2 mul sub 2 div def
        /HPwmY2 HPwmPgWidth HPwmScale mul HPwmY1 add def
      } bind def HPwmCTM
    
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      /restore {/PageSV where {pop dup PageSV eq 
        {restore HPwm begin HPwmMatrix setmatrix end}{restore}ifelse}{restore}ifelse} bind def
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
    
      /HPWaterMark {
      0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
      0 0 HPwmPgWidth HPwmPgHeight rectstroke
      userdict /HPwmText known HPwmOn and
        {HPwmPgWidth 2 div HPwmPgHeight 2 div translate
         HPwmAngle rotate /HPwmFont HPwmSize selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch HPwmSize .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmScale div HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
      } bind def
      end
    
      <<
      /BeginPage {userdict begin
        2 mod 0 eq { HPwmX1 HPwmY1 translate }{ HPwmX1 HPwmY2 translate } ifelse
        90 rotate HPwmScale HPwmScale scale
        HPwm begin true setglobal
          /HPwmMatrix matrix currentmatrix def
        false setglobal end
        end } bind
     
      /EndPage {userdict begin
        HPwm begin HPwmMatrix setmatrix
        2 eq {2 mod 0 ne {HPwmEOP}{false}ifelse}{HPWaterMark 2 mod 1 eq {HPwmEOP}{false}ifelse} ifelse end
        end } bind
      >> setpagedevice
    
    /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
      HPwmCTM <</PageSize [HPwmShWidth HPwmShHeight] /ImagingBBox null>>
      userdict /HPwmSPD known {HPwmSPD}{setpagedevice} ifelse}if end} bind def

#ExtractedKey: HPNup TwoUpL/2 (Landscape)
ps_twoupl=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      userdict /HPwmPgWidth known not
        {/HPwmPgWidth currentpagedevice /PageSize get aload pop /HPwmPgHeight exch def def} if
      /HPwmShWidth currentpagedevice /PageSize get aload pop /HPwmShHeight exch def def
    
      /HPwmCTM {
        /HPwmScale HPwmShWidth 32 sub HPwmPgHeight div dup HPwmShHeight 32 sub 2 div 
          HPwmPgWidth div dup 3 1 roll lt {pop} {exch pop} ifelse def
        /HPwmX1 HPwmShWidth HPwmPgHeight HPwmScale mul sub 2 div def
        /HPwmY1 HPwmShHeight HPwmPgWidth HPwmScale mul 2 mul sub 2 div HPwmShHeight exch sub def
        /HPwmY2 HPwmY1 HPwmPgWidth HPwmScale mul sub def
      } bind def HPwmCTM
    
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      /restore {/PageSV where {pop dup PageSV eq 
        {restore HPwm begin HPwmMatrix setmatrix end}{restore}ifelse}{restore}ifelse} bind def
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
    
      /HPWaterMark {
      0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
      0 0 HPwmPgWidth HPwmPgHeight rectstroke
      userdict /HPwmText known HPwmOn and
        {HPwmPgWidth 2 div HPwmPgHeight 2 div translate
         HPwmAngle 90 add rotate /HPwmFont HPwmSize selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch HPwmSize .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmScale div HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
      } bind def
      end
    
      <<
      /BeginPage {userdict begin
        2 mod 0 eq { HPwmX1 HPwmY1 translate }{ HPwmX1 HPwmY2 translate } ifelse
        -90 rotate HPwmScale HPwmScale scale
        HPwm begin true setglobal
          /HPwmMatrix matrix currentmatrix def
        false setglobal end
        end } bind
     
      /EndPage {userdict begin
        HPwm begin HPwmMatrix setmatrix
        2 eq {2 mod 0 ne {HPwmEOP}{false}ifelse}{HPWaterMark 2 mod 1 eq {HPwmEOP}{false}ifelse} ifelse end
        end } bind
      >> setpagedevice
    
    /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
      HPwmCTM <</PageSize [HPwmShWidth HPwmShHeight] /ImagingBBox null>>
      userdict /HPwmSPD known {HPwmSPD}{setpagedevice} ifelse}if end} bind def

#ExtractedKey: HPNup FourUp/4 (Portrait)
ps_fourup=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      userdict /HPwmPgWidth known not
        {/HPwmPgWidth currentpagedevice /PageSize get aload pop /HPwmPgHeight exch def def} if
      /HPwmShWidth currentpagedevice /PageSize get aload pop /HPwmShHeight exch def def
    
      /HPwmCTM {
        /HPwmScale HPwmShWidth 32 sub 2 div HPwmPgWidth div dup HPwmShHeight 32 sub 2 div 
          HPwmPgHeight div dup 3 1 roll lt {pop} {exch pop} ifelse def
        /HPwmX1 HPwmShWidth HPwmPgWidth HPwmScale mul 2 mul sub 2 div def
        /HPwmX2 HPwmPgWidth HPwmScale mul HPwmX1 add def
        /HPwmY1 HPwmShHeight HPwmPgHeight HPwmScale mul 2 mul sub 2 div def
        /HPwmY2 HPwmPgHeight HPwmScale mul HPwmY1 add def
      } bind def HPwmCTM
    
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      /restore {/PageSV where {pop dup PageSV eq 
        {restore HPwm begin HPwmMatrix setmatrix end}{restore}ifelse}{restore}ifelse} bind def
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
    
      /HPWaterMark {
      0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
      0 0 HPwmPgWidth HPwmPgHeight rectstroke
      userdict /HPwmText known HPwmOn and
        {HPwmPgWidth 2 div HPwmPgHeight 2 div translate
         HPwmAngle rotate /HPwmFont HPwmSize selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch HPwmSize .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmScale div HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
      } bind def
      end
    
    <<
      /BeginPage {userdict begin
        4 mod dup dup dup
        0 eq {HPwmX1 HPwmY2 translate} if
        1 eq {HPwmX2 HPwmY2 translate} if
        2 eq {HPwmX1 HPwmY1 translate} if
        3 eq {HPwmX2 HPwmY1 translate} if
        HPwmScale HPwmScale scale
        HPwm begin true setglobal
          /HPwmMatrix matrix currentmatrix def
        false setglobal end
        end } bind
     
      /EndPage {userdict begin
        HPwm begin HPwmMatrix setmatrix
        2 eq {4 mod 0 ne {HPwmEOP}{false}ifelse}{HPWaterMark 4 mod 3 eq {HPwmEOP}{false}ifelse} ifelse end
        end } bind
    >> setpagedevice
    
    /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
      HPwmCTM <</PageSize [HPwmShWidth HPwmShHeight] /ImagingBBox null>>
      userdict /HPwmSPD known {HPwmSPD}{setpagedevice} ifelse}if end} bind def

#ExtractedKey: HPNup FourUpL/4 (Landscape)
ps_fourupl=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      userdict /HPwmPgWidth known not
        {/HPwmPgWidth currentpagedevice /PageSize get aload pop /HPwmPgHeight exch def def} if
      /HPwmShWidth currentpagedevice /PageSize get aload pop /HPwmShHeight exch def def
    
      /HPwmCTM {
        /HPwmScale HPwmShWidth 32 sub 2 div HPwmPgWidth div dup HPwmShHeight 32 sub 2 div 
          HPwmPgHeight div dup 3 1 roll lt {pop} {exch pop} ifelse def
        /HPwmX1 HPwmShWidth HPwmPgWidth HPwmScale mul 2 mul sub 2 div def
        /HPwmX2 HPwmPgWidth HPwmScale mul HPwmX1 add def
        /HPwmY1 HPwmShHeight HPwmPgHeight HPwmScale mul 2 mul sub 2 div def
        /HPwmY2 HPwmPgHeight HPwmScale mul HPwmY1 add def
      } bind def HPwmCTM
    
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      /restore {/PageSV where {pop dup PageSV eq 
        {restore HPwm begin HPwmMatrix setmatrix end}{restore}ifelse}{restore}ifelse} bind def
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
    
      /HPWaterMark {
      0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
      0 0 HPwmPgWidth HPwmPgHeight rectstroke
      userdict /HPwmText known HPwmOn and
        {HPwmPgWidth 2 div HPwmPgHeight 2 div translate
         HPwmAngle 90 add rotate /HPwmFont HPwmSize selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch HPwmSize .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmScale div HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
      } bind def
      end
    
      <<
      /BeginPage {userdict begin
        4 mod dup dup dup
        0 eq {HPwmX1 HPwmY1 translate} if
        1 eq {HPwmX1 HPwmY2 translate} if
        2 eq {HPwmX2 HPwmY1 translate} if
        3 eq {HPwmX2 HPwmY2 translate} if
        HPwmScale HPwmScale scale
        HPwm begin true setglobal
          /HPwmMatrix matrix currentmatrix def
        false setglobal end
        end } bind
     
      /EndPage {userdict begin
        HPwm begin HPwmMatrix setmatrix
        2 eq {4 mod 0 ne {HPwmEOP}{false}ifelse}{HPWaterMark 4 mod 3 eq {HPwmEOP}{false}ifelse} ifelse end
        end } bind
      >> setpagedevice
    
    /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
      HPwmCTM <</PageSize [HPwmShWidth HPwmShHeight] /ImagingBBox null>>
      userdict /HPwmSPD known {HPwmSPD}{setpagedevice} ifelse}if end} bind def

#ExtractedKey: HPNup SixUp/6 (Portrait)
ps_sixup=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      userdict /HPwmPgWidth known not
        {/HPwmPgWidth currentpagedevice /PageSize get aload pop /HPwmPgHeight exch def def} if
      /HPwmShWidth currentpagedevice /PageSize get aload pop /HPwmShHeight exch def def
    
      /HPwmCTM {
        /HPwmScale HPwmShWidth 32 sub 2 div HPwmPgHeight div dup HPwmShHeight 32 sub 3 div 
          HPwmPgWidth div dup 3 1 roll lt {pop} {exch pop} ifelse def
        /HPwmX1 HPwmShWidth HPwmPgHeight HPwmScale mul 2 mul sub 2 div HPwmPgHeight HPwmScale mul add def
        /HPwmY1 HPwmShHeight HPwmPgWidth HPwmScale mul 3 mul sub 2 div def
      } bind def HPwmCTM
    
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      /restore {/PageSV where {pop dup PageSV eq 
        {restore HPwm begin HPwmMatrix setmatrix end}{restore}ifelse}{restore}ifelse} bind def
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
    
      /HPWaterMark {
      0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
      0 0 HPwmPgWidth HPwmPgHeight rectstroke
      userdict /HPwmText known HPwmOn and
        {HPwmPgWidth 2 div HPwmPgHeight 2 div translate
         HPwmAngle rotate /HPwmFont HPwmSize selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch HPwmSize .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmScale div HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
      } bind def
      end
    
      <<
      /BeginPage {userdict begin
        6 mod dup
        3 idiv HPwmPgHeight HPwmScale mul mul HPwmX1 add
        exch dup 3 idiv 3 mul sub HPwmPgWidth HPwmScale mul mul HPwmY1 add
        translate
        90 rotate HPwmScale HPwmScale scale
        HPwm begin true setglobal
          /HPwmMatrix matrix currentmatrix def
        false setglobal end
        end } bind
     
      /EndPage {userdict begin
        HPwm begin HPwmMatrix setmatrix
        2 eq {6 mod 0 ne {HPwmEOP}{false}ifelse}{HPWaterMark 6 mod 5 eq {HPwmEOP}{false}ifelse} ifelse end
        end } bind
      >> setpagedevice
    
    /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
      HPwmCTM <</PageSize [HPwmShWidth HPwmShHeight] /ImagingBBox null>>
      userdict /HPwmSPD known {HPwmSPD}{setpagedevice} ifelse}if end} bind def

#ExtractedKey: HPNup SixUpL/6 (Landscape)
ps_sixupl=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      userdict /HPwmPgWidth known not
        {/HPwmPgWidth currentpagedevice /PageSize get aload pop /HPwmPgHeight exch def def} if
      /HPwmShWidth currentpagedevice /PageSize get aload pop /HPwmShHeight exch def def
    
      /HPwmCTM {
        /HPwmScale HPwmShWidth 32 sub 2 div HPwmPgHeight div dup HPwmShHeight 32 sub 3 div 
          HPwmPgWidth div dup 3 1 roll lt {pop} {exch pop} ifelse def
        /HPwmX1 HPwmShWidth HPwmPgHeight HPwmScale mul 2 mul sub 2 div def
        /HPwmY1 HPwmShHeight HPwmPgWidth HPwmScale mul 3 mul sub 2 div HPwmPgWidth HPwmScale mul add def
      } bind def HPwmCTM
    
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      /restore {/PageSV where {pop dup PageSV eq 
        {restore HPwm begin HPwmMatrix setmatrix end}{restore}ifelse}{restore}ifelse} bind def
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
    
      /HPWaterMark {
      0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
      0 0 HPwmPgWidth HPwmPgHeight rectstroke
      userdict /HPwmText known HPwmOn and
        {HPwmPgWidth 2 div HPwmPgHeight 2 div translate
         HPwmAngle 90 add rotate /HPwmFont HPwmSize selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch HPwmSize .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmScale div HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
      } bind def
      end
    
      <<
      /BeginPage {userdict begin
        6 mod dup
        dup 2 idiv 2 mul sub HPwmPgHeight HPwmScale mul mul HPwmX1 add
        exch 2 idiv 2 exch sub HPwmPgWidth HPwmScale mul mul HPwmY1 add
        translate
        -90 rotate HPwmScale HPwmScale scale
        HPwm begin true setglobal
          /HPwmMatrix matrix currentmatrix def
        false setglobal end
        end } bind
     
      /EndPage {userdict begin
        HPwm begin HPwmMatrix setmatrix
        2 eq {6 mod 0 ne {HPwmEOP}{false}ifelse}{HPWaterMark 6 mod 5 eq {HPwmEOP}{false}ifelse} ifelse end
        end } bind
      >> setpagedevice
    
    /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
      HPwmCTM <</PageSize [HPwmShWidth HPwmShHeight] /ImagingBBox null>>
      userdict /HPwmSPD known {HPwmSPD}{setpagedevice} ifelse}if end} bind def

#ExtractedKey: HPNup NineUp/9 (Portrait)
ps_nineuo=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      userdict /HPwmPgWidth known not
        {/HPwmPgWidth currentpagedevice /PageSize get aload pop /HPwmPgHeight exch def def} if
      /HPwmShWidth currentpagedevice /PageSize get aload pop /HPwmShHeight exch def def
    
      /HPwmCTM {
        /HPwmScale HPwmShWidth 32 sub 3 div HPwmPgWidth div dup HPwmShHeight 32 sub 3 div 
          HPwmPgHeight div dup 3 1 roll lt {pop} {exch pop} ifelse def
        /HPwmX1 HPwmShWidth HPwmPgWidth HPwmScale mul 3 mul sub 2 div def
        /HPwmY1 HPwmShHeight HPwmPgHeight HPwmScale mul 3 mul sub 2 div def
      } bind def HPwmCTM
    
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      /restore {/PageSV where {pop dup PageSV eq 
        {restore HPwm begin HPwmMatrix setmatrix end}{restore}ifelse}{restore}ifelse} bind def
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
    
      /HPWaterMark {
      0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
      0 0 HPwmPgWidth HPwmPgHeight rectstroke
      userdict /HPwmText known HPwmOn and
        {HPwmPgWidth 2 div HPwmPgHeight 2 div translate
         HPwmAngle rotate /HPwmFont HPwmSize selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch HPwmSize .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmScale div HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
      } bind def
      end
    
      <<
      /BeginPage {userdict begin
        9 mod dup
        dup 3 idiv 3 mul sub HPwmPgWidth HPwmScale mul mul HPwmX1 add
        exch 3 idiv 2 exch sub HPwmPgHeight HPwmScale mul mul HPwmY1 add
        translate
        HPwmScale HPwmScale scale
        HPwm begin true setglobal
          /HPwmMatrix matrix currentmatrix def
        false setglobal end
        end } bind
     
      /EndPage {userdict begin
        HPwm begin HPwmMatrix setmatrix
        2 eq {9 mod 0 ne {HPwmEOP}{false}ifelse}{HPWaterMark 9 mod 8 eq {HPwmEOP}{false}ifelse} ifelse end
        end } bind
      >> setpagedevice
    
    /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
      HPwmCTM <</PageSize [HPwmShWidth HPwmShHeight] /ImagingBBox null>>
      userdict /HPwmSPD known {HPwmSPD}{setpagedevice} ifelse}if end} bind def

#ExtractedKey: HPNup NineUpL/9 (Landscape)
ps_nineupl=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      userdict /HPwmPgWidth known not
        {/HPwmPgWidth currentpagedevice /PageSize get aload pop /HPwmPgHeight exch def def} if
      /HPwmShWidth currentpagedevice /PageSize get aload pop /HPwmShHeight exch def def
    
      /HPwmCTM {
        /HPwmScale HPwmShWidth 32 sub 3 div HPwmPgWidth div dup HPwmShHeight 32 sub 3 div 
          HPwmPgHeight div dup 3 1 roll lt {pop} {exch pop} ifelse def
        /HPwmX1 HPwmShWidth HPwmPgWidth HPwmScale mul 3 mul sub 2 div def
        /HPwmY1 HPwmShHeight HPwmPgHeight HPwmScale mul 3 mul sub 2 div def
      } bind def HPwmCTM
    
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      /restore {/PageSV where {pop dup PageSV eq 
        {restore HPwm begin HPwmMatrix setmatrix end}{restore}ifelse}{restore}ifelse} bind def
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
    
      /HPWaterMark {
      0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
      0 0 HPwmPgWidth HPwmPgHeight rectstroke
      userdict /HPwmText known HPwmOn and
        {HPwmPgWidth 2 div HPwmPgHeight 2 div translate
         HPwmAngle 90 add rotate /HPwmFont HPwmSize selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch HPwmSize .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmScale div HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
      } bind def
      end
    
      <<
      /BeginPage {userdict begin
        9 mod dup
        3 idiv HPwmPgWidth HPwmScale mul mul HPwmX1 add
        exch dup 3 idiv 3 mul sub HPwmPgHeight HPwmScale mul mul HPwmY1 add
        translate
        HPwmScale HPwmScale scale
        HPwm begin true setglobal
          /HPwmMatrix matrix currentmatrix def
        false setglobal end
        end } bind
     
      /EndPage {userdict begin
        HPwm begin HPwmMatrix setmatrix
        2 eq {9 mod 0 ne {HPwmEOP}{false}ifelse}{HPWaterMark 9 mod 8 eq {HPwmEOP}{false}ifelse} ifelse end
        end } bind
      >> setpagedevice
    
    /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
      HPwmCTM <</PageSize [HPwmShWidth HPwmShHeight] /ImagingBBox null>>
      userdict /HPwmSPD known {HPwmSPD}{setpagedevice} ifelse}if end} bind def

#ExtractedKey: HPNup SixteenUp/16 (Portrait)
ps_sixteenup=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      userdict /HPwmPgWidth known not
        {/HPwmPgWidth currentpagedevice /PageSize get aload pop /HPwmPgHeight exch def def} if
      /HPwmShWidth currentpagedevice /PageSize get aload pop /HPwmShHeight exch def def
    
      /HPwmCTM {
        /HPwmScale HPwmShWidth 32 sub 4 div HPwmPgWidth div dup HPwmShHeight 32 sub 4 div 
          HPwmPgHeight div dup 3 1 roll lt {pop} {exch pop} ifelse def
        /HPwmX1 HPwmShWidth HPwmPgWidth HPwmScale mul 4 mul sub 2 div def
        /HPwmY1 HPwmShHeight HPwmPgHeight HPwmScale mul 4 mul sub 2 div def
      } bind def HPwmCTM
    
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      /restore {/PageSV where {pop dup PageSV eq 
        {restore HPwm begin HPwmMatrix setmatrix end}{restore}ifelse}{restore}ifelse} bind def
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
    
      /HPWaterMark {
      0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
      0 0 HPwmPgWidth HPwmPgHeight rectstroke
      userdict /HPwmText known HPwmOn and
        {HPwmPgWidth 2 div HPwmPgHeight 2 div translate
         HPwmAngle rotate /HPwmFont HPwmSize selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch HPwmSize .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmScale div HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
      } bind def
      end
    
      <<
      /BeginPage {userdict begin
        16 mod dup
        dup 4 idiv 4 mul sub HPwmPgWidth HPwmScale mul mul HPwmX1 add
        exch 4 idiv 3 exch sub HPwmPgHeight HPwmScale mul mul HPwmY1 add
        translate
        HPwmScale HPwmScale scale
        HPwm begin true setglobal
          /HPwmMatrix matrix currentmatrix def
        false setglobal end
        end } bind
     
      /EndPage {userdict begin
        HPwm begin HPwmMatrix setmatrix
        2 eq {16 mod 0 ne {HPwmEOP}{false}ifelse}{HPWaterMark 16 mod 15 eq {HPwmEOP}{false}ifelse} ifelse end
        end } bind
      >> setpagedevice
    
    /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
      HPwmCTM <</PageSize [HPwmShWidth HPwmShHeight] /ImagingBBox null>>
      userdict /HPwmSPD known {HPwmSPD}{setpagedevice} ifelse}if end} bind def

#ExtractedKey: HPNup SixteenUpL/16 (Landscape)
ps_sixteenupl=
    % Copyright (c) Hewlett-Packard Co 1997
      userdict begin
      userdict /HPwmPgWidth known not
        {/HPwmPgWidth currentpagedevice /PageSize get aload pop /HPwmPgHeight exch def def} if
      /HPwmShWidth currentpagedevice /PageSize get aload pop /HPwmShHeight exch def def
    
      /HPwmCTM {
        /HPwmScale HPwmShWidth 32 sub 4 div HPwmPgWidth div dup HPwmShHeight 32 sub 4 div 
          HPwmPgHeight div dup 3 1 roll lt {pop} {exch pop} ifelse def
        /HPwmX1 HPwmShWidth HPwmPgWidth HPwmScale mul 4 mul sub 2 div def
        /HPwmY1 HPwmShHeight HPwmPgHeight HPwmScale mul 4 mul sub 2 div def
      } bind def HPwmCTM
    
      true setglobal /HPwm 5 dict dup begin /HPwmOn true def /HPwmOdd true def end def false setglobal
    
      /restore {/PageSV where {pop dup PageSV eq 
        {restore HPwm begin HPwmMatrix setmatrix end}{restore}ifelse}{restore}ifelse} bind def
    
      userdict /HPwmAngle known not {/HPwmAngle 45 def} if
      userdict /HPwmSize known not {/HPwmSize 48 def} if
      userdict /HPwmLocation known not {/HPwmLocation true def} if
      userdict /HPwmStyle known not {/HPwmStyle .48 def} if
      userdict /HPwmDuplex known not {/HPwmDuplex 0 def} if
    
      /HPwmEOP {HPwmDuplex 0 eq {true}{HPwmDuplex 1 eq HPwmOdd eq dup not {erasepage}if
        true setglobal /HPwmOdd HPwmOdd not def false setglobal}ifelse} bind def
    
      /HPWaterMark {
      0 setgray 1 setlinewidth true setstrokeadjust 0 setlinejoin 0 setlinecap [] 0 setdash
      0 0 HPwmPgWidth HPwmPgHeight rectstroke
      userdict /HPwmText known HPwmOn and
        {HPwmPgWidth 2 div HPwmPgHeight 2 div translate
         HPwmAngle 90 add rotate /HPwmFont HPwmSize selectfont
         HPwmText stringwidth 2 div neg exch 2 div neg exch HPwmSize .25 mul sub moveto
         HPwmText false charpath userdict /HPwmStyle1 known
           {gsave 1 setgray HPwmStyle1 HPwmScale div HPwmStyle add setlinewidth stroke grestore} if
         0 setgray HPwmStyle setlinewidth stroke
         HPwmLocation not {true setglobal HPwm /HPwmOn false put false setglobal} if
        } if
      } bind def
      end
    
      <<
      /BeginPage {userdict begin
        16 mod dup
        4 idiv HPwmPgWidth HPwmScale mul mul HPwmX1 add
        exch dup 4 idiv 4 mul sub HPwmPgHeight HPwmScale mul mul HPwmY1 add
        translate
        HPwmScale HPwmScale scale
        HPwm begin true setglobal
          /HPwmMatrix matrix currentmatrix def
        false setglobal end
        end } bind
     
      /EndPage {userdict begin
        HPwm begin HPwmMatrix setmatrix
        2 eq {16 mod 0 ne {HPwmEOP}{false}ifelse}{HPWaterMark 16 mod 15 eq {HPwmEOP}{false}ifelse} ifelse end
        end } bind
      >> setpagedevice
    
    /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
      HPwmCTM <</PageSize [HPwmShWidth HPwmShHeight] /ImagingBBox null>>
      userdict /HPwmSPD known {HPwmSPD}{setpagedevice} ifelse}if end} bind def

#ExtractedKey: HPwmText CompanyConfidential/Company Confidential
#ExtractedKey: HPwmText CompanyProprietary/Company Proprietary
#ExtractedKey: HPwmText CompanyPrivate/Company Private
#ExtractedKey: HPwmText Confidential/Confidential
#ExtractedKey: HPwmText Copy/Copy
#ExtractedKey: HPwmText Copyright/Copyright
#ExtractedKey: HPwmText Draft/Draft
#ExtractedKey: HPwmText FileCopy/File Copy
#ExtractedKey: HPwmText Final/Final
#ExtractedKey: HPwmText ForInternalUse/For Internal Use Only
#ExtractedKey: HPwmText Preliminary/Preliminary
#ExtractedKey: HPwmText Proof/Proof
#ExtractedKey: HPwmText ReviewCopy/Review Copy
#ExtractedKey: HPwmText Sample/Sample
#ExtractedKey: HPwmText TopSecret/Top Secret
#ExtractedKey: HPwmText Urgent/Urgent
wmtest=Company Confidential
ps_wmtext=
    userdict /HPwmText (\%s{wmtest}) put

#ExtractedKey: HPwmFont CourierB/Courier Bold
#ExtractedKey: HPwmFont TimesB/Times Bold
#ExtractedKey: HPwmFont HelveticaB/Helvetica Bold
wmfont=Courier-Bold
ps_wmfont=
      /\%s{wmfont} findfont dup length dict begin
        {1 index /FID ne {def} {pop pop} ifelse} forall
        /Encoding ISOLatin1Encoding def currentdict 
      end
      /HPwmFont exch definefont pop

#ExtractedKey: HPwmFontSize pt24/24 Points
#ExtractedKey: HPwmFontSize pt30/30 Points
#ExtractedKey: HPwmFontSize pt36/36 Points
#ExtractedKey: HPwmFontSize pt42/42 Points
#ExtractedKey: HPwmFontSize pt48/48 Points
#ExtractedKey: HPwmFontSize pt54/54 Points
#ExtractedKey: HPwmFontSize pt60/60 Points
#ExtractedKey: HPwmFontSize pt66/66 Points
#ExtractedKey: HPwmFontSize pt72/72 Points
#ExtractedKey: HPwmFontSize pt78/78 Points
#ExtractedKey: HPwmFontSize pt84/84 Points
#ExtractedKey: HPwmFontSize pt90/90 Points
wmsize=24
ps_wmsize=
    userdict /HPwmSize \%d{wmsize} put

#ExtractedKey: HPwmTextAngle Deg90/90 Degrees
#ExtractedKey: HPwmTextAngle Deg75/75 Degrees
#ExtractedKey: HPwmTextAngle Deg60/60 Degrees
#ExtractedKey: HPwmTextAngle Deg45/45 Degrees
#ExtractedKey: HPwmTextAngle Deg30/30 Degrees
#ExtractedKey: HPwmTextAngle Deg15/15 Degrees
#ExtractedKey: HPwmTextAngle Deg0/0 Degrees
#ExtractedKey: HPwmTextAngle DegN15/-15 Degrees
#ExtractedKey: HPwmTextAngle DegN30/-30 Degrees
#ExtractedKey: HPwmTextAngle DegN45/-45 Degrees
#ExtractedKey: HPwmTextAngle DegN60/-60 Degrees
#ExtractedKey: HPwmTextAngle DegN75/-75 Degrees
#ExtractedKey: HPwmTextAngle DegN90/-90 Degrees
wmangle=90
ps_wmangle=
    userdict /HPwmAngle \%d{wmangle} put

#ExtractedKey: HPwmTextStyle Narrow/Narrow Outline
ps_wmtextstylenarrow=
    userdict /HPwmStyle .24 put

#ExtractedKey: HPwmTextStyle Medium/Medium Outline
ps_wmtextstylemedium=
    userdict /HPwmStyle .48 put

#ExtractedKey: HPwmTextStyle Wide/Wide Outline
ps_wmtextstylewide=
    userdict /HPwmStyle .96 put

#ExtractedKey: HPwmTextStyle Halo/Wide Halo Outline
ps_wmtextstylehalo=
    userdict /HPwmStyle .96 put userdict /HPwmStyle1 .84 put

#ExtractedKey: HPwmLocation True/All Pages
ps_wmallpages=
    userdict /HPwmLocation true put

#ExtractedKey: HPwmLocation False/First Page Only
ps_wmfirstpage=
    userdict /HPwmLocation false put

#ExtractedKey: HPCollate True/On (turn off in application)
collate=true
ps_collate=<</Collate \%s{collate}>> setpagedevice

#ExtractedKey: HPCollate False/Off
# ps_collateoff=
    <</Collate false>> setpagedevice

#ExtractedKey: Smoothing True/On
ps_smoothing=[ smoothingon ]
ps_nosmoothing=[ smoothingoff ]
ps_smoothingon=
      << /PostRenderingEnhance true /PostRenderingEnhanceDetails << /REValue 2 /Type 8 >>
      >> setpagedevice

#ExtractedKey: Smoothing False/Off
ps_smoothingoff=
      << /PostRenderingEnhance true /PostRenderingEnhanceDetails << /REValue 0 /Type 8 >>
      >> setpagedevice

#
# Paper size selection ...
#

#ExtractedKey: PageSize Letter/Letter
ps_letter=<</PageSize [612 792] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize Executive/Executive
ps_executive=<</PageSize [522 756] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize Legal/Legal
ps_legal=<</PageSize [612 1008] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize A4/A4
ps_a4=<</PageSize [595 842] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize A5/A5
ps_a5=<</PageSize [420 595] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize B5/B5 (JIS)
ps_b5=<</PageSize [516 729] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize w612h935/Executive (JIS)
ps_w612h935=<</PageSize [612 935] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize w558h774/16K
ps_w558h774=<</PageSize [558 774] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize Env10/Envelope #10
ps_env10=<</PageSize [297 684] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize EnvMonarch/Envelope Monarch
ps_envmonarch=<</PageSize [279 540] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize EnvDL/Envelope DL
ps_envdl=<</PageSize [312 624] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize EnvC5/Envelope C5
ps_envc5=<</PageSize [459 649] /ImagingBBox null>> setpagedevice
#ExtractedKey: PageSize EnvISOB5/Envelope B5
ps_envb5=<</PageSize [499 709] /ImagingBBox null>> setpagedevice

#
# source ...
#
    
#ExtractedKey: InputSlot Upper/ Tray 1
ps_inupper=[ intray1 ]
ps_intray1=<</ManualFeed false /MediaPosition 3>> setpagedevice
#ExtractedKey: InputSlot ManualFeed/ Tray 1 (Manual)
ps_manualfeed=[ manual ]
ps_manual=<</ManualFeed true /MediaPosition 3>> setpagedevice
#ExtractedKey: InputSlot Middle/ Tray 2
ps_inmiddle=[ intray2 ]
ps_intray2=<</ManualFeed false /MediaPosition 0>> setpagedevice
#ExtractedKey: InputSlot Lower/ Tray 3
ps_inlower=[ intray3 ]
ps_intray3=currentpagedevice /InputAttributes get 1 known
      {<</ManualFeed false /MediaPosition 1>> setpagedevice}
      {currentpagedevice /InputAttributes get 5 known
        {<</ManualFeed false /MediaPosition 5>> setpagedevice}if}ifelse
#ExtractedKey: InputSlot LargeCapacity/ Tray 4
ps_inlarge=[ intray4 ]
ps_inlargecapacity=[ intray4 ]
ps_intray4=currentpagedevice /InputAttributes get 4 known
      {<</ManualFeed false /MediaPosition 4>> setpagedevice}
      {currentpagedevice /InputAttributes get 1 known
        {<</ManualFeed false /MediaPosition 5>> setpagedevice}
        {<</ManualFeed false /MediaPosition 6>> setpagedevice}ifelse}ifelse

#ExtractedKey: InputSlot Tray5/ Tray 5
ps_intray5=currentpagedevice /InputAttributes get 1 known
      {<</ManualFeed false /MediaPosition 6>> setpagedevice}
      {<</ManualFeed false /MediaPosition 7>> setpagedevice}ifelse

#ExtractedKey: InputSlot Tray6/ Tray 6
ps_intray6=currentpagedevice /InputAttributes get 1 known
      {<</ManualFeed false /MediaPosition 7>> setpagedevice}
      {<</ManualFeed false /MediaPosition 8>> setpagedevice}ifelse

#ExtractedKey: InputSlot Tray7/ Tray 7
ps_intray7=currentpagedevice /InputAttributes get 1 known
      {<</ManualFeed false /MediaPosition 8>> setpagedevice}
      {<</ManualFeed false /MediaPosition 9>> setpagedevice}ifelse

#ExtractedKey: InputSlot Tray8/ Tray 8
ps_intray8=
    currentpagedevice /InputAttributes get 1 known
      {<</ManualFeed false /MediaPosition 9>> setpagedevice}
      {<</ManualFeed false /MediaPosition 10>> setpagedevice}ifelse

#ExtractedKey: InputSlot Tray9/ Tray 9
ps_intray9=
    currentpagedevice /InputAttributes get 1 known
      {<</ManualFeed false /MediaPosition 10>> setpagedevice}
      {<</ManualFeed false /MediaPosition 11>> setpagedevice}ifelse

#ExtractedKey: InputSlot Tray10/ Tray 10
ps_intray10=
    currentpagedevice /InputAttributes get 1 known
      {<</ManualFeed false /MediaPosition 11>> setpagedevice}
      {<</ManualFeed false /MediaPosition 12>> setpagedevice}ifelse

#ExtractedKey: InputSlot Envelope/ Envelope Feeder
ps_envelope=
    <</ManualFeed false /MediaPosition 2>> setpagedevice

#
# Media type ...
#
#ExtractedKey: InputSlot Plain/Plain
ps_plain=<</ManualFeed false /MediaType (Plain)>> setpagedevice

#ExtractedKey: InputSlot Preprinted/Preprinted
ps_preprinted=<</ManualFeed false /MediaType (Preprinted)>> setpagedevice

#ExtractedKey: InputSlot Letterhead/Letterhead
ps_letterhead=<</ManualFeed false /MediaType (Letterhead)>> setpagedevice

#ExtractedKey: InputSlot Transparency/Transparency
ps_transparancy=<</ManualFeed false /MediaType (Transparency)>> setpagedevice

#ExtractedKey: InputSlot Prepunched/Prepunched
ps_prepunched=<</ManualFeed false /MediaType (Prepunched)>> setpagedevice

#ExtractedKey: InputSlot Labels/Labels
ps_labels=<</ManualFeed false /MediaType (Labels)>> setpagedevice

#ExtractedKey: InputSlot Bond/Bond
ps_bond=<</ManualFeed false /MediaType (Bond)>> setpagedevice

#ExtractedKey: InputSlot Recycled/Recycled
ps_recycled=<</ManualFeed false /MediaType (Recycled)>> setpagedevice

#ExtractedKey: InputSlot Color/Color
ps_mediacolor=<</ManualFeed false /MediaType (Color)>> setpagedevice

#ExtractedKey: InputSlot Cardstock/Card Stock
ps_cardstock=<</ManualFeed false /MediaType (Card Stock)>> setpagedevice

#ExtractedKey: InputSlot Rough/Rough
ps_rough=<</ManualFeed false /MediaType (Rough)>> setpagedevice

#ExtractedKey: HPPaperPolicy PromptUser/Prompt User
ps_promptuser=<</DeferredMediaSelection true>> setpagedevice

#ExtractedKey: HPPaperPolicy NearestSizeAdjust/Nearest Size and Scale
ps_nearestsizeadjust=<</DeferredMediaSelection false /Policies << /PageSize 3 >> >> setpagedevice
#ExtractedKey: HPPaperPolicy NearestSizeNoAdjust/Nearest Size and Crop
ps_nearestsizenoadjust=<</DeferredMediaSelection false /Policies << /PageSize 5 >> >> setpagedevice

#ExtractedKey: HPPaperPolicy Letter/Letter
ps_policyletter=
    userdict begin
      /HPppX1 0 def
      /HPppY1 0 def
      /HPppScale 1 def
    
      <</DeferredMediaSelection true
        /BeginPage {pop userdict begin HPppX1 HPppY1 translate HPppScale HPppScale scale end} bind>> setpagedevice
    
      /HPwmSPD {setpagedevice} bind def
      /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
          /HPppScale 612 HPwmPgWidth div dup 792 HPwmPgHeight div dup 3 1 roll lt {pop} {exch pop} ifelse def
          HPppScale 1 gt {/HPppScale 1 def}if
          /HPppX1 612 HPwmPgWidth HPppScale mul sub 2 div def
          /HPppY1 792 HPwmPgHeight HPppScale mul sub 2 div def
          <</PageSize [612 792] /ImagingBBox null>> setpagedevice}{setpagedevice}ifelse end} bind def
    end

#ExtractedKey: HPPaperPolicy A4/A4
ps_policya4=
    userdict begin
      /HPppX1 0 def
      /HPppY1 0 def
      /HPppScale 1 def
    
      <</DeferredMediaSelection true
        /BeginPage {pop userdict begin HPppX1 HPppY1 translate HPppScale HPppScale scale end} bind>> setpagedevice
    
      /HPwmSPD {setpagedevice} bind def
      /setpagedevice {userdict begin dup /PageSize known {/HPwmPgWidth exch /PageSize get aload pop /HPwmPgHeight exch def def
          /HPppScale 595 HPwmPgWidth div dup 842 HPwmPgHeight div dup 3 1 roll lt {pop} {exch pop} ifelse def
          HPppScale 1 gt {/HPppScale 1 def}if
          /HPppX1 595 HPwmPgWidth HPppScale mul sub 2 div def
          /HPppY1 842 HPwmPgHeight HPppScale mul sub 2 div def
          <</PageSize [595 842] /ImagingBBox null>> setpagedevice}{setpagedevice}ifelse end} bind def
    end

#ExtractedKey: HPScalePatterns Scale/On
ps_scalepatterns=
    /GDIBWPatternDict 18 dict def
    /dtransform {GDIBWPatternDict /Width known {currentpagedevice /HWResolution get 0 get
    150 div mul exch currentpagedevice /HWResolution get 0 get 150 div mul exch dtransform}{dtransform}ifelse} bind def

#ExtractedKey: HPHalftone Enhanced/Enhanced
ps_halftoneenhanced=
       << /Install {
         currentpagedevice /HWResolution get
         dup 0 get 600 eq exch 1 get 600 eq and
         { /EnhancedColorRendering600 } { /EnhancedColorRendering } ifelse
         /ColorRendering findresource setcolorrendering
         /EnhancedHalftone /Halftone findresource sethalftone
         { } settransfer false setstrokeadjust
       }
       >> setpagedevice
       currentpagedevice /HWResolution get dup 0 get 600 eq exch 1 get 600 eq and
       {
           << /PostRenderingEnhance true
                /PostRenderingEnhanceDetails << /REValue 0 /Type 8 >>
           >> setpagedevice
       } if
       /setscreen { pop pop pop } def
       /setcolorscreen { pop pop pop pop pop pop pop pop pop pop pop pop } def
       /sethalftone { pop } def 


#ExtractedKey: HPHalftone Standard/Standard
ps_halftonestandard=
       << /Install {
         currentpagedevice /HWResolution get
         dup 0 get 600 eq exch 1 get 600 eq and dup
         currentpagedevice /PostRenderingEnhance get
         currentpagedevice /PostRenderingEnhanceDetails get /REValue get 0 ne and
         { {/DefaultColorRenderingRE600} {/DefaultColorRenderingRE} ifelse}
         { {/DefaultColorRendering600} {/DefaultColorRendering} ifelse} ifelse
         /ColorRendering findresource setcolorrendering
         { /DefaultHalftone600 } {/DefaultHalftone} ifelse
         /Halftone findresource sethalftone
         {} settransfer false setstrokeadjust
       } >> setpagedevice
       currentpagedevice /HWResolution get dup 0 get 600 eq exch 1 get 600 eq and
       {
         << /PostRenderingEnhance true /PostRenderingEnhanceDetails
         << /REValue 0 /Type 8 >> >> setpagedevice
       } if


#
# Duplex control ..
#

#ExtractedKey: Duplex DuplexNoTumble/Flip on Long Edge (Standard)
ps_duplex=<</Duplex true /Tumble false>> setpagedevice
ps_lduplex=[ duplex ]

#ExtractedKey: Duplex DuplexTumble/Flip on Short Edge
ps_duplexshort=<</Duplex true /Tumble true>> setpagedevice
ps_sduplex=[ duplexshort ]
ps_duplexshortedge=[ duplexshort ]

#ExtractedKey: Duplex None/Off (1-Sided)
ps_simplex=<</Duplex false>> setpagedevice

ps_tumble=<</Tumble true>> setpagedevice
ps_shortedge=[ tumble ]

ps_user_opts += [
	a4 a5 b5 bond cardstock collate duplex duplexshort duplexshortedge env10
	envb5 envc5 envdl envelope envmonarch executive fourup fourupl halftoneenhanced
	halftonestandard inlarge inlargecapacity inlower inmiddle intray1 intray10
	intray2 intray3 intray4 intray5 intray6 intray7 intray8 intray9
	inupper labels lduplex legal letter letterhead manual manualfeed mediacolor
	nearestsizeadjust nearestsizenoadjust nineuo nineupl nosmoothing oneup
	oneupl plain policya4 policyletter preprinted prepunched promptuser recycled rough
	scalepatterns sduplex shortedge simplex sixteenup sixteenupl sixup sixupl smoothing
	smoothingoff smoothingon transparancy tumble twoup twoupl w558h774 w612h935
	wmallpages wmangle wmfirstpage wmfont wmsize wmtext wmtextstylehalo wmtextstylemedium
	wmtextstylenarrow wmtextstylewide
    ]
#
#!End of [ hp4050 ]

##
##  QMS Printers do not seem to return status or other information
##  you may need to configure them to connect on port 35
## printcap 
##  lp:ifhp=model=qms1725,dev=qms.printer.ip.addr%35
##    :lp=/dev/null
##    :if=..../ifhp
##

# PRINTER qms1725 - QMS 1725, uses appsocket, no status, PostScript only
[ qms1725 ]
appsocket
# close_connection
status@
pjl@
pcl@
ps
text@

file_output_match = [
  *postscript*       ps
  *text*             ps      \%s{a2ps_converter}
  *pdf*              filter  \%s{pdf2ps_converter}
  *gzip_compressed*  filter  \%s{gzip_decompress}
  ]

#*DefaultDuplex: None
#*Duplex None: statusdict begin false setduplexmode false settumble end
ps_simplex=statusdict begin false setduplexmode false settumble end
#*Duplex DuplexNoTumble: statusdict begin true setduplexmode false settumble end
ps_duplex=statusdict begin true setduplexmode false settumble end
ps_lduplex=[ duplex ]
#*Duplex DuplexTumble: statusdict begin true setduplexmode true settumble end
ps_duplexshort=statusdict begin true setduplexmode true settumble end
ps_sduplex=[ duplexshort ]

ps_tumble=statusdict begin true settumble end
ps_shortedge=[ tumble ]

#*InputSlot Upper: statusdict begin 1 setpapertray end
ps_inupper=statusdict begin 1 setpapertray end
#*InputSlot Lower: statusdict begin 2 setpapertray end
ps_inlower=statusdict begin 2 setpapertray end
#*InputSlot Envelope: statusdict begin 3 setpapertray end
ps_envelope=statusdict begin 3 setpapertray end

ps_manual=   1 dict dup /ManualFeed true put setpagedevice

#*OutputBin Upper: statusdict begin 1 setoutputray end
#*OutputBin Back: statusdict begin 2 setoutputtray end

ps_outupper= statusdict begin 1 setoutputray end
ps_outlower= statusdict begin 2 setoutputtray end

# QMS 2025 appears to be HP compatible
# QMS 860 has same tray as QMS2025
# PRINTER % - QMS Laser Printer {/qms(.*)/QMS $1/}, appsocket, no status, PostScript and PCL
[ qms2025 qms860 qms2060 ]
appsocket
# close_connection
status@
pjl@
pcl
ps
text@
#*PageSize Letter: statusdict begin lettertray end
ps_letter=statusdict begin lettertray end
#*PageSize Legal: statusdict begin legaltray end
ps_legal=statusdict begin legaltray end
#*PageSize Tabloid: statusdict begin 11x17tray end
ps_ledger=statusdict begin 11x17tray end
#*PageSize Executive: statusdict begin executivetray end
ps_executive=statusdict begin executivetray end
#*PageSize A3: statusdict begin a3tray end
ps_a3=statusdict begin a3tray end
#*PageSize A4: statusdict begin a4tray end
ps_a4=statusdict begin a4tray end
#*PageSize A5: statusdict begin a5tray end
ps_a5=statusdict begin a5tray end
#*PageSize B4: statusdict begin b4tray end
ps_b4=statusdict begin b4tray end
#*PageSize B5: statusdict begin b5tray end
ps_b5=statusdict begin b5tray end
#*PageSize B6: statusdict begin b6tray end
ps_b6=statusdict begin b6tray end


## Tektronix Color Printers
##  uses 'appsocket' protcol
##   TCP port 9100
##    receives job status
##
## printcap entry:
##  lp:cm=Phaser
##    :lp=/dev/null
##    :ifhp=model=phaser,dev=10.0.0.1%9100
##    :if=/dev/env/DJDIR/etc/filters/ifhp
##
##  OR
##
##  lp:cm=Phaser
##    :lp=/dev/null
##    :if=/dev/env/DJDIR/etc/filters/ifhp -Tmodel=phaser,dev=10.0.0.1%9100
##
##  If you insist on banner pages or need powerful accounting
##  and need an OF filter
##  then add (respectively to the above examples):
##
##    :of=/dev/env/DJDIR/etc/filters/ifhp
##  OR
##    :of=/dev/env/DJDIR/etc/filters/ifhp -Tmodel=phaser,dev=10.0.0.1%9100
##  

# PRINTER % - Generic Tektronics Phaser Color Printer, appsocket, PostScript only
[ phaser ]
appsocket
# close_connection
pjl@
pcl@
ps
sync@

file_output_match = [
  *postscript*       ps
  *text*             ps      \%s{a2ps_converter}
  *pdf*              filter  \%s{pdf2ps_converter}
  *gzip_compressed*  filter  \%s{gzip_decompress}
  ]

ps_pagecount_code=%!
  false 0 startjob pop
  (%%[ pagecount: )print statusdict /pagecount get exec (                )cvs
   print
  ( ]%% )= flush
ps_inupper=
  product (Phaser 2) anchorsearch
  { pop pop 2 dict begin
     /InputAttributes 1 dict begin /Priority [0] def currentdict
  end def }
  {  (Phaser 440) anchorsearch
     { pop pop 3 dict begin
         /MediaType (Upper Tray) def
        /MediaColor null def }
    { pop 4 dict begin
        /MediaPosition 0 def
        /MediaType null def
        /ManualFeed false def } ifelse
  } ifelse
  /TraySwitch false def
  currentdict end setpagedevice

ps_transparency=
  mark
  {
    4 dict begin
      /MediaPosition null def
      /MediaType (Transparency) def
      /TraySwitch true def
      /ManualFeed false def
      currentdict end setpagedevice
  } stopped cleartomark

# PRINTER % - Tektronics Phaser {/phaser(.*)/$1/} Color Printer, appsocket, PostScript only
[ phaser360 phaser740 phaser750 phaser850 ]

# use the generic phaser definitions
tc=phaser
# The following is required for transparency selection on
# the Phaser 360, Phaser 740, Phaser 750 and Phaser850:
#  These updates from:
# kreiser@axp602.gsi.de (Helmut Kreiser, Linux + VMS Admin,
#   GSI Darmstadt, H.Kreiser@gsi.de, Tel.: +(49)(0)6159 71-(0)-2517)

#  Note: your local printer may not handle the 'permanent selection'
#  version.  If so,  then use the following and comment the others out.
#   Patrick Powell
#ps_transparency=
#                << /MediaPosition null 
#                   /MediaClass (Transparency) 
#                   /TraySwitch true 
#                   /ManualFeed false 
#                >> setpagedevice
#
#ps_transparency=
#                 true 0 startjob not { /exitserver errordict/invalidaccess get
#                 exec quit } if <</Duplex true /Tumble false>> setpagedevice false
#                 0 startjob pop
#                 << /MediaPosition null
#                    /MediaClass (Transparency)
#                    /TraySwitch true
#                    /ManualFeed false
#                 >> setpagedevice
#
#ps_simplex=
#                 true 0 startjob not { /exitserver errordict/invalidaccess get
#                 exec quit } if <</Duplex true /Tumble false>> setpagedevice false
#                 0 startjob pop
#                 <</Duplex false /Tumble false>> setpagedevice
#
#ps_duplex=
#                 true 0 startjob not { /exitserver errordict/invalidaccess get
#                 exec quit } if <</Duplex true /Tumble false>> setpagedevice false
#                 0 startjob pop
#                 <</Duplex true /Tumble false>> setpagedevice

# The following is required for tray selection 
# with permanent selection

# we could set the defaults so that we force the tray selection
# ps_init += [ inlower simplex ]

ps_inupper=
  %  Wrap function with startjob to make the change persistent.
  %   true 0 startjob not { /exitserver errordict /invalidaccess get exec quit } if
   /pt { product exch anchorsearch { pop pop true } { pop false } ifelse } bind def
   << (Phaser 350) pt (Phaser 380) pt or (Phaser 360) pt or
     { << /HWResolution /Default /OutputDevice findresource /HWResolution get
       dup length 1 sub get >> setpagedevice }
     { (Phaser 550) pt { /HWResolution [1200 600] /ProcessColorModel /DeviceCMYK }
       { (Phaser 540) pt { /HWResolution [600 600] }
         { /HWResolution [300 300] } ifelse
         /PostRenderingEnhance true /PostRenderingEnhanceDetails
          << /OutputMode (Enhanced) >> } ifelse } ifelse >> setpagedevice
   userdict /pt undef
  %   false 0 startjob pop
  %  Wrap function with startjob to make the change persistent.
  %   This seems to check for some language level...
  %   systemdict/languagelevel known{languagelevel 2 ge{true (0) startjob dup not
  %    {/exitserver errordict/invalidaccess get exec}if}{false}ifelse}{false}ifelse
  %   not {quit} if
   mark { product (Phaser 2) anchorsearch
     { pop pop 2 dict begin
         /InputAttributes 1 dict begin /Priority [0] def currentdict end def }
     { (Phaser 4) anchorsearch
       { pop pop 3 dict begin
         languagelevel 3 lt {/MediaType}{/MediaClass} ifelse (Upper Tray) def
         /MediaColor null def }
       { pop 4 dict begin
         /MediaPosition 0 def
         languagelevel 3 lt {/MediaType}{/MediaClass} ifelse null def
         /ManualFeed false def } ifelse } ifelse /TraySwitch false def
     currentdict end setpagedevice } stopped cleartomark
  %  false (0) startjob pop

# The following is required for paper selection
# with permanent selection

ps_inlower=
  %  Wrap function with startjob to make the change persistent.
  %   true 0 startjob not { /exitserver errordict /invalidaccess get exec quit } if
   /pt { product exch anchorsearch { pop pop true } { pop false } ifelse } bind def
   << (Phaser 350) pt (Phaser 380) pt or (Phaser 360) pt or
     { << /HWResolution /Default /OutputDevice findresource /HWResolution get
        dup length 1 sub get >> setpagedevice }
     { (Phaser 550) pt { /HWResolution [1200 600] /ProcessColorModel /DeviceCMYK }
       { (Phaser 540) pt { /HWResolution [600 600] }
         { /HWResolution [300 300] } ifelse
         /PostRenderingEnhance true /PostRenderingEnhanceDetails <<
           /OutputMode (Enhanced) >> } ifelse } ifelse >> setpagedevice
   userdict /pt undef
  %  false 0 startjob pop
  %  Wrap function with startjob to make the change persistent.
  %   systemdict/languagelevel known{languagelevel 2 ge{true (0) startjob dup not
  %    {/exitserver errordict/invalidaccess get exec}if}{false}ifelse}{false}ifelse
  %     not {quit} if
   /pt { product exch anchorsearch { pop pop true }{ pop false } ifelse } bind def
   mark { 4 dict begin (Phaser 2) pt
    { /InputAttributes 1 dict begin /Priority [1] def currentdict end def }
    { (Phaser 4) pt {
       languagelevel 3 lt {/MediaType}{/MediaClass} ifelse (Lower Tray) def
       /MediaColor null def } { (Phaser 5) pt
           {/MediaPosition 2 def }
           {/MediaPosition 1 def } ifelse
           languagelevel 3 lt {/MediaType}{/MediaClass} ifelse null def
           /ManualFeed false def } ifelse } ifelse
       /TraySwitch false def currentdict end setpagedevice } stopped cleartomark
   userdict /pt undef
  %  false (0) startjob pop

ps_transparency=
  %  Wrap function with startjob to make the change persistent.
  %   true 0 startjob not { /exitserver errordict/invalidaccess get exec quit } if
   /pt { product exch anchorsearch { pop pop true }{ pop false } ifelse } bind def
   << /MediaPosition  (Phaser 8) pt
      { currentpagedevice /InputAttributes get dup 2 known { pop 1}
      { 1 known {1}{0} ifelse} ifelse } { 1} ifelse
     languagelevel 2 le {/MediaType}{/MediaClass} ifelse null /ManualFeed false
     /TraySwitch false >> setpagedevice
  %   false 0 startjob pop
  %  Wrap function with startjob to make the change persistent.
  %   true 0 startjob not { /exitserver errordict/invalidaccess get exec quit } if
   /pt { product exch anchorsearch { pop pop true }{ pop false } ifelse } bind def
   << (Phaser 550) pt (Phaser 560) pt or (Phaser 740) pt or (Phaser 750) pt or {
      /HWResolution [1200 1200] /ProcessColorModel /DeviceCMYK
      (Phaser 560) pt (Phaser 740) pt or { /PostRenderingEnhance true
      /PostRenderingEnhanceDetails << /Type 5 /OutputMode (Standard) >> } if }{
      (Phaser 780) pt {  /HWResolution [600 600] /ProcessColorModel /DeviceCMYK
      /DeviceRenderingInfo currentpagedevice 1 index get 1 dict copy
      dup /ValuesPerColorComponent 16 put }{ /PostRenderingEnhance true
      /PostRenderingEnhanceDetails <</OutputMode (Premium)>> } ifelse } ifelse
   >> setpagedevice
   userdict /pt undef
  % false 0 startjob pop
  %   %  Wrap function with startjob to make the change persistent.
  %  true 0 startjob not { /exitserver errordict/invalidaccess get exec quit } if
   <</Duplex false /Tumble false>> setpagedevice
  % false 0 startjob pop

# The following is required for paper simplex/duplex selection
# with permanent selection

ps_simplex=
  %  Wrap function with startjob to make the change persistent.
  %   true 0 startjob not { /exitserver errordict/invalidaccess get exec quit } if
   /pt { product exch anchorsearch { pop pop true }{ pop false } ifelse } bind def
   << /ManualFeed false /TraySwitch false (Phaser 2) pt { 
      /InputAttributes <</Priority [1]>> }{ (Phaser 4) pt { /MediaType (Lower Tray)
      /MediaColor null }{ /MediaPosition (Phaser 8) pt {
      currentpagedevice /InputAttributes get dup 2 known { pop 2 }{
      1 known {1}{0} ifelse } ifelse }{
      (Phaser 5) pt (Phaser 740) pt or (Phaser 750) pt or {2}{1} ifelse } ifelse
      languagelevel 2 le {/MediaType}{/MediaClass} ifelse null } ifelse } ifelse
   >> setpagedevice
   userdict /pt undef
  %  false 0 startjob pop
  %  Wrap function with startjob to make the change persistent.
  %   true 0 startjob not { /exitserver errordict/invalidaccess get exec quit } if
   /pt { product exch anchorsearch { pop pop true }{ pop false } ifelse } bind def
   << (Phaser 550) pt (Phaser 560) pt or (Phaser 740) pt or (Phaser 750) pt or {
     /HWResolution [1200 1200] /ProcessColorModel /DeviceCMYK
     (Phaser 560) pt (Phaser 740) pt or { /PostRenderingEnhance true
     /PostRenderingEnhanceDetails << /Type 5 /OutputMode (Standard) >> } if }{
     (Phaser 780) pt { /HWResolution [600 600] /ProcessColorModel /DeviceCMYK
     /DeviceRenderingInfo currentpagedevice 1 index get 1 dict copy
     dup /ValuesPerColorComponent 16 put }{ /PostRenderingEnhance true
     /PostRenderingEnhanceDetails <</OutputMode (Premium)>> } ifelse } ifelse
   >> setpagedevice
   userdict /pt undef
  % false 0 startjob pop
  %  Wrap function with startjob to make the change persistent.
  %   true 0 startjob not { /exitserver errordict/invalidaccess get exec quit } if
   <</Duplex false /Tumble false>> setpagedevice
  % false 0 startjob pop

ps_duplex=
  %  Wrap function with startjob to make the change persistent.
  % true 0 startjob not { /exitserver errordict/invalidaccess get exec quit } if
   /pt { product exch anchorsearch { pop pop true }{ pop false } ifelse } bind def
   << /ManualFeed false /TraySwitch false (Phaser 2) pt { 
      /InputAttributes <</Priority [1]>> }{ (Phaser 4) pt { /MediaType (Lower Tray)
      /MediaColor null }{ /MediaPosition (Phaser 8) pt {
      currentpagedevice /InputAttributes get dup 2 known { pop 2 }{
      1 known {1}{0} ifelse } ifelse }{
      (Phaser 5) pt (Phaser 740) pt or (Phaser 750) pt or {2}{1} ifelse } ifelse
      languagelevel 2 le {/MediaType}{/MediaClass} ifelse null } ifelse } ifelse
   >> setpagedevice
   userdict /pt undef
  % false 0 startjob pop
  %  Wrap function with startjob to make the change persistent.
  % true 0 startjob not { /exitserver errordict/invalidaccess get exec quit } if
   /pt { product exch anchorsearch { pop pop true }{ pop false } ifelse } bind def
   << (Phaser 550) pt (Phaser 560) pt or (Phaser 740) pt or (Phaser 750) pt or {
     /HWResolution [1200 1200] /ProcessColorModel /DeviceCMYK
     (Phaser 560) pt (Phaser 740) pt or { /PostRenderingEnhance true
     /PostRenderingEnhanceDetails << /Type 5 /OutputMode (Standard) >> } if }{
     (Phaser 780) pt { /HWResolution [600 600] /ProcessColorModel /DeviceCMYK
     /DeviceRenderingInfo currentpagedevice 1 index get 1 dict copy
     dup /ValuesPerColorComponent 16 put }{ /PostRenderingEnhance true
     /PostRenderingEnhanceDetails <</OutputMode (Premium)>> } ifelse } ifelse
   >> setpagedevice
   userdict /pt undef
  % false 0 startjob pop
  %  Wrap function with startjob to make the change persistent.
  % true 0 startjob not { /exitserver errordict/invalidaccess get exec quit } if
   <</Duplex true /Tumble false>> setpagedevice
  % false 0 startjob pop

#! end [ phaser 750 ]

# PRINTER % - Phaser 5400, understands PCL and PostScript, needs appsocket
#  You can use a program to get the status and pagecount information
#   see the phaser5400_snmp_status utility in the distribution ifhp/UTILS directory

[ phaser5400 ] 
tc=hp4000_pcl

appsocket
sync=|/program_not_specified
sync
pagecount=|/program_not_specified
pagecount
waitend=|/program_not_specified
waitend

ps_simplex= <</Duplex false /Tumble false>> setpagedevice
ps_duplex= <</Duplex true /Tumble false>> setpagedevice
ps_lduplex=[ duplex ]
ps_sduplex= <</Duplex true /Tumble true>> setpagedevice

ps_collate=
  currentpagedevice /Collate known
    {currentpagedevice /Collate get
      {(True)}{(False)} ifelse}
    {(Unknown)}
  ifelse = flush
 restore "

ps_draft=  << /HWResolution [600 600] /Policies <</HWResolution 2 >>
     /PostRenderingEnhance true 
     /PostRenderingEnhanceDetails
      << /REValue 0 /TonerSaver 1 /Type 18 >>
  >> setpagedevice 


ps_normal=   << /HWResolution [1200 1200] /Policies <</HWResolution 2 >> 
     /PostRenderingEnhance true 
     /PostRenderingEnhanceDetails
      << /REValue 0 /TonerSaver 0 /Type 18 >>
  >> setpagedevice 

ps_high=[ normal]
ps_fast=[ draft ] 

#
# Position 1 is the MBF (manual bypass feeder)
#   Must specify Manual Feed or it will go to next tray (tray2) if empty
# Position 0 is tray 1 (top tray)
# Position 2 is tray 2
# Position 3 is tray 3 (assumed to be large-capacity feeder--would anyone 
#   get a large-capacity feeder without the second tray option up at the top?
#
ps_manual= <</ManualFeed true /MediaPosition 1 >> setpagedevice
ps_inupper= <</MediaPosition 0 >> setpagedevice
ps_intray1=[ ps_inupper ]
ps_inlower= <</MediaPosition 2 >> setpagedevice
ps_intray2=[ ps_inlower ]
ps_inlargecapacity= <</MediaPosition 3 >> setpagedevice
ps_inlarge=[ inlargecapacity ]
ps_intray3=[ inlargecapacity ]

# PRINTER % - Lexmark 4039, Postscript only
[ lexmark4039 ]
pcl@
pjl@
ps
ps_init=[ sync ]
ps_sync=
  serverdict begin 0 exitserver
  statusdict begin true setenginesync end
ps_async=
  serverdict begin 0 exitserver
  statusdict begin false setenginesync end

file_output_match = [
  *postscript*       ps
  *text*             ps      \%s{a2ps_converter}
  *pdf*              ps      \%s{pdf2ps_converter}
  *gzip_compressed*  filter  \%s{gzip_decompress}
  ]

# PRINTER % - Lexmark Optra e312, Postscript, PCL and PJL
[ lexmark_optra_e312 ]

# Lexmark Optra e312 IFHP printer configuration
# Contribued by:
#   Lars Kellogg-Stedman <lars@larsshack.org>
#   Fri, 21 Jul 2000 23:55:14 -0400 (EDT)
## You may want to add the following xxx-to-ps converters
##  file_output_match += [
##        *gif*                   filter  \%s{gif_converter}
##        *jpeg*                  filter  \%s{jpeg_converter}
##        *tiff*                  filter  \%s{tiff_converter}
##        *gzip_compressed*       filter  \%s{gzip_decompress}
##        *postscript*            ps
##        *roff*                  ps      \%s{troff_converter}
##        *text*                  ps      \%s{a2ps_converter}
##        *pdf*                   ps      \%s{pdf_converter}
##        *dvi*                   ps      \%s{dvi_converter}
##        *pnm*                   ps      \%s{pnm_converter}
##        *ppm*                   ps      \%s{pnm_converter}
##  ]
##

## The lexmark supports both pcl and pjl in addition to postscript.
pcl
pjl

pjl_user_opts += [
		density economode noeconomode picturegrade nopicturegrade
	]

pjl_density = @PJL SET DENSITY = \%s{density}

pjl_economode = @PJL SET ECONOMODE = ON
pjl_noeconomode = @PJL SET ECONOMODE = OFF

pjl_picturegrade = @PJL SET LPARM:POSTSCRIPT LPICTUREGRADE = ON
pjl_nopicturegrade = @PJL SET LPARM:POSTSCRIPT LPICTUREGRADE = OFF

ps_user_opts += [
		smoothing nosmoothing enhance noenhance
		300x300 600x600 plain cardstock transparency
		labels bond letterhead preprinted color envelope
		custom1 custom2 custom3 custom4 custom5 custom6
		lxcollate nolxcollate letter legal b5 a4
		executive a5 universal monarch c9 comm10 dl c5
		isob5 other autoselect intray1 manual
	]

ps_smoothing = %% Turn smoothing ON
	<< /PostRenderingEnhanceDetails << /REValue 2 >> >> setpagedevice
ps_nosmoothing = %% Turn smoothing OFF
	<< /PostRenderingEnhanceDetails << /REValue 0 >> >> setpagedevice

ps_enhance = %% Turn imageenhance ON
	1 dict dup /DeviceRenderingInfo 1 dict dup /ImageEnhancement 1 put put setpagedevice
ps_noenhance = %% Turn imageenhance OFF
	1 dict dup /DeviceRenderingInfo 1 dict dup /ImageEnhancement 0 put put setpagedevice

## resolution
ps_300x300 = %% Set resolution to 300x300
	<< /HWResolution [300 300] >> setpagedevice
ps_600x600 = %% Set resolution to 600x600
	<< /HWResolution [600 600] >> setpagedevice

ps_lxcollate = %% Turn lxcollate ON
	<< /Collate true >> setpagedevice
ps_nolxcollate = %% Turn lxcollate OFF
	<< /Collate false >> setpagedevice

## media types
ps_plain = << /MediaType (Plain) /Policies << /MediaType 2 >> >> setpagedevice
ps_cardstock = << /MediaType (Card Stock) /Policies << /MediaType 2 >> >> setpagedevice
ps_transparency = << /MediaType (Transparency) /Policies << /MediaType 2 >> >> setpagedevice
ps_labels = << /MediaType (Labels) /Policies << /MediaType 2 >> >> setpagedevice
ps_bond = << /MediaType (Bond) /Policies << /MediaType 2 >> >> setpagedevice
ps_letterhead = << /MediaType (Letterhead) /Policies << /MediaType 2 >> >> setpagedevice
ps_preprinted = << /MediaType (Preprinted) /Policies << /MediaType 2 >> >> setpagedevice
ps_color = << /MediaType (Color) /Policies << /MediaType 2 >> >> setpagedevice
ps_envelope = << /MediaType (Envelope) /Policies << /MediaType 2 >> >> setpagedevice
ps_custom1 = << /MediaType (Custom Type 1) /Policies << /MediaType 2 >> >> setpagedevice
ps_custom2 = << /MediaType (Custom Type 2) /Policies << /MediaType 2 >> >> setpagedevice
ps_custom3 = << /MediaType (Custom Type 3) /Policies << /MediaType 2 >> >> setpagedevice
ps_custom4 = << /MediaType (Custom Type 4) /Policies << /MediaType 2 >> >> setpagedevice
ps_custom5 = << /MediaType (Custom Type 5) /Policies << /MediaType 2 >> >> setpagedevice
ps_custom6 = << /MediaType (Custom Type 6) /Policies << /MediaType 2 >> >> setpagedevice

ps_letter = %% Letter
	2 dict dup /PageSize [612 792]  put dup /ImagingBBox null put setpagedevice
ps_legal = %% Legal
	2 dict dup /PageSize [612 1008] put dup /ImagingBBox null put setpagedevice
ps_b5 = %% B5
	2 dict dup /PageSize [516 729]  put dup /ImagingBBox null put setpagedevice
ps_a4 = %% A4
	2 dict dup /PageSize [595 842]  put dup /ImagingBBox null put setpagedevice
ps_executive = %% Executive
	2 dict dup /PageSize [522 756]  put dup /ImagingBBox null put setpagedevice
ps_a5 = %% A5
	2 dict dup /PageSize [420 595]  put dup /ImagingBBox null put setpagedevice
ps_universal = %% Universal
	2 dict dup /PageSize [612 1008]  put dup /ImagingBBox null put setpagedevice
ps_monarch = %% Monarch Envelope
	2 dict dup /PageSize [279 540]  put dup /ImagingBBox null put setpagedevice
ps_c9 = %% C9 Envelope
	2 dict dup /PageSize [279 639]  put dup /ImagingBBox null put setpagedevice
ps_comm10 = %% comm10 (Number 10 Envlope?)
	2 dict dup /PageSize [297 684]  put dup /ImagingBBox null put setpagedevice
ps_dl = %% DL Envelope
	2 dict dup /PageSize [312 624]  put dup /ImagingBBox null put setpagedevice
ps_c5 = %% C5 Envelope
	2 dict dup /PageSize [459 649]  put dup /ImagingBBox null put setpagedevice
ps_isob5 = %% ISO B5 Envelope
	2 dict dup /PageSize [499 708]  put dup /ImagingBBox null put setpagedevice
ps_other = %% Other Envelope (8.5 x 14)
	2 dict dup /PageSize [612 1008] put dup /ImagingBBox null put setpagedevice

## autoselect
ps_autoselect = %% Autoselect input tray
	1 dict dup /Policies 1 dict dup /PageSize 2 put put setpagedevice

ps_intray1 = %% Select input tray 1
	1 dict dup /ManualFeed false put setpagedevice
	1 dict dup /MediaPosition null put setpagedevice
	currentpagedevice /InputAttributes get 0 get setpagedevice
	1 dict dup /InputAttributes 1 dict dup /Priority [0] put put setpagedevice
	1 dict dup /Policies 1 dict dup /PageSize 7 put put setpagedevice

## manual
ps_manual = %% Select manual input tray
	1 dict dup /ManualFeed true  put setpagedevice
	1 dict dup /MediaPosition null put setpagedevice
	1 dict dup /Policies 1 dict dup /PageSize 2 put put setpagedevice

# PRINTER %s - Digital Laser LN15, LN17ps, Compaq Laser LN 16
[ ln15 ln16 ln17ps ]

pjl@
file_output_match = [
   *text*   filter  \%s{a2ps_converter}
   *pdf*    filter  \%s{pdf2ps_converter}
                    ]

ps_duplex=<</Duplex true>> setpagedevice
ps_lduplex=[ duplex ]
ps_sduplex=<</Duplex true /Tumble true>> setpagedevice
ps_duplexshort=[ sduplex ]
ps_simplex=<</Duplex false /Tumble false>> setpagedevice

ps_tumble=<</Tumble true>> setpagedevice
ps_shortedge=[ tumble ]

#!End of [ ln15 ln16 ln17ps ]


# PRINTER %s - HP Business Inkjet 2250
[ hpij2250 ]

file_output_match = [
   *text*   filter  \%s{a2ps_converter}
   *pdf*    filter  \%s{pdf2ps_converter}
                    ]

ps_inupper=<</ManualFeed false /MediaPosition 1>> setpagedevice
ps_intray1=[ inupper ]
ps_inlower=<</ManualFeed false /MediaPosition 4>> setpagedevice
ps_intray2=[ inlower ]

#!End of [ hpij2250 ]



#####
#####  GhostScript Rasterization Printer Entries
#####

# PRINTER gs_bj10 - Canon BubbleJet BJ10e 
# PRINTER gs_bj10 - Canon BubbleJet BJ20 
[ gs_bj10 ]
tc=ghostscript
gs_device=bj10
gs_options=

# PRINTER gs_bj200 - Canon BubbleJet BJ200 
# PRINTER gs_bj200 - Canon BubbleJet BubbleJet BJC-210 B/W only 
# PRINTER gs_bj200 - Canon BubbleJet BubbleJet BJC-240 B/W only 
# PRINTER gs_bj200 - Canon BubbleJet BubbleJet BJC-250 B/W only 
# PRINTER gs_bj200 - Canon BubbleJet BubbleJet BJC-70 B/W only 
[ gs_bj200 ]
tc=ghostscript
gs_device=bj200
gs_options=

# PRINTER gs_bjc600 - Canon BubbleJet BubbleJet BJC-600 
# PRINTER gs_bjc600 - Canon BubbleJet BubbleJet BJC-610
# PRINTER gs_bjc600 - Canon BubbleJet BubbleJet BJC-50
# PRINTER gs_bjc600 - Canon BubbleJet BubbleJet BJC-70 
# PRINTER gs_bjc600 - Canon BubbleJet BubbleJet BJC-80 
# PRINTER gs_bjc600 - Canon BubbleJet BubbleJet BJC-210 Color only
# PRINTER gs_bjc600 - Canon BubbleJet BubbleJet BJC-240 Color only
# PRINTER gs_bjc600 - Canon BubbleJet BubbleJet BJC-250 
# PRINTER gs_bjc600 - Canon BubbleJet BubbleJet BJC-1000
# PRINTER gs_bjc600 - Canon BubbleJet BubbleJet BJC-2000
# PRINTER gs_bjc600 - Canon BubbleJet BubbleJet BJC-4000 
# PRINTER gs_bjc600 - Canon BubbleJet BubbleJet BJC-4100 B/W only
# PRINTER gs_bjc600 - Canon BubbleJet BubbleJet BJC-4200
# PRINTER gs_bjc600 - Canon BubbleJet BubbleJet BJC-4300
# PRINTER gs_bjc600 - Canon BubbleJet BubbleJet BJC-4550 
# PRINTER gs_bjc600 - Canon BubbleJet BubbleJet BJC-6000
# PRINTER gs_bjc600 - Canon MultiPASS C2500 color printer/fax/copier 
[ gs_bjc600 ]
tc=ghostscript
gs_device=bjc600
gs_options=

# PRINTER gs_bjc800 - Canon BubbleJet BubbleJet BJC-800 
# PRINTER gs_bjc800 - Canon BubbleJet BubbleJet BJC-7000 Color. 
# PRINTER gs_bjc800 - Canon BubbleJet BubbleJet BJC-4300 Color
# PRINTER gs_bjc800 - Canon BubbleJet BubbleJet BJC-4650 
[ gs_bjc800 ]
tc=ghostscript
gs_device=bjc800
gs_options=

# PRINTER gs_deskjet - HP DeskJet 
# PRINTER gs_deskjet - HP DeskJet Plus 
[ gs_deskjet ]
tc=pcl_gs
gs_device=deskjet
gs_options=

# PRINTER gs_djet500 - HP DeskJet 500 B/W
# PRINTER gs_djet500 - HP DeskJet Portable B/W
# PRINTER gs_djet500 - HP OfficeJet 590 B/W
[ gs_djet500 ]
tc=pcl_gs
gs_device=djet500
gs_options=

# PRINTER gs_cdj500 - HP DeskJet 400
# PRINTER gs_cdj500 - HP DeskJet 500C 
# PRINTER gs_cdj500 - HP DeskJet 540C 
# PRINTER gs_cdj500 - HP DeskJet 690C
# PRINTER gs_cdj500 - HP DeskJet 693C
[ gs_cdj500 ]
tc=pcl_gs
gs_device=cdj500
gs_options=

# PRINTER gs_cdj550 - HP DeskJet 550C 
# PRINTER gs_cdj550 - HP DeskJet 560C 
# PRINTER gs_cdj550 - HP DeskJet 600
# PRINTER gs_cdj550 - HP DeskJet 660C 
# PRINTER gs_cdj550 - HP DeskJet 660C 
# PRINTER gs_cdj550 - HP DeskJet 682C
# PRINTER gs_cdj550 - HP DeskJet 683C
# PRINTER gs_cdj550 - HP DeskJet 693C 
# PRINTER gs_cdj550 - HP DeskJet 694C 
# PRINTER gs_cdj550 - HP DeskJet 690C 
# PRINTER gs_cdj550 - HP DeskJet 692C 
# PRINTER gs_cdj550 - HP DeskJet 693C 
# PRINTER gs_cdj550 - HP DeskJet 694C 
# PRINTER gs_cdj550 - HP DeskJet 695C 
# PRINTER gs_cdj550 - HP DeskJet 850 
# PRINTER gs_cdj550 - HP DeskJet 870Cse 
# PRINTER gs_cdj550 - HP DeskJet 895Cxi
# PRINTER gs_cdj550 - HP DeskJet 970 
# PRINTER gs_cdj550 - HP OfficeJet 590 
# PRINTER gs_cdj550 - Olivetti jp450 
# PRINTER gs_cdj550 - Xerox XJ6C 
[ gs_cdj550 ]
tc=pcl_gs
gs_device=cdj550
gs_options=

# PRINTER gs_cdj850 - HP DeskJet 850 
# PRINTER gs_cdj850 - HP DeskJet 855 
# PRINTER gs_cdj850 - HP DeskJet 870Cse 
# PRINTER gs_cdj850 - HP DeskJet 870Cxi 
# PRINTER gs_cdj850 - HP DeskJet 890C 
# PRINTER gs_cdj850 - HP DeskJet 670C 
# PRINTER gs_cdj850 - HP DeskJet 680 
[ gs_cdj850 ]
tc=pcl_gs
gs_device=cdj850
gs_options=

# PRINTER gs_cdeskjet - HP DeskJet 500C
# PRINTER gs_cdeskjet - GhostScript with -sDEVICE=cdj500 -dBitsPerPixel=3 
[ gs_cdeskjet ]
tc=pcl_gs
gs_device=cdeskjet
gs_options=

# PRINTER gs_cdjcolor - GhostScript with -sDEVICE=cdj500 -dBitsPerPixel=24 
[ gs_cdjcolor ]
tc=pcl_gs
gs_device=cdjcolor
gs_options=

# PRINTER gs_cdjmono - HP DeskJet 500C 
# PRINTER gs_cdjmono - HP DeskJet 510 
# PRINTER gs_cdjmono - HP DeskJet 520 
# PRINTER gs_cdjmono - HP DeskJet 540C 
# PRINTER gs_cdjmono - HP DeskJet 693C 
# PRINTER gs_cdjmono - GhostScript with -sDEVICE=cdj500 -dBitsPerPixel=1 
[ gs_cdjmono ]
tc=pcl_gs
gs_device=cdjmono
gs_options=

# PRINTER gs_epsonc - Fujitsu DL-1100 
# PRINTER gs_epsonc - Fujitsu DL-2400 
[ gs_epsonc ]
tc=pcl_gs
gs_device=epsonc
gs_options=

# PRINTER gs_hl7x0 - Brother HL-720 
# PRINTER gs_hl7x0 - Brother HL-730 
# PRINTER gs_hl7x0 - Do not use hl7x0 with PCL compliant Brother HL-760. Use ljet4. 
[ gs_hl7x0 ]
tc=pcl_gs
gs_device=hl7x0
gs_options=

# PRINTER gs_laserjet - Bull Compuprint Pagemaster 415 
[ gs_laserjet ]
tc=pcl_gs
gs_device=laserjet
gs_options=

# PRINTER gs_lips3 - Canon LBP4+
[ gs_lips3 ]
tc=ghostscript
gs_device=lips3
gs_options=

# PRINTER gs_lj4dith - HP DeskJet 600 
[ gs_lj4dith ]
tc=pcl_gs
gs_device=lj4dith
gs_options=

# PRINTER gs_ljet2 - HP LaserJet II 
# PRINTER gs_ljet2 - Xerox 4030 
[ gs_ljet2 ]
tc=pcl_gs
gs_device=ljet2p
gs_options=

# PRINTER gs_ljet3 - Tandy LP800 With LaserJet III emulation. 
[ gs_ljet3 ]
tc=pcl_gs
gs_device=ljet3
gs_options=

# PRINTER gs_ljet4 - Brother HL-660 
# PRINTER gs_ljet4 - Brother HL-760 600dpi 
# PRINTER gs_ljet4 - Epson EPL5700 300dpi OK
# PRINTER gs_ljet4 - HP DeskJet 600 margins wrong 
# PRINTER gs_ljet4 - HP DeskJet 870Cse 
# PRINTER gs_ljet4 - HP LaserJet 5 300dpi or 600dpi 
# PRINTER gs_ljet4 - HP LaserJet 5L 300dpi or 600dpi
# PRINTER gs_ljet4 - HP LaserJet 6L 600dpi
# PRINTER gs_ljet4 - HP LaserJet 1100 600dpi OK. 
# PRINTER gs_ljet4 - IBM Network Printer 17 
# PRINTER gs_ljet4 - IBM/Lexmark 4029 Margins wrong. 
# PRINTER gs_ljet4 - Lexmark Optra E+ 
# PRINTER gs_ljet4 - Lexmark Optra SC 1275 B/W only. 
# PRINTER gs_ljet4 - Oki OL410ex LED printer 300dpi or 600dpi 

[ gs_ljet4 ]
# tc=pcl_gs
gs_device=ljet4
gs_options=

# PRINTER gs_ljetplus - HP LaserJet Plus 
# PRINTER gs_ljetplus - Canon Laser LBP-600 
# PRINTER gs_ljetplus - NEC SuperScript 860 
[ gs_ljetplus ]
tc=pcl_gs
gs_device=ljetplus
gs_options=

# PRINTER gs_pjxl300 - HP PaintJet XL300 
# PRINTER gs_pjxl300 - HP DeskJet 600
# PRINTER gs_pjxl300 - HP DeskJet 1200C 
# PRINTER gs_pjxl300 - HP DeskJet 1600C
[ gs_pjxl300 ]
tc=pcl_gs
gs_device=pjxl300
gs_options=

# PRINTER gs_r4081 - Ricoh 4081 laser printer 
# PRINTER gs_r4081 - Ricoh 6000 laser printer 
[ gs_r4081 ]
tc=ghostscript
gs_device=r4081
gs_options=

#
#            gs_uniprint driver
#
# Does the following for GhostScript:
#      gs @MODEL.upp -sOutputFile=- ....
#
# Uses:
# gs_converter=  \%s{gs_unidriver} 
# gs_unidriver= /dev/d/usr/djgpp/bin/gs -dSAFER -dPARANOIDSAFER -dBATCH -dNOPAUSE -q '-sOutputFile=/dev/fd3' 3>&1 1>&2
#        @\%s{gs_device}.upp \%s{gs_options} \%s{inputfile}
#
#  set gs_device to MODEL and you will get the desired operation
#
#  The user can interface to this by using the ifhp options:
#
#  lp:
#    :ifhp=model=gs_uniprint,gs_device=bjc610a0
#
#  Canon BubbleJet BubbleJet BJC 610 (color, rendered)
#    bjc610a0.upp 360x360dpi plain paper, high speed
#    bjc610a1.upp 360x360dpi plain paper
#    bjc610a2.upp 360x360dpi coated paper
#    bjc610a3.upp 360x360dpi transparency film
#    bjc610a4.upp 360x360dpi back print film
#    bjc610a5.upp 360x360dpi fabric sheet
#    bjc610a6.upp 360x360dpi glossy paper
#    bjc610a7.upp 360x360dpi high gloss film
#    bjc610a8.upp 360x360dpi high resolution paper
#    bjc610b1.upp 720x720dpi plain paper
#    bjc610b2.upp 720x720dpi coated paper
#    bjc610b3.upp 720x720dpi transparency film
#    bjc610b4.upp 720x720dpi back print film
#    bjc610b6.upp 720x720dpi glossy paper
#    bjc610b7.upp 720x720dpi high-gloss paper
#    bjc610b8.upp 720x720dpi high resolution paper
#  HP DeskJet 550C
#    cdj550.upp 300x300dpi 32-bit CMYK
#  NEC P2X
#    necp2x.upp 360x360dpi 8-bit (Floyd-Steinberg)
#  Epson Stylus Color (Any)
#    stcany.upp 360x360dpi 4-bit, PostScript halftoning
#  Epson Stylus (Original) and Stylus Pro Color
#    stc.upp 360x360dpi 32-bit CMYK, 15-pin 
#    stc_l.upp 360x360dpi 4-bit, PostScript halftoning, weaved noWeave
#    stc_h.upp 720x720dpi 32-bit CMYK, 15-pin Weave
#    stc2.upp 360x360dpi 32-bit CMYK, 20-pin, Epson Stylus Color II(s)
#    stc2_h.upp 720x720dpi 32-bit CMYK, 20-pin, Epson Stylus Color II 
#    stc2s_h.upp 720x720dpi 32-bit CMYK, 20-pin, Epson Stylus Color IIs
#  Epson Stylus Color 500 (good transfer curves for plain paper)
#    stc500p.upp 360x360dpi 32-bit CMYK, noWeave, plain paper
#    stc500ph.upp 720x720dpi 32-bit CMYK, noWeave, plain paper
#  Epson Stylus Color 600, 32/90-inch weaving
#    stc600pl.upp 360x360dpi 32-bit CMYK, 32-pin, plain paper
#    stc600p.upp 720x720dpi 32-bit CMYK, 32-pin, plain paper
#    stc600ih.upp 1440x720dpi 32-bit CMYK, 30-pin, inkjet paper
#  Epson Stylus Color 800, 64/180-inch weaving
#    stc800pl.upp 360x360dpi 32-bit CMYK, 64-pin, plain paper
#    stc800p.upp 720x720dpi 32-bit CMYK, 64-pin, plain paper   
#    stc800ih.upp 1440x720dpi 32-bit CMYK, 62-pin, inkjet paper
#    stc1520h.upp 1440x720dpi 32-bit CMYK, 62-pin, inkjet paper
#      (This is erroneously described in the GhostScript
#       documentation as the stc1520.upp)

[ gs_uniprint ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
# example: gs_device=
gs_device=
gs_options=

# PRINTER bjc610a0.upp - Canon BubbleJet BJC 610 (color, rendered) 360x360dpi plain paper, high speed
[ bjc610a0.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=bjc610a0.upp

# PRINTER bjc610a1.upp - Canon BubbleJet BJC 610 (color, rendered) 360x360dpi plain paper
[ bjc610a1.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=bjc610a1.upp

# PRINTER bjc610a2.upp - Canon BubbleJet BJC 610 (color, rendered) 360x360dpi coated paper
[ bjc610a2.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=bjc610a2.upp

# PRINTER bjc610a3.upp - Canon BubbleJet BJC 610 (color, rendered) 360x360dpi transparency film
[ bjc610a3.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=bjc610a3.upp

# PRINTER bjc610a4.upp - Canon BubbleJet BJC 610 (color, rendered) 360x360dpi back print film
[ bjc610a4.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=bjc610a4.upp

# PRINTER bjc610a5.upp - Canon BubbleJet BJC 610 (color, rendered) 360x360dpi fabric sheet
[ bjc610a5.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=bjc610a5.upp

# PRINTER bjc610a6.upp - Canon BubbleJet BJC 610 (color, rendered) 360x360dpi glossy paper
[ bjc610a6.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=bjc610a6.upp

# PRINTER bjc610a7.upp - Canon BubbleJet BJC 610 (color, rendered) 360x360dpi high gloss film
[ bjc610a7.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=bjc610a7.upp

# PRINTER bjc610a8.upp - Canon BubbleJet BJC 610 (color, rendered) 360x360dpi high resolution paper
[ bjc610a8.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=bjc610a8.upp

# PRINTER bjc610b1.upp - Canon BubbleJet BJC 610 (color, rendered) 720x720dpi plain paper
[ bjc610b1.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=bjc610b1.upp

# PRINTER bjc610b2.upp - Canon BubbleJet BJC 610 (color, rendered) 720x720dpi coated paper
[ bjc610b2.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=bjc610b2.upp

# PRINTER bjc610b3.upp - Canon BubbleJet BJC 610 (color, rendered) 720x720dpi transparency film
[ bjc610b3.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=bjc610b3.upp

# PRINTER bjc610b4.upp - Canon BubbleJet BJC 610 (color, rendered) 720x720dpi back print film
[ bjc610b4.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=bjc610b4.upp

# PRINTER bjc610b6.upp - Canon BubbleJet BJC 610 (color, rendered) 720x720dpi glossy paper
[ bjc610b6.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=bjc610b6.upp

# PRINTER bjc610b7.upp - Canon BubbleJet BJC 610 (color, rendered) 720x720dpi high-gloss paper
[ bjc610b7.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=bjc610b7.upp

# PRINTER bjc610b8.upp - Canon BubbleJet BJC 610 (color, rendered) 720x720dpi high resolution paper
[ bjc610b8.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=bjc610b8.upp

# PRINTER cdj550.upp - HP DeskJet 550C 300x300dpi 32-bit CMYK
[ cdj550.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=cdj550.upp

# PRINTER necp2x.upp - NEC P2X 360x360dpi 8-bit (Floyd-Steinberg)
[ necp2x.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=necp2x.upp

# PRINTER stcany.upp - Epson Stylus Color (Any) 360x360dpi 4-bit, PostScript halftoning
[ stcany.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=stcany.upp

# PRINTER stc.upp - Epson Stylus (Original) and Stylus Pro Color 360x360dpi 32-bit CMYK, 15-pin 
[ stc.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=stc.upp

# PRINTER stc_l.upp - Epson Stylus (Original) and Stylus Pro Color 360x360dpi 4-bit, PostScript halftoning, weaved noWeave
[ stc_l.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=stc_l.upp

# PRINTER stc_h.upp - Epson Stylus (Original) and Stylus Pro Color 720x720dpi 32-bit CMYK, 15-pin Weave
[ stc_h.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=stc_h.upp

# PRINTER stc2.upp - Epson Stylus (Original) and Stylus Pro Color 360x360dpi 32-bit CMYK, 20-pin, Epson Stylus Color II(s)
[ stc2.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=stc2.upp

# PRINTER stc2_h.upp - Epson Stylus (Original) and Stylus Pro Color 720x720dpi 32-bit CMYK, 20-pin, Epson Stylus Color II 
[ stc2_h.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=stc2_h.upp

# PRINTER stc2s_h.upp - Epson Stylus (Original) and Stylus Pro Color 720x720dpi 32-bit CMYK, 20-pin, Epson Stylus Color IIs
[ stc2s_h.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=stc2s_h.upp

# PRINTER stc500p.upp - Epson Stylus Color 500 360x360dpi 32-bit CMYK, noWeave, plain paper
[ stc500p.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=stc500p.upp

# PRINTER stc500ph.upp - Epson Stylus Color 500 720x720dpi 32-bit CMYK, noWeave, plain paper
[ stc500ph.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=stc500ph.upp

# PRINTER stc600pl.upp - Epson Stylus Color 600, 360x360dpi, 32/90-inch weaving 32-bit CMYK, 32-pin, plain paper
[ stc600pl.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=stc600pl.upp

# PRINTER stc600p.upp - Epson Stylus Color 600, 720x720dpi, 32/90-inch weaving 32-bit CMYK, 32-pin, plain paper
[ stc600p.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=stc600p.upp

# PRINTER stc600ih.upp - Epson Stylus Color 600, 1440x720dpi, 32/90-inch weaving 32-bit CMYK, 30-pin, inkjet paper
[ stc600ih.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=stc600ih.upp

# PRINTER stc800pl.upp - Epson Stylus Color 800, 64/180-inch weaving 360x360dpi 32-bit CMYK, 64-pin, plain paper
[ stc800pl.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=stc800pl.upp

# PRINTER stc800p.upp - Epson Stylus Color 800, 64/180-inch weaving 720x720dpi 32-bit CMYK, 64-pin, plain paper   
[ stc800p.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=stc800p.upp

# PRINTER stc800ih.upp - Epson Stylus Color 800, 64/180-inch weaving 1440x720dpi 32-bit CMYK, 62-pin, inkjet paper
[ stc800ih.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=stc800ih.upp

# PRINTER stc1520h.upp - Epson Stylus Color 800, 64/180-inch weaving 1440x720dpi 32-bit CMYK, 62-pin, inkjet paper
[ stc1520h.upp ]
tc=pcl_gs
gs_converter=  \%s{gs_unidriver} 
gs_device=stc1520h.upp

# PRINTER imagerunner550 - Canon imageRUNNER 550/600 iR600-550-60 
# PRINTER imagerunner600 - Canon imageRUNNER 550/600 iR600-550-60 
[ ir550 ir600 ]
# PostScript for Canon iR600-550-60 PS Print Server Ver 2.0P
# PCFileName: "EFMC6A30.PPD"
# most of the commands at the PJL/PCL level are the same as the
# HP5Si, or so the documentation leads us to believe
#  - Patrick Powell Tue Jun 18 18:54:00 EDT 2002

tc = hp5si
#  *MediaType Plain/Plain Paper: "
ps_plain= /XJXsetmediatype where { pop 0 XJXsetmediatype } if 
#  *MediaType Transparent/Transparency: 
ps_transparency=      /XJXsetmediatype where { pop 1 XJXsetmediatype } if 
#  *MediaType Interleaved/Interleaving (Blank): 
ps_interleaved=      /XJXsetmediatype where { pop 2 XJXsetmediatype } if 
#  *MediaType P_Interleaved/Interleaving (Printed): 
ps_printerleaved=      /XJXsetmediatype where { pop 3 XJXsetmediatype } if 
#  
#  *%EFIFlags *EFStapler Spooler|Command
#  *%EFIGroup *EFStapler Finishing/Finishing
#  *EFStapler None/Off: 
#       /XJXsetstapler where { pop 0 XJXsetstapler } if 
#  *EFStapler PUpperLeft/Corner [Upper Left-P]: 
ps_staple = [ staple_ulp ]
ps_staple_ulp=      /XJXsetstapler where { pop 1 XJXsetstapler } if 
#  *EFStapler LUpperLeft/Corner [Upper Left-L]: 
ps_staple_ull=      /XJXsetstapler where { pop 3 XJXsetstapler } if 
#  *EFStapler PUpperRight/Corner [Upper Right-P]: 
ps_staple_urp=      /XJXsetstapler where { pop 2 XJXsetstapler } if 
#  *EFStapler LUpperRight/Corner [Upper Right-L]: 
ps_staple_url=      /XJXsetstapler where { pop 1 XJXsetstapler } if 
#  *EFStapler PLeft/Double [Left-P]: 
ps_staple_dlp=      /XJXsetstapler where { pop 5 XJXsetstapler } if 
#  *EFStapler LLeft/Double [Left-L]: 
ps_staple_dll=      /XJXsetstapler where { pop 8 XJXsetstapler } if 
#  *EFStapler PUpper/Double [Top-P]: 
ps_staple_dtp=      /XJXsetstapler where { pop 7 XJXsetstapler } if 
#  *EFStapler LUpper/Double [Top-L]: 
ps_staple_dtl=      /XJXsetstapler where { pop 5 XJXsetstapler } if 
#  *EFStapler PRight/Double [Right-P]: 
ps_staple_drp=      /XJXsetstapler where { pop 6 XJXsetstapler } if 
#  *EFStapler LRight/Double [Right-L]: 
ps_staple_drl=      /XJXsetstapler where { pop 7 XJXsetstapler } if 
#  *EFStapler Stitch/Saddle Stitch: 
#       /XJXsetstapler where { pop 9 XJXsetstapler } if 
ps_staple_saddle=      /XJXsetstapler where { pop 7 XJXsetstapler } if 
#  
#  *EFPunch False/Off: 
#       /XJXsetpunch where { pop 0 XJXsetpunch } if 
#  *EFPunch PUpper/Top-Portrait: 
ps_punch= [ punch_lp ]
ps_punch_tp=      /XJXsetpunch where { pop 7 XJXsetpunch } if 
#  *EFPunch LUpper/Top-Landscape: 
ps_punch_tl=      /XJXsetpunch where { pop 5 XJXsetpunch } if 
#  *EFPunch PLeft/Left-Portrait: 
ps_punch_lp=      /XJXsetpunch where { pop 5 XJXsetpunch } if 
#  *EFPunch LLeft/Left-Landscape: 
ps_punch_ll=      /XJXsetpunch where { pop 8 XJXsetpunch } if 
#  *EFPunch PRight/Right-Portrait: 
ps_punch_rp=      /XJXsetpunch where { pop 6 XJXsetpunch } if 
#  *EFPunch LRight/Right-Landscape: 
ps_punch_rl=     /XJXsetpunch where { pop 7 XJXsetpunch } if 

#  
#  *%EFIFlags *EFDuplexing Spooler|Command
#  *EFDuplexing None/Off: 
ps_simplex=
      /XJXSetEngineDuplex where { pop 0 XJXSetEngineDuplex } if
      /XJXSetEngineBinding where { pop 0 XJXSetEngineBinding } if 
#  *EFDuplexing Top/Long Edge Binding: 
ps_duplex=
     /XJXSetEngineDuplex where { pop 1 XJXSetEngineDuplex } if
     /XJXSetEngineBinding where { pop 0 XJXSetEngineBinding } if 
#  *EFDuplexing Bottom/Short Edge Binding: 
ps_duplexshort=
      /XJXSetEngineDuplex where { pop 1 XJXSetEngineDuplex } if
      /XJXSetEngineBinding where { pop 1 XJXSetEngineBinding } if 

#  *%EFIFlags *EFFirstPage Spooler|Command
#  *%EFIGroup *EFFirstPage Job/Job
#  *OpenUI *EFFirstPage/First Page Source :PickOne
#  *OrderDependency: 50 AnySetup *EFFirstPage
#  *DefaultEFFirstPage: None
#  *EFFirstPage ManualFeed/Stack Bypass: 
ps_1manual=      /XJXsetFirstPageTray where { pop 1 neg XJXsetFirstPageTray } if 
#  *EFFirstPage Tray1/Drawer 1: 
ps_1intray1=      /XJXsetFirstPageTray where { pop 1 XJXsetFirstPageTray } if 
#  *EFFirstPage Tray2/Drawer 2: 
ps_1intray2=      /XJXsetFirstPageTray where { pop 2 XJXsetFirstPageTray } if 
#  *EFFirstPage Tray3/Drawer 3: 
ps_1intray3=      /XJXsetFirstPageTray where { pop 3 XJXsetFirstPageTray } if 
#  *EFFirstPage Tray4/Drawer 4: 
ps_1intray4=      /XJXsetFirstPageTray where { pop 4 XJXsetFirstPageTray } if 
#  *EFFirstPage Tray5/Side Paper Deck: 
ps_1intray5=      /XJXsetFirstPageTray where { pop 5 XJXsetFirstPageTray } if 
#  *CloseUI: *EFFirstPage
#  
#  *OpenUI *InputSlot/Paper Source : PickOne
#  *InputSlot AutoSelect/Auto: 
ps_autoselect=     /XJXsettraysel where { pop 0 XJXsettraysel } if 
#  *InputSlot ManualFeed/Stack Bypass: 
ps_manual=     /XJXsettraysel where { pop 1 neg XJXsettraysel } if 
#  *InputSlot Tray1/Drawer 1: 
ps_intray1=     /XJXsettraysel where { pop 1 XJXsettraysel } if 
#  *InputSlot Tray2/Drawer 2: 
ps_intray2=     /XJXsettraysel where { pop 2 XJXsettraysel } if 
#  *InputSlot Tray3/Drawer 3: 
ps_intray3=     /XJXsettraysel where { pop 3 XJXsettraysel } if 
#  *InputSlot Tray4/Drawer 4: 
ps_intray4=     /XJXsettraysel where { pop 4 XJXsettraysel } if 
#  *InputSlot Tray5/Side Paper Deck: 
ps_intray5=     /XJXsettraysel where { pop 5 XJXsettraysel } if 
#  *CloseUI: *InputSlot

#  *DefaultPageSize: Letter
#  *PageSize Tabloid/11x17: 
ps_ledger=      /XJXsetpagesize where { pop (Tabloid) XJXsetpagesize } if 
#  *PageSize Legal/Legal: 
ps_legal=      /XJXsetpagesize where { pop (Legal) XJXsetpagesize } if 
#  *PageSize Letter/Letter: 
ps_letter=      /XJXsetpagesize where { pop (Letter) XJXsetpagesize } if 
#  *PageSize Statement/Statement: 
ps_statement=      /XJXsetpagesize where { pop (Statement) XJXsetpagesize } if 
#  *PageSize A3/A3: 
ps_a3=      /XJXsetpagesize where { pop (A3) XJXsetpagesize } if 
#  *PageSize B4/B4: 
ps_b4=      /XJXsetpagesize where { pop (B4) XJXsetpagesize } if 
#  *PageSize A4/A4: 
ps_a4=      /XJXsetpagesize where { pop (A4) XJXsetpagesize } if 
#  *PageSize B5/B5: 
ps_b5=      /XJXsetpagesize where { pop (B5) XJXsetpagesize } if 
#  *PageSize A5/A5: 
ps_a5=      /XJXsetpagesize where { pop (A5) XJXsetpagesize } if 
#  *PageSize Executive/Executive: 
ps_executive=      /XJXsetpagesize where { pop (Executive) XJXsetpagesize } if 

ps_user_opts += [
 plain transparency interleaved printerleaved staple 
 staple_ulp staple_ull staple_urp staple_url staple_dlp staple_dll
 staple_dtp staple_dtl staple_drp staple_drl staple_saddle
 punch punch_tp punch_tl punch_lp punch_ll punch_rp punch_rl
 simplex duplex duplexshort 1manual 1intray1 1intray2
 1intray3 1intray4 1intray5 autoselect manual intray1
 intray2 intray3 intray4 intray5 ledger legal
 letter statement a3 b4 a4 b5 a5 executive
 ]

# really really stripped down PJL support

pjl_only=[
    COMMENT ECHO ENTER EOJ
    INFO INITIALIZE INQUIRE JOB
    RESET SET
  ]

ps
pcl
pjl

# no console, or at least not supported the same
# way as HP and similar printers
pjl_console@
appsocket
pagecount@
ps_ctrl_t@
ps_eoj_at_start@

##### This is the end of the standard ifhp.conf file.
##### Add your local files after this
##### If you want to override some entries, simply change the names to
##### something different, i.e. hp4 hp4.old
##### Here is a script to do this and then append your local file to the
##### end of the ifhp.conf file:
#####
##### #!/bin/sh
##### for i in $* ; do
#####   perl -spi.bak -e 's/ $i / $i.orig /g' ifhp.conf
##### done
##### 
##### sed -n -e '1,/XXX END XXX/p' ifhp.conf >ifhp.conf.new
##### sed '1,/XXX END XXX/d' ifhp.old >> ifhp.conf.new
#####
##### You can probably improve on this.
#####
#### XXX END XXX #####
