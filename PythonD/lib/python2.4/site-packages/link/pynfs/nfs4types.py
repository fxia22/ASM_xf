# Generated by rpcgen.py at Tue Jan 14 21:23:48 2003

from nfs4constants import *
from nfs4packer import *
import rpc

def init_type_class(klass, ncl):
    # Initilize type class
    klass.ncl = ncl
    klass.packer = ncl.packer
    klass.unpacker = ncl.unpacker

def assert_not_none(klass, *args):
    for arg in args:
	if arg == None:
	    raise TypeError(repr(klass) + " has uninitialized data")

def pack_objarray(ncl, list):
    # FIXME: Support for length assertion. 
    ncl.packer.pack_uint(len(list))
    for item in list:
	item.pack()

def unpack_objarray(ncl, klass):
    n = ncl.unpacker.unpack_uint()
    list = []
    for i in range(n):
	obj = klass(ncl)
	obj.unpack()
	list.append(obj)
    return list


class BadDiscriminant(rpc.RPCException):
    def __init__(self, value, klass):
        self.value = value
        self.klass = klass

    def __str__(self):
        return "Bad Discriminant %s in %s" % (self.value, self.klass)

class nfstime4:
    # XDR definition:
    # struct nfstime4 {
    #     int64_t seconds;
    #     uint32_t nseconds;
    # };
    def __init__(self, ncl, seconds=None, nseconds=None):
        init_type_class(self, ncl)
        self.seconds = seconds
        self.nseconds = nseconds

    def __repr__(self):
        s = " seconds=%s nseconds=%s" % (str(self.seconds), str(self.nseconds))
        if len(s) > 70: s = s[:70] + "..."
        return "<nfstime4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.seconds, self.nseconds)
        self.packer.pack_int64_t(self.seconds)
        self.packer.pack_uint32_t(self.nseconds)

    def unpack(self):
        self.seconds = self.unpacker.unpack_int64_t()
        self.nseconds = self.unpacker.unpack_uint32_t()

class settime4:
    # XDR definition:
    # union settime4 switch (time_how4 set_it) {
    #     case SET_TO_CLIENT_TIME4:
    #         nfstime4    time;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, set_it=None, time=None):
        init_type_class(self, ncl)
        self.set_it = set_it
        self.time = time
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " set_it=%s time=%s" % (str(self.set_it), str(self.time))
        if len(s) > 70: s = s[:70] + "..."
        return "<settime4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.set_it)
        self.packer.pack_time_how4(self.set_it)
        if self.set_it == SET_TO_CLIENT_TIME4:
            assert_not_none(self, self.time)
            self.time.pack()
            self.arm = self.time
        else:
            pass
            

    def unpack(self):
        self.set_it = self.unpacker.unpack_time_how4()
        if self.set_it == SET_TO_CLIENT_TIME4:
            self.time = nfstime4(self)
            self.time.unpack()
            self.arm = self.time
        else:
            pass
            

class fsid4:
    # XDR definition:
    # struct fsid4 {
    #     uint64_t major;
    #     uint64_t minor;
    # };
    def __init__(self, ncl, major=None, minor=None):
        init_type_class(self, ncl)
        self.major = major
        self.minor = minor

    def __repr__(self):
        s = " major=%s minor=%s" % (str(self.major), str(self.minor))
        if len(s) > 70: s = s[:70] + "..."
        return "<fsid4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.major, self.minor)
        self.packer.pack_uint64_t(self.major)
        self.packer.pack_uint64_t(self.minor)

    def unpack(self):
        self.major = self.unpacker.unpack_uint64_t()
        self.minor = self.unpacker.unpack_uint64_t()

class fs_location4:
    # XDR definition:
    # struct fs_location4 {
    #     utf8string server<>;
    #     pathname4 rootpath;
    # };
    def __init__(self, ncl, server=None, rootpath=None):
        init_type_class(self, ncl)
        self.server = server
        self.rootpath = rootpath

    def __repr__(self):
        s = " server=%s rootpath=%s" % (str(self.server), str(self.rootpath))
        if len(s) > 70: s = s[:70] + "..."
        return "<fs_location4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.server, self.rootpath)
        self.packer.pack_utf8string(self.server)
        self.packer.pack_pathname4(self.rootpath)

    def unpack(self):
        self.server = self.unpacker.unpack_utf8string()
        self.rootpath = self.unpacker.unpack_pathname4()

class fs_locations4:
    # XDR definition:
    # struct fs_locations4 {
    #     pathname4 fs_root;
    #     fs_location4 locations<>;
    # };
    def __init__(self, ncl, fs_root=None, locations=None):
        init_type_class(self, ncl)
        self.fs_root = fs_root
        self.locations = locations

    def __repr__(self):
        s = " fs_root=%s locations=%s" % (str(self.fs_root), str(self.locations))
        if len(s) > 70: s = s[:70] + "..."
        return "<fs_locations4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.fs_root, self.locations)
        self.packer.pack_pathname4(self.fs_root)
        pack_objarray(self, self.locations)

    def unpack(self):
        self.fs_root = self.unpacker.unpack_pathname4()
        self.locations = unpack_objarray(self, fs_location4)

class nfsace4:
    # XDR definition:
    # struct nfsace4 {
    #     acetype4 type;
    #     aceflag4 flag;
    #     acemask4 access_mask;
    #     utf8string who;
    # };
    def __init__(self, ncl, type=None, flag=None, access_mask=None, who=None):
        init_type_class(self, ncl)
        self.type = type
        self.flag = flag
        self.access_mask = access_mask
        self.who = who

    def __repr__(self):
        s = " type=%s flag=%s access_mask=%s who=%s" % (str(self.type), str(self.flag), str(self.access_mask), str(self.who))
        if len(s) > 70: s = s[:70] + "..."
        return "<nfsace4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.type, self.flag, self.access_mask, self.who)
        self.packer.pack_acetype4(self.type)
        self.packer.pack_aceflag4(self.flag)
        self.packer.pack_acemask4(self.access_mask)
        self.packer.pack_utf8string(self.who)

    def unpack(self):
        self.type = self.unpacker.unpack_acetype4()
        self.flag = self.unpacker.unpack_aceflag4()
        self.access_mask = self.unpacker.unpack_acemask4()
        self.who = self.unpacker.unpack_utf8string()

class specdata4:
    # XDR definition:
    # struct specdata4 {
    #     uint32_t specdata1;
    #     uint32_t specdata2;
    # };
    def __init__(self, ncl, specdata1=None, specdata2=None):
        init_type_class(self, ncl)
        self.specdata1 = specdata1
        self.specdata2 = specdata2

    def __repr__(self):
        s = " specdata1=%s specdata2=%s" % (str(self.specdata1), str(self.specdata2))
        if len(s) > 70: s = s[:70] + "..."
        return "<specdata4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.specdata1, self.specdata2)
        self.packer.pack_uint32_t(self.specdata1)
        self.packer.pack_uint32_t(self.specdata2)

    def unpack(self):
        self.specdata1 = self.unpacker.unpack_uint32_t()
        self.specdata2 = self.unpacker.unpack_uint32_t()

class fattr4:
    # XDR definition:
    # struct fattr4 {
    #     bitmap4 attrmask;
    #     attrlist4 attr_vals;
    # };
    def __init__(self, ncl, attrmask=None, attr_vals=None):
        init_type_class(self, ncl)
        self.attrmask = attrmask
        self.attr_vals = attr_vals

    def __repr__(self):
        s = " attrmask=%s attr_vals=%s" % (str(self.attrmask), str(self.attr_vals))
        if len(s) > 70: s = s[:70] + "..."
        return "<fattr4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.attrmask, self.attr_vals)
        self.packer.pack_bitmap4(self.attrmask)
        self.packer.pack_attrlist4(self.attr_vals)

    def unpack(self):
        self.attrmask = self.unpacker.unpack_bitmap4()
        self.attr_vals = self.unpacker.unpack_attrlist4()

class change_info4:
    # XDR definition:
    # struct change_info4 {
    #     bool atomic;
    #     changeid4 before;
    #     changeid4 after;
    # };
    def __init__(self, ncl, atomic=None, before=None, after=None):
        init_type_class(self, ncl)
        self.atomic = atomic
        self.before = before
        self.after = after

    def __repr__(self):
        s = " atomic=%s before=%s after=%s" % (str(self.atomic), str(self.before), str(self.after))
        if len(s) > 70: s = s[:70] + "..."
        return "<change_info4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.atomic, self.before, self.after)
        self.packer.pack_bool(self.atomic)
        self.packer.pack_changeid4(self.before)
        self.packer.pack_changeid4(self.after)

    def unpack(self):
        self.atomic = self.unpacker.unpack_bool()
        self.before = self.unpacker.unpack_changeid4()
        self.after = self.unpacker.unpack_changeid4()

class clientaddr4:
    # XDR definition:
    # struct clientaddr4 {
    #     string r_netid<>;
    #     string r_addr<>;
    # };
    def __init__(self, ncl, r_netid=None, r_addr=None):
        init_type_class(self, ncl)
        self.r_netid = r_netid
        self.r_addr = r_addr

    def __repr__(self):
        s = " r_netid=%s r_addr=%s" % (str(self.r_netid), str(self.r_addr))
        if len(s) > 70: s = s[:70] + "..."
        return "<clientaddr4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.r_netid, self.r_addr)
        self.packer.pack_string(self.r_netid)
        self.packer.pack_string(self.r_addr)

    def unpack(self):
        self.r_netid = self.unpacker.unpack_string()
        self.r_addr = self.unpacker.unpack_string()

class cb_client4:
    # XDR definition:
    # struct cb_client4 {
    #     uint32_t cb_program;
    #     clientaddr4 cb_location;
    # };
    def __init__(self, ncl, cb_program=None, cb_location=None):
        init_type_class(self, ncl)
        self.cb_program = cb_program
        self.cb_location = cb_location

    def __repr__(self):
        s = " cb_program=%s cb_location=%s" % (str(self.cb_program), str(self.cb_location))
        if len(s) > 70: s = s[:70] + "..."
        return "<cb_client4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.cb_program, self.cb_location)
        self.packer.pack_uint32_t(self.cb_program)
        self.cb_location.pack()

    def unpack(self):
        self.cb_program = self.unpacker.unpack_uint32_t()
        self.cb_location = clientaddr4(self)
        self.cb_location.unpack()

class stateid4:
    # XDR definition:
    # struct stateid4 {
    #     uint32_t seqid;
    #     opaque other[12];
    # };
    def __init__(self, ncl, seqid=None, other=None):
        init_type_class(self, ncl)
        self.seqid = seqid
        self.other = other

    def __repr__(self):
        s = " seqid=%s other=%s" % (str(self.seqid), str(self.other))
        if len(s) > 70: s = s[:70] + "..."
        return "<stateid4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.seqid, self.other)
        self.packer.pack_uint32_t(self.seqid)
        self.packer.pack_fopaque(12, self.other)

    def unpack(self):
        self.seqid = self.unpacker.unpack_uint32_t()
        self.other = self.unpacker.unpack_fopaque(12)

class nfs_client_id4:
    # XDR definition:
    # struct nfs_client_id4 {
    #     verifier4 verifier;
    #     opaque id<>;
    # };
    def __init__(self, ncl, verifier=None, id=None):
        init_type_class(self, ncl)
        self.verifier = verifier
        self.id = id

    def __repr__(self):
        s = " verifier=%s id=%s" % (str(self.verifier), str(self.id))
        if len(s) > 70: s = s[:70] + "..."
        return "<nfs_client_id4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.verifier, self.id)
        self.packer.pack_verifier4(self.verifier)
        self.packer.pack_opaque(self.id)

    def unpack(self):
        self.verifier = self.unpacker.unpack_verifier4()
        self.id = self.unpacker.unpack_opaque()

class open_owner4:
    # XDR definition:
    # struct open_owner4 {
    #     clientid4 clientid;
    #     opaque owner<>;
    # };
    def __init__(self, ncl, clientid=None, owner=None):
        init_type_class(self, ncl)
        self.clientid = clientid
        self.owner = owner

    def __repr__(self):
        s = " clientid=%s owner=%s" % (str(self.clientid), str(self.owner))
        if len(s) > 70: s = s[:70] + "..."
        return "<open_owner4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.clientid, self.owner)
        self.packer.pack_clientid4(self.clientid)
        self.packer.pack_opaque(self.owner)

    def unpack(self):
        self.clientid = self.unpacker.unpack_clientid4()
        self.owner = self.unpacker.unpack_opaque()

class lock_owner4:
    # XDR definition:
    # struct lock_owner4 {
    #     clientid4 clientid;
    #     opaque owner<>;
    # };
    def __init__(self, ncl, clientid=None, owner=None):
        init_type_class(self, ncl)
        self.clientid = clientid
        self.owner = owner

    def __repr__(self):
        s = " clientid=%s owner=%s" % (str(self.clientid), str(self.owner))
        if len(s) > 70: s = s[:70] + "..."
        return "<lock_owner4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.clientid, self.owner)
        self.packer.pack_clientid4(self.clientid)
        self.packer.pack_opaque(self.owner)

    def unpack(self):
        self.clientid = self.unpacker.unpack_clientid4()
        self.owner = self.unpacker.unpack_opaque()

class ACCESS4args:
    # XDR definition:
    # struct ACCESS4args {
    #     uint32_t access;
    # };
    def __init__(self, ncl, access=None):
        init_type_class(self, ncl)
        self.access = access

    def __repr__(self):
        s = " access=%s" % (str(self.access))
        if len(s) > 70: s = s[:70] + "..."
        return "<ACCESS4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.access)
        self.packer.pack_uint32_t(self.access)

    def unpack(self):
        self.access = self.unpacker.unpack_uint32_t()

class ACCESS4resok:
    # XDR definition:
    # struct ACCESS4resok {
    #     uint32_t supported;
    #     uint32_t access;
    # };
    def __init__(self, ncl, supported=None, access=None):
        init_type_class(self, ncl)
        self.supported = supported
        self.access = access

    def __repr__(self):
        s = " supported=%s access=%s" % (str(self.supported), str(self.access))
        if len(s) > 70: s = s[:70] + "..."
        return "<ACCESS4resok:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.supported, self.access)
        self.packer.pack_uint32_t(self.supported)
        self.packer.pack_uint32_t(self.access)

    def unpack(self):
        self.supported = self.unpacker.unpack_uint32_t()
        self.access = self.unpacker.unpack_uint32_t()

class ACCESS4res:
    # XDR definition:
    # union ACCESS4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         ACCESS4resok    resok4;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, resok4=None):
        init_type_class(self, ncl)
        self.status = status
        self.resok4 = resok4
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s resok4=%s" % (str(self.status), str(self.resok4))
        if len(s) > 70: s = s[:70] + "..."
        return "<ACCESS4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.resok4)
            self.resok4.pack()
            self.arm = self.resok4
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.resok4 = ACCESS4resok(self)
            self.resok4.unpack()
            self.arm = self.resok4
        else:
            pass
            

class CLOSE4args:
    # XDR definition:
    # struct CLOSE4args {
    #     seqid4 seqid;
    #     stateid4 open_stateid;
    # };
    def __init__(self, ncl, seqid=None, open_stateid=None):
        init_type_class(self, ncl)
        self.seqid = seqid
        self.open_stateid = open_stateid

    def __repr__(self):
        s = " seqid=%s open_stateid=%s" % (str(self.seqid), str(self.open_stateid))
        if len(s) > 70: s = s[:70] + "..."
        return "<CLOSE4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.seqid, self.open_stateid)
        self.packer.pack_seqid4(self.seqid)
        self.open_stateid.pack()

    def unpack(self):
        self.seqid = self.unpacker.unpack_seqid4()
        self.open_stateid = stateid4(self)
        self.open_stateid.unpack()

class CLOSE4res:
    # XDR definition:
    # union CLOSE4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         stateid4    open_stateid;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, open_stateid=None):
        init_type_class(self, ncl)
        self.status = status
        self.open_stateid = open_stateid
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s open_stateid=%s" % (str(self.status), str(self.open_stateid))
        if len(s) > 70: s = s[:70] + "..."
        return "<CLOSE4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.open_stateid)
            self.open_stateid.pack()
            self.arm = self.open_stateid
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.open_stateid = stateid4(self)
            self.open_stateid.unpack()
            self.arm = self.open_stateid
        else:
            pass
            

class COMMIT4args:
    # XDR definition:
    # struct COMMIT4args {
    #     offset4 offset;
    #     count4 count;
    # };
    def __init__(self, ncl, offset=None, count=None):
        init_type_class(self, ncl)
        self.offset = offset
        self.count = count

    def __repr__(self):
        s = " offset=%s count=%s" % (str(self.offset), str(self.count))
        if len(s) > 70: s = s[:70] + "..."
        return "<COMMIT4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.offset, self.count)
        self.packer.pack_offset4(self.offset)
        self.packer.pack_count4(self.count)

    def unpack(self):
        self.offset = self.unpacker.unpack_offset4()
        self.count = self.unpacker.unpack_count4()

class COMMIT4resok:
    # XDR definition:
    # struct COMMIT4resok {
    #     verifier4 writeverf;
    # };
    def __init__(self, ncl, writeverf=None):
        init_type_class(self, ncl)
        self.writeverf = writeverf

    def __repr__(self):
        s = " writeverf=%s" % (str(self.writeverf))
        if len(s) > 70: s = s[:70] + "..."
        return "<COMMIT4resok:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.writeverf)
        self.packer.pack_verifier4(self.writeverf)

    def unpack(self):
        self.writeverf = self.unpacker.unpack_verifier4()

class COMMIT4res:
    # XDR definition:
    # union COMMIT4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         COMMIT4resok    resok4;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, resok4=None):
        init_type_class(self, ncl)
        self.status = status
        self.resok4 = resok4
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s resok4=%s" % (str(self.status), str(self.resok4))
        if len(s) > 70: s = s[:70] + "..."
        return "<COMMIT4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.resok4)
            self.resok4.pack()
            self.arm = self.resok4
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.resok4 = COMMIT4resok(self)
            self.resok4.unpack()
            self.arm = self.resok4
        else:
            pass
            

class createtype4:
    # XDR definition:
    # union createtype4 switch (nfs_ftype4 type) {
    #     case NF4LNK:
    #         linktext4    linkdata;
    #     case NF4BLK:
    #     case NF4CHR:
    #         specdata4    devdata;
    #     case NF4SOCK:
    #     case NF4FIFO:
    #     case NF4DIR:
    #             void;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, type=None, linkdata=None, devdata=None):
        init_type_class(self, ncl)
        self.type = type
        self.linkdata = linkdata
        self.devdata = devdata
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " type=%s linkdata=%s devdata=%s" % (str(self.type), str(self.linkdata), str(self.devdata))
        if len(s) > 70: s = s[:70] + "..."
        return "<createtype4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.type)
        self.packer.pack_nfs_ftype4(self.type)
        if self.type == NF4LNK:
            assert_not_none(self, self.linkdata)
            self.packer.pack_linktext4(self.linkdata)
            self.arm = self.linkdata
        elif self.type == NF4BLK or self.type == NF4CHR:
            assert_not_none(self, self.devdata)
            self.devdata.pack()
            self.arm = self.devdata
        elif self.type == NF4SOCK or self.type == NF4FIFO or self.type == NF4DIR:
            pass
        else:
            pass
            

    def unpack(self):
        self.type = self.unpacker.unpack_nfs_ftype4()
        if self.type == NF4LNK:
            self.linkdata = self.unpacker.unpack_linktext4()
            self.arm = self.linkdata
        elif self.type == NF4BLK or self.type == NF4CHR:
            self.devdata = specdata4(self)
            self.devdata.unpack()
            self.arm = self.devdata
        elif self.type == NF4SOCK or self.type == NF4FIFO or self.type == NF4DIR:
            pass
        else:
            pass
            

class CREATE4args:
    # XDR definition:
    # struct CREATE4args {
    #     createtype4 objtype;
    #     component4 objname;
    #     fattr4 createattrs;
    # };
    def __init__(self, ncl, objtype=None, objname=None, createattrs=None):
        init_type_class(self, ncl)
        self.objtype = objtype
        self.objname = objname
        self.createattrs = createattrs

    def __repr__(self):
        s = " objtype=%s objname=%s createattrs=%s" % (str(self.objtype), str(self.objname), str(self.createattrs))
        if len(s) > 70: s = s[:70] + "..."
        return "<CREATE4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.objtype, self.objname, self.createattrs)
        self.objtype.pack()
        self.packer.pack_component4(self.objname)
        self.createattrs.pack()

    def unpack(self):
        self.objtype = createtype4(self)
        self.objtype.unpack()
        self.objname = self.unpacker.unpack_component4()
        self.createattrs = fattr4(self)
        self.createattrs.unpack()

class CREATE4resok:
    # XDR definition:
    # struct CREATE4resok {
    #     change_info4 cinfo;
    #     bitmap4 attrset;
    # };
    def __init__(self, ncl, cinfo=None, attrset=None):
        init_type_class(self, ncl)
        self.cinfo = cinfo
        self.attrset = attrset

    def __repr__(self):
        s = " cinfo=%s attrset=%s" % (str(self.cinfo), str(self.attrset))
        if len(s) > 70: s = s[:70] + "..."
        return "<CREATE4resok:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.cinfo, self.attrset)
        self.cinfo.pack()
        self.packer.pack_bitmap4(self.attrset)

    def unpack(self):
        self.cinfo = change_info4(self)
        self.cinfo.unpack()
        self.attrset = self.unpacker.unpack_bitmap4()

class CREATE4res:
    # XDR definition:
    # union CREATE4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         CREATE4resok    resok4;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, resok4=None):
        init_type_class(self, ncl)
        self.status = status
        self.resok4 = resok4
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s resok4=%s" % (str(self.status), str(self.resok4))
        if len(s) > 70: s = s[:70] + "..."
        return "<CREATE4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.resok4)
            self.resok4.pack()
            self.arm = self.resok4
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.resok4 = CREATE4resok(self)
            self.resok4.unpack()
            self.arm = self.resok4
        else:
            pass
            

class DELEGPURGE4args:
    # XDR definition:
    # struct DELEGPURGE4args {
    #     clientid4 clientid;
    # };
    def __init__(self, ncl, clientid=None):
        init_type_class(self, ncl)
        self.clientid = clientid

    def __repr__(self):
        s = " clientid=%s" % (str(self.clientid))
        if len(s) > 70: s = s[:70] + "..."
        return "<DELEGPURGE4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.clientid)
        self.packer.pack_clientid4(self.clientid)

    def unpack(self):
        self.clientid = self.unpacker.unpack_clientid4()

class DELEGPURGE4res:
    # XDR definition:
    # struct DELEGPURGE4res {
    #     nfsstat4 status;
    # };
    def __init__(self, ncl, status=None):
        init_type_class(self, ncl)
        self.status = status

    def __repr__(self):
        s = " status=%s" % (str(self.status))
        if len(s) > 70: s = s[:70] + "..."
        return "<DELEGPURGE4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()

class DELEGRETURN4args:
    # XDR definition:
    # struct DELEGRETURN4args {
    #     stateid4 deleg_stateid;
    # };
    def __init__(self, ncl, deleg_stateid=None):
        init_type_class(self, ncl)
        self.deleg_stateid = deleg_stateid

    def __repr__(self):
        s = " deleg_stateid=%s" % (str(self.deleg_stateid))
        if len(s) > 70: s = s[:70] + "..."
        return "<DELEGRETURN4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.deleg_stateid)
        self.deleg_stateid.pack()

    def unpack(self):
        self.deleg_stateid = stateid4(self)
        self.deleg_stateid.unpack()

class DELEGRETURN4res:
    # XDR definition:
    # struct DELEGRETURN4res {
    #     nfsstat4 status;
    # };
    def __init__(self, ncl, status=None):
        init_type_class(self, ncl)
        self.status = status

    def __repr__(self):
        s = " status=%s" % (str(self.status))
        if len(s) > 70: s = s[:70] + "..."
        return "<DELEGRETURN4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()

class GETATTR4args:
    # XDR definition:
    # struct GETATTR4args {
    #     bitmap4 attr_request;
    # };
    def __init__(self, ncl, attr_request=None):
        init_type_class(self, ncl)
        self.attr_request = attr_request

    def __repr__(self):
        s = " attr_request=%s" % (str(self.attr_request))
        if len(s) > 70: s = s[:70] + "..."
        return "<GETATTR4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.attr_request)
        self.packer.pack_bitmap4(self.attr_request)

    def unpack(self):
        self.attr_request = self.unpacker.unpack_bitmap4()

class GETATTR4resok:
    # XDR definition:
    # struct GETATTR4resok {
    #     fattr4 obj_attributes;
    # };
    def __init__(self, ncl, obj_attributes=None):
        init_type_class(self, ncl)
        self.obj_attributes = obj_attributes

    def __repr__(self):
        s = " obj_attributes=%s" % (str(self.obj_attributes))
        if len(s) > 70: s = s[:70] + "..."
        return "<GETATTR4resok:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.obj_attributes)
        self.obj_attributes.pack()

    def unpack(self):
        self.obj_attributes = fattr4(self)
        self.obj_attributes.unpack()

class GETATTR4res:
    # XDR definition:
    # union GETATTR4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         GETATTR4resok    resok4;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, resok4=None):
        init_type_class(self, ncl)
        self.status = status
        self.resok4 = resok4
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s resok4=%s" % (str(self.status), str(self.resok4))
        if len(s) > 70: s = s[:70] + "..."
        return "<GETATTR4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.resok4)
            self.resok4.pack()
            self.arm = self.resok4
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.resok4 = GETATTR4resok(self)
            self.resok4.unpack()
            self.arm = self.resok4
        else:
            pass
            

class GETFH4resok:
    # XDR definition:
    # struct GETFH4resok {
    #     nfs_fh4 object;
    # };
    def __init__(self, ncl, object=None):
        init_type_class(self, ncl)
        self.object = object

    def __repr__(self):
        s = " object=%s" % (str(self.object))
        if len(s) > 70: s = s[:70] + "..."
        return "<GETFH4resok:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.object)
        self.packer.pack_nfs_fh4(self.object)

    def unpack(self):
        self.object = self.unpacker.unpack_nfs_fh4()

class GETFH4res:
    # XDR definition:
    # union GETFH4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         GETFH4resok    resok4;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, resok4=None):
        init_type_class(self, ncl)
        self.status = status
        self.resok4 = resok4
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s resok4=%s" % (str(self.status), str(self.resok4))
        if len(s) > 70: s = s[:70] + "..."
        return "<GETFH4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.resok4)
            self.resok4.pack()
            self.arm = self.resok4
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.resok4 = GETFH4resok(self)
            self.resok4.unpack()
            self.arm = self.resok4
        else:
            pass
            

class LINK4args:
    # XDR definition:
    # struct LINK4args {
    #     component4 newname;
    # };
    def __init__(self, ncl, newname=None):
        init_type_class(self, ncl)
        self.newname = newname

    def __repr__(self):
        s = " newname=%s" % (str(self.newname))
        if len(s) > 70: s = s[:70] + "..."
        return "<LINK4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.newname)
        self.packer.pack_component4(self.newname)

    def unpack(self):
        self.newname = self.unpacker.unpack_component4()

class LINK4resok:
    # XDR definition:
    # struct LINK4resok {
    #     change_info4 cinfo;
    # };
    def __init__(self, ncl, cinfo=None):
        init_type_class(self, ncl)
        self.cinfo = cinfo

    def __repr__(self):
        s = " cinfo=%s" % (str(self.cinfo))
        if len(s) > 70: s = s[:70] + "..."
        return "<LINK4resok:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.cinfo)
        self.cinfo.pack()

    def unpack(self):
        self.cinfo = change_info4(self)
        self.cinfo.unpack()

class LINK4res:
    # XDR definition:
    # union LINK4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         LINK4resok    resok4;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, resok4=None):
        init_type_class(self, ncl)
        self.status = status
        self.resok4 = resok4
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s resok4=%s" % (str(self.status), str(self.resok4))
        if len(s) > 70: s = s[:70] + "..."
        return "<LINK4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.resok4)
            self.resok4.pack()
            self.arm = self.resok4
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.resok4 = LINK4resok(self)
            self.resok4.unpack()
            self.arm = self.resok4
        else:
            pass
            

class open_to_lock_owner4:
    # XDR definition:
    # struct open_to_lock_owner4 {
    #     seqid4 open_seqid;
    #     stateid4 open_stateid;
    #     seqid4 lock_seqid;
    #     lock_owner4 lock_owner;
    # };
    def __init__(self, ncl, open_seqid=None, open_stateid=None, lock_seqid=None, lock_owner=None):
        init_type_class(self, ncl)
        self.open_seqid = open_seqid
        self.open_stateid = open_stateid
        self.lock_seqid = lock_seqid
        self.lock_owner = lock_owner

    def __repr__(self):
        s = " open_seqid=%s open_stateid=%s lock_seqid=%s lock_owner=%s" % (str(self.open_seqid), str(self.open_stateid), str(self.lock_seqid), str(self.lock_owner))
        if len(s) > 70: s = s[:70] + "..."
        return "<open_to_lock_owner4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.open_seqid, self.open_stateid, self.lock_seqid, self.lock_owner)
        self.packer.pack_seqid4(self.open_seqid)
        self.open_stateid.pack()
        self.packer.pack_seqid4(self.lock_seqid)
        self.lock_owner.pack()

    def unpack(self):
        self.open_seqid = self.unpacker.unpack_seqid4()
        self.open_stateid = stateid4(self)
        self.open_stateid.unpack()
        self.lock_seqid = self.unpacker.unpack_seqid4()
        self.lock_owner = lock_owner4(self)
        self.lock_owner.unpack()

class exist_lock_owner4:
    # XDR definition:
    # struct exist_lock_owner4 {
    #     stateid4 lock_stateid;
    #     seqid4 lock_seqid;
    # };
    def __init__(self, ncl, lock_stateid=None, lock_seqid=None):
        init_type_class(self, ncl)
        self.lock_stateid = lock_stateid
        self.lock_seqid = lock_seqid

    def __repr__(self):
        s = " lock_stateid=%s lock_seqid=%s" % (str(self.lock_stateid), str(self.lock_seqid))
        if len(s) > 70: s = s[:70] + "..."
        return "<exist_lock_owner4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.lock_stateid, self.lock_seqid)
        self.lock_stateid.pack()
        self.packer.pack_seqid4(self.lock_seqid)

    def unpack(self):
        self.lock_stateid = stateid4(self)
        self.lock_stateid.unpack()
        self.lock_seqid = self.unpacker.unpack_seqid4()

class locker4:
    # XDR definition:
    # union locker4 switch (bool new_lock_owner) {
    #     case TRUE:
    #         open_to_lock_owner4    open_owner;
    #     case FALSE:
    #         exist_lock_owner4    lock_owner;
    # };
    def __init__(self, ncl, new_lock_owner=None, open_owner=None, lock_owner=None):
        init_type_class(self, ncl)
        self.new_lock_owner = new_lock_owner
        self.open_owner = open_owner
        self.lock_owner = lock_owner
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " new_lock_owner=%s open_owner=%s lock_owner=%s" % (str(self.new_lock_owner), str(self.open_owner), str(self.lock_owner))
        if len(s) > 70: s = s[:70] + "..."
        return "<locker4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.new_lock_owner)
        self.packer.pack_bool(self.new_lock_owner)
        if self.new_lock_owner == TRUE:
            assert_not_none(self, self.open_owner)
            self.open_owner.pack()
            self.arm = self.open_owner
        elif self.new_lock_owner == FALSE:
            assert_not_none(self, self.lock_owner)
            self.lock_owner.pack()
            self.arm = self.lock_owner
        else:
            raise BadDiscriminant(self.new_lock_owner, self)
            

    def unpack(self):
        self.new_lock_owner = self.unpacker.unpack_bool()
        if self.new_lock_owner == TRUE:
            self.open_owner = open_to_lock_owner4(self)
            self.open_owner.unpack()
            self.arm = self.open_owner
        elif self.new_lock_owner == FALSE:
            self.lock_owner = exist_lock_owner4(self)
            self.lock_owner.unpack()
            self.arm = self.lock_owner
        else:
            raise BadDiscriminant(self.new_lock_owner, self)
            

class LOCK4args:
    # XDR definition:
    # struct LOCK4args {
    #     nfs_lock_type4 locktype;
    #     bool reclaim;
    #     offset4 offset;
    #     length4 length;
    #     locker4 locker;
    # };
    def __init__(self, ncl, locktype=None, reclaim=None, offset=None, length=None, locker=None):
        init_type_class(self, ncl)
        self.locktype = locktype
        self.reclaim = reclaim
        self.offset = offset
        self.length = length
        self.locker = locker

    def __repr__(self):
        s = " locktype=%s reclaim=%s offset=%s length=%s locker=%s" % (str(self.locktype), str(self.reclaim), str(self.offset), str(self.length), str(self.locker))
        if len(s) > 70: s = s[:70] + "..."
        return "<LOCK4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.locktype, self.reclaim, self.offset, self.length, self.locker)
        self.packer.pack_nfs_lock_type4(self.locktype)
        self.packer.pack_bool(self.reclaim)
        self.packer.pack_offset4(self.offset)
        self.packer.pack_length4(self.length)
        self.locker.pack()

    def unpack(self):
        self.locktype = self.unpacker.unpack_nfs_lock_type4()
        self.reclaim = self.unpacker.unpack_bool()
        self.offset = self.unpacker.unpack_offset4()
        self.length = self.unpacker.unpack_length4()
        self.locker = locker4(self)
        self.locker.unpack()

class LOCK4denied:
    # XDR definition:
    # struct LOCK4denied {
    #     offset4 offset;
    #     length4 length;
    #     nfs_lock_type4 locktype;
    #     lock_owner4 owner;
    # };
    def __init__(self, ncl, offset=None, length=None, locktype=None, owner=None):
        init_type_class(self, ncl)
        self.offset = offset
        self.length = length
        self.locktype = locktype
        self.owner = owner

    def __repr__(self):
        s = " offset=%s length=%s locktype=%s owner=%s" % (str(self.offset), str(self.length), str(self.locktype), str(self.owner))
        if len(s) > 70: s = s[:70] + "..."
        return "<LOCK4denied:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.offset, self.length, self.locktype, self.owner)
        self.packer.pack_offset4(self.offset)
        self.packer.pack_length4(self.length)
        self.packer.pack_nfs_lock_type4(self.locktype)
        self.owner.pack()

    def unpack(self):
        self.offset = self.unpacker.unpack_offset4()
        self.length = self.unpacker.unpack_length4()
        self.locktype = self.unpacker.unpack_nfs_lock_type4()
        self.owner = lock_owner4(self)
        self.owner.unpack()

class LOCK4resok:
    # XDR definition:
    # struct LOCK4resok {
    #     stateid4 lock_stateid;
    # };
    def __init__(self, ncl, lock_stateid=None):
        init_type_class(self, ncl)
        self.lock_stateid = lock_stateid

    def __repr__(self):
        s = " lock_stateid=%s" % (str(self.lock_stateid))
        if len(s) > 70: s = s[:70] + "..."
        return "<LOCK4resok:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.lock_stateid)
        self.lock_stateid.pack()

    def unpack(self):
        self.lock_stateid = stateid4(self)
        self.lock_stateid.unpack()

class LOCK4res:
    # XDR definition:
    # union LOCK4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         LOCK4resok    resok4;
    #     case NFS4ERR_DENIED:
    #         LOCK4denied    denied;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, resok4=None, denied=None):
        init_type_class(self, ncl)
        self.status = status
        self.resok4 = resok4
        self.denied = denied
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s resok4=%s denied=%s" % (str(self.status), str(self.resok4), str(self.denied))
        if len(s) > 70: s = s[:70] + "..."
        return "<LOCK4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.resok4)
            self.resok4.pack()
            self.arm = self.resok4
        elif self.status == NFS4ERR_DENIED:
            assert_not_none(self, self.denied)
            self.denied.pack()
            self.arm = self.denied
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.resok4 = LOCK4resok(self)
            self.resok4.unpack()
            self.arm = self.resok4
        elif self.status == NFS4ERR_DENIED:
            self.denied = LOCK4denied(self)
            self.denied.unpack()
            self.arm = self.denied
        else:
            pass
            

class LOCKT4args:
    # XDR definition:
    # struct LOCKT4args {
    #     nfs_lock_type4 locktype;
    #     offset4 offset;
    #     length4 length;
    #     lock_owner4 owner;
    # };
    def __init__(self, ncl, locktype=None, offset=None, length=None, owner=None):
        init_type_class(self, ncl)
        self.locktype = locktype
        self.offset = offset
        self.length = length
        self.owner = owner

    def __repr__(self):
        s = " locktype=%s offset=%s length=%s owner=%s" % (str(self.locktype), str(self.offset), str(self.length), str(self.owner))
        if len(s) > 70: s = s[:70] + "..."
        return "<LOCKT4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.locktype, self.offset, self.length, self.owner)
        self.packer.pack_nfs_lock_type4(self.locktype)
        self.packer.pack_offset4(self.offset)
        self.packer.pack_length4(self.length)
        self.owner.pack()

    def unpack(self):
        self.locktype = self.unpacker.unpack_nfs_lock_type4()
        self.offset = self.unpacker.unpack_offset4()
        self.length = self.unpacker.unpack_length4()
        self.owner = lock_owner4(self)
        self.owner.unpack()

class LOCKT4res:
    # XDR definition:
    # union LOCKT4res switch (nfsstat4 status) {
    #     case NFS4ERR_DENIED:
    #         LOCK4denied    denied;
    #     case NFS4_OK:
    #             void;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, denied=None):
        init_type_class(self, ncl)
        self.status = status
        self.denied = denied
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s denied=%s" % (str(self.status), str(self.denied))
        if len(s) > 70: s = s[:70] + "..."
        return "<LOCKT4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4ERR_DENIED:
            assert_not_none(self, self.denied)
            self.denied.pack()
            self.arm = self.denied
        elif self.status == NFS4_OK:
            pass
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4ERR_DENIED:
            self.denied = LOCK4denied(self)
            self.denied.unpack()
            self.arm = self.denied
        elif self.status == NFS4_OK:
            pass
        else:
            pass
            

class LOCKU4args:
    # XDR definition:
    # struct LOCKU4args {
    #     nfs_lock_type4 locktype;
    #     seqid4 seqid;
    #     stateid4 lock_stateid;
    #     offset4 offset;
    #     length4 length;
    # };
    def __init__(self, ncl, locktype=None, seqid=None, lock_stateid=None, offset=None, length=None):
        init_type_class(self, ncl)
        self.locktype = locktype
        self.seqid = seqid
        self.lock_stateid = lock_stateid
        self.offset = offset
        self.length = length

    def __repr__(self):
        s = " locktype=%s seqid=%s lock_stateid=%s offset=%s length=%s" % (str(self.locktype), str(self.seqid), str(self.lock_stateid), str(self.offset), str(self.length))
        if len(s) > 70: s = s[:70] + "..."
        return "<LOCKU4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.locktype, self.seqid, self.lock_stateid, self.offset, self.length)
        self.packer.pack_nfs_lock_type4(self.locktype)
        self.packer.pack_seqid4(self.seqid)
        self.lock_stateid.pack()
        self.packer.pack_offset4(self.offset)
        self.packer.pack_length4(self.length)

    def unpack(self):
        self.locktype = self.unpacker.unpack_nfs_lock_type4()
        self.seqid = self.unpacker.unpack_seqid4()
        self.lock_stateid = stateid4(self)
        self.lock_stateid.unpack()
        self.offset = self.unpacker.unpack_offset4()
        self.length = self.unpacker.unpack_length4()

class LOCKU4res:
    # XDR definition:
    # union LOCKU4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         stateid4    lock_stateid;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, lock_stateid=None):
        init_type_class(self, ncl)
        self.status = status
        self.lock_stateid = lock_stateid
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s lock_stateid=%s" % (str(self.status), str(self.lock_stateid))
        if len(s) > 70: s = s[:70] + "..."
        return "<LOCKU4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.lock_stateid)
            self.lock_stateid.pack()
            self.arm = self.lock_stateid
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.lock_stateid = stateid4(self)
            self.lock_stateid.unpack()
            self.arm = self.lock_stateid
        else:
            pass
            

class LOOKUP4args:
    # XDR definition:
    # struct LOOKUP4args {
    #     component4 objname;
    # };
    def __init__(self, ncl, objname=None):
        init_type_class(self, ncl)
        self.objname = objname

    def __repr__(self):
        s = " objname=%s" % (str(self.objname))
        if len(s) > 70: s = s[:70] + "..."
        return "<LOOKUP4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.objname)
        self.packer.pack_component4(self.objname)

    def unpack(self):
        self.objname = self.unpacker.unpack_component4()

class LOOKUP4res:
    # XDR definition:
    # struct LOOKUP4res {
    #     nfsstat4 status;
    # };
    def __init__(self, ncl, status=None):
        init_type_class(self, ncl)
        self.status = status

    def __repr__(self):
        s = " status=%s" % (str(self.status))
        if len(s) > 70: s = s[:70] + "..."
        return "<LOOKUP4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()

class LOOKUPP4res:
    # XDR definition:
    # struct LOOKUPP4res {
    #     nfsstat4 status;
    # };
    def __init__(self, ncl, status=None):
        init_type_class(self, ncl)
        self.status = status

    def __repr__(self):
        s = " status=%s" % (str(self.status))
        if len(s) > 70: s = s[:70] + "..."
        return "<LOOKUPP4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()

class NVERIFY4args:
    # XDR definition:
    # struct NVERIFY4args {
    #     fattr4 obj_attributes;
    # };
    def __init__(self, ncl, obj_attributes=None):
        init_type_class(self, ncl)
        self.obj_attributes = obj_attributes

    def __repr__(self):
        s = " obj_attributes=%s" % (str(self.obj_attributes))
        if len(s) > 70: s = s[:70] + "..."
        return "<NVERIFY4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.obj_attributes)
        self.obj_attributes.pack()

    def unpack(self):
        self.obj_attributes = fattr4(self)
        self.obj_attributes.unpack()

class NVERIFY4res:
    # XDR definition:
    # struct NVERIFY4res {
    #     nfsstat4 status;
    # };
    def __init__(self, ncl, status=None):
        init_type_class(self, ncl)
        self.status = status

    def __repr__(self):
        s = " status=%s" % (str(self.status))
        if len(s) > 70: s = s[:70] + "..."
        return "<NVERIFY4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()

class createhow4:
    # XDR definition:
    # union createhow4 switch (createmode4 mode) {
    #     case UNCHECKED4:
    #     case GUARDED4:
    #         fattr4    createattrs;
    #     case EXCLUSIVE4:
    #         verifier4    createverf;
    # };
    def __init__(self, ncl, mode=None, createattrs=None, createverf=None):
        init_type_class(self, ncl)
        self.mode = mode
        self.createattrs = createattrs
        self.createverf = createverf
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " mode=%s createattrs=%s createverf=%s" % (str(self.mode), str(self.createattrs), str(self.createverf))
        if len(s) > 70: s = s[:70] + "..."
        return "<createhow4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.mode)
        self.packer.pack_createmode4(self.mode)
        if self.mode == UNCHECKED4 or self.mode == GUARDED4:
            assert_not_none(self, self.createattrs)
            self.createattrs.pack()
            self.arm = self.createattrs
        elif self.mode == EXCLUSIVE4:
            assert_not_none(self, self.createverf)
            self.packer.pack_verifier4(self.createverf)
            self.arm = self.createverf
        else:
            raise BadDiscriminant(self.mode, self)
            

    def unpack(self):
        self.mode = self.unpacker.unpack_createmode4()
        if self.mode == UNCHECKED4 or self.mode == GUARDED4:
            self.createattrs = fattr4(self)
            self.createattrs.unpack()
            self.arm = self.createattrs
        elif self.mode == EXCLUSIVE4:
            self.createverf = self.unpacker.unpack_verifier4()
            self.arm = self.createverf
        else:
            raise BadDiscriminant(self.mode, self)
            

class openflag4:
    # XDR definition:
    # union openflag4 switch (opentype4 opentype) {
    #     case OPEN4_CREATE:
    #         createhow4    how;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, opentype=None, how=None):
        init_type_class(self, ncl)
        self.opentype = opentype
        self.how = how
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " opentype=%s how=%s" % (str(self.opentype), str(self.how))
        if len(s) > 70: s = s[:70] + "..."
        return "<openflag4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.opentype)
        self.packer.pack_opentype4(self.opentype)
        if self.opentype == OPEN4_CREATE:
            assert_not_none(self, self.how)
            self.how.pack()
            self.arm = self.how
        else:
            pass
            

    def unpack(self):
        self.opentype = self.unpacker.unpack_opentype4()
        if self.opentype == OPEN4_CREATE:
            self.how = createhow4(self)
            self.how.unpack()
            self.arm = self.how
        else:
            pass
            

class nfs_modified_limit4:
    # XDR definition:
    # struct nfs_modified_limit4 {
    #     uint32_t num_blocks;
    #     uint32_t bytes_per_block;
    # };
    def __init__(self, ncl, num_blocks=None, bytes_per_block=None):
        init_type_class(self, ncl)
        self.num_blocks = num_blocks
        self.bytes_per_block = bytes_per_block

    def __repr__(self):
        s = " num_blocks=%s bytes_per_block=%s" % (str(self.num_blocks), str(self.bytes_per_block))
        if len(s) > 70: s = s[:70] + "..."
        return "<nfs_modified_limit4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.num_blocks, self.bytes_per_block)
        self.packer.pack_uint32_t(self.num_blocks)
        self.packer.pack_uint32_t(self.bytes_per_block)

    def unpack(self):
        self.num_blocks = self.unpacker.unpack_uint32_t()
        self.bytes_per_block = self.unpacker.unpack_uint32_t()

class nfs_space_limit4:
    # XDR definition:
    # union nfs_space_limit4 switch (limit_by4 limitby) {
    #     case NFS_LIMIT_SIZE:
    #         uint64_t    filesize;
    #     case NFS_LIMIT_BLOCKS:
    #         nfs_modified_limit4    mod_blocks;
    # };
    def __init__(self, ncl, limitby=None, filesize=None, mod_blocks=None):
        init_type_class(self, ncl)
        self.limitby = limitby
        self.filesize = filesize
        self.mod_blocks = mod_blocks
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " limitby=%s filesize=%s mod_blocks=%s" % (str(self.limitby), str(self.filesize), str(self.mod_blocks))
        if len(s) > 70: s = s[:70] + "..."
        return "<nfs_space_limit4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.limitby)
        self.packer.pack_limit_by4(self.limitby)
        if self.limitby == NFS_LIMIT_SIZE:
            assert_not_none(self, self.filesize)
            self.packer.pack_uint64_t(self.filesize)
            self.arm = self.filesize
        elif self.limitby == NFS_LIMIT_BLOCKS:
            assert_not_none(self, self.mod_blocks)
            self.mod_blocks.pack()
            self.arm = self.mod_blocks
        else:
            raise BadDiscriminant(self.limitby, self)
            

    def unpack(self):
        self.limitby = self.unpacker.unpack_limit_by4()
        if self.limitby == NFS_LIMIT_SIZE:
            self.filesize = self.unpacker.unpack_uint64_t()
            self.arm = self.filesize
        elif self.limitby == NFS_LIMIT_BLOCKS:
            self.mod_blocks = nfs_modified_limit4(self)
            self.mod_blocks.unpack()
            self.arm = self.mod_blocks
        else:
            raise BadDiscriminant(self.limitby, self)
            

class open_claim_delegate_cur4:
    # XDR definition:
    # struct open_claim_delegate_cur4 {
    #     stateid4 delegate_stateid;
    #     component4 file;
    # };
    def __init__(self, ncl, delegate_stateid=None, file=None):
        init_type_class(self, ncl)
        self.delegate_stateid = delegate_stateid
        self.file = file

    def __repr__(self):
        s = " delegate_stateid=%s file=%s" % (str(self.delegate_stateid), str(self.file))
        if len(s) > 70: s = s[:70] + "..."
        return "<open_claim_delegate_cur4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.delegate_stateid, self.file)
        self.delegate_stateid.pack()
        self.packer.pack_component4(self.file)

    def unpack(self):
        self.delegate_stateid = stateid4(self)
        self.delegate_stateid.unpack()
        self.file = self.unpacker.unpack_component4()

class open_claim4:
    # XDR definition:
    # union open_claim4 switch (open_claim_type4 claim) {
    #     case CLAIM_NULL:
    #         component4    file;
    #     case CLAIM_PREVIOUS:
    #         open_delegation_type4    delegate_type;
    #     case CLAIM_DELEGATE_CUR:
    #         open_claim_delegate_cur4    delegate_cur_info;
    #     case CLAIM_DELEGATE_PREV:
    #         component4    file_delegate_prev;
    # };
    def __init__(self, ncl, claim=None, file=None, delegate_type=None, delegate_cur_info=None, file_delegate_prev=None):
        init_type_class(self, ncl)
        self.claim = claim
        self.file = file
        self.delegate_type = delegate_type
        self.delegate_cur_info = delegate_cur_info
        self.file_delegate_prev = file_delegate_prev
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " claim=%s file=%s delegate_type=%s delegate_cur_info=%s file_delegate_prev=%s" % (str(self.claim), str(self.file), str(self.delegate_type), str(self.delegate_cur_info), str(self.file_delegate_prev))
        if len(s) > 70: s = s[:70] + "..."
        return "<open_claim4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.claim)
        self.packer.pack_open_claim_type4(self.claim)
        if self.claim == CLAIM_NULL:
            assert_not_none(self, self.file)
            self.packer.pack_component4(self.file)
            self.arm = self.file
        elif self.claim == CLAIM_PREVIOUS:
            assert_not_none(self, self.delegate_type)
            self.packer.pack_open_delegation_type4(self.delegate_type)
            self.arm = self.delegate_type
        elif self.claim == CLAIM_DELEGATE_CUR:
            assert_not_none(self, self.delegate_cur_info)
            self.delegate_cur_info.pack()
            self.arm = self.delegate_cur_info
        elif self.claim == CLAIM_DELEGATE_PREV:
            assert_not_none(self, self.file_delegate_prev)
            self.packer.pack_component4(self.file_delegate_prev)
            self.arm = self.file_delegate_prev
        else:
            raise BadDiscriminant(self.claim, self)
            

    def unpack(self):
        self.claim = self.unpacker.unpack_open_claim_type4()
        if self.claim == CLAIM_NULL:
            self.file = self.unpacker.unpack_component4()
            self.arm = self.file
        elif self.claim == CLAIM_PREVIOUS:
            self.delegate_type = self.unpacker.unpack_open_delegation_type4()
            self.arm = self.delegate_type
        elif self.claim == CLAIM_DELEGATE_CUR:
            self.delegate_cur_info = open_claim_delegate_cur4(self)
            self.delegate_cur_info.unpack()
            self.arm = self.delegate_cur_info
        elif self.claim == CLAIM_DELEGATE_PREV:
            self.file_delegate_prev = self.unpacker.unpack_component4()
            self.arm = self.file_delegate_prev
        else:
            raise BadDiscriminant(self.claim, self)
            

class OPEN4args:
    # XDR definition:
    # struct OPEN4args {
    #     seqid4 seqid;
    #     uint32_t share_access;
    #     uint32_t share_deny;
    #     open_owner4 owner;
    #     openflag4 openhow;
    #     open_claim4 claim;
    # };
    def __init__(self, ncl, seqid=None, share_access=None, share_deny=None, owner=None, openhow=None, claim=None):
        init_type_class(self, ncl)
        self.seqid = seqid
        self.share_access = share_access
        self.share_deny = share_deny
        self.owner = owner
        self.openhow = openhow
        self.claim = claim

    def __repr__(self):
        s = " seqid=%s share_access=%s share_deny=%s owner=%s openhow=%s claim=%s" % (str(self.seqid), str(self.share_access), str(self.share_deny), str(self.owner), str(self.openhow), str(self.claim))
        if len(s) > 70: s = s[:70] + "..."
        return "<OPEN4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.seqid, self.share_access, self.share_deny, self.owner, self.openhow, self.claim)
        self.packer.pack_seqid4(self.seqid)
        self.packer.pack_uint32_t(self.share_access)
        self.packer.pack_uint32_t(self.share_deny)
        self.owner.pack()
        self.openhow.pack()
        self.claim.pack()

    def unpack(self):
        self.seqid = self.unpacker.unpack_seqid4()
        self.share_access = self.unpacker.unpack_uint32_t()
        self.share_deny = self.unpacker.unpack_uint32_t()
        self.owner = open_owner4(self)
        self.owner.unpack()
        self.openhow = openflag4(self)
        self.openhow.unpack()
        self.claim = open_claim4(self)
        self.claim.unpack()

class open_read_delegation4:
    # XDR definition:
    # struct open_read_delegation4 {
    #     stateid4 stateid;
    #     bool recall;
    #     nfsace4 permissions;
    # };
    def __init__(self, ncl, stateid=None, recall=None, permissions=None):
        init_type_class(self, ncl)
        self.stateid = stateid
        self.recall = recall
        self.permissions = permissions

    def __repr__(self):
        s = " stateid=%s recall=%s permissions=%s" % (str(self.stateid), str(self.recall), str(self.permissions))
        if len(s) > 70: s = s[:70] + "..."
        return "<open_read_delegation4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.stateid, self.recall, self.permissions)
        self.stateid.pack()
        self.packer.pack_bool(self.recall)
        self.permissions.pack()

    def unpack(self):
        self.stateid = stateid4(self)
        self.stateid.unpack()
        self.recall = self.unpacker.unpack_bool()
        self.permissions = nfsace4(self)
        self.permissions.unpack()

class open_write_delegation4:
    # XDR definition:
    # struct open_write_delegation4 {
    #     stateid4 stateid;
    #     bool recall;
    #     nfs_space_limit4 space_limit;
    #     nfsace4 permissions;
    # };
    def __init__(self, ncl, stateid=None, recall=None, space_limit=None, permissions=None):
        init_type_class(self, ncl)
        self.stateid = stateid
        self.recall = recall
        self.space_limit = space_limit
        self.permissions = permissions

    def __repr__(self):
        s = " stateid=%s recall=%s space_limit=%s permissions=%s" % (str(self.stateid), str(self.recall), str(self.space_limit), str(self.permissions))
        if len(s) > 70: s = s[:70] + "..."
        return "<open_write_delegation4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.stateid, self.recall, self.space_limit, self.permissions)
        self.stateid.pack()
        self.packer.pack_bool(self.recall)
        self.space_limit.pack()
        self.permissions.pack()

    def unpack(self):
        self.stateid = stateid4(self)
        self.stateid.unpack()
        self.recall = self.unpacker.unpack_bool()
        self.space_limit = nfs_space_limit4(self)
        self.space_limit.unpack()
        self.permissions = nfsace4(self)
        self.permissions.unpack()

class open_delegation4:
    # XDR definition:
    # union open_delegation4 switch (open_delegation_type4 delegation_type) {
    #     case OPEN_DELEGATE_NONE:
    #             void;
    #     case OPEN_DELEGATE_READ:
    #         open_read_delegation4    read;
    #     case OPEN_DELEGATE_WRITE:
    #         open_write_delegation4    write;
    # };
    def __init__(self, ncl, delegation_type=None, read=None, write=None):
        init_type_class(self, ncl)
        self.delegation_type = delegation_type
        self.read = read
        self.write = write
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " delegation_type=%s read=%s write=%s" % (str(self.delegation_type), str(self.read), str(self.write))
        if len(s) > 70: s = s[:70] + "..."
        return "<open_delegation4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.delegation_type)
        self.packer.pack_open_delegation_type4(self.delegation_type)
        if self.delegation_type == OPEN_DELEGATE_NONE:
            pass
        elif self.delegation_type == OPEN_DELEGATE_READ:
            assert_not_none(self, self.read)
            self.read.pack()
            self.arm = self.read
        elif self.delegation_type == OPEN_DELEGATE_WRITE:
            assert_not_none(self, self.write)
            self.write.pack()
            self.arm = self.write
        else:
            raise BadDiscriminant(self.delegation_type, self)
            

    def unpack(self):
        self.delegation_type = self.unpacker.unpack_open_delegation_type4()
        if self.delegation_type == OPEN_DELEGATE_NONE:
            pass
        elif self.delegation_type == OPEN_DELEGATE_READ:
            self.read = open_read_delegation4(self)
            self.read.unpack()
            self.arm = self.read
        elif self.delegation_type == OPEN_DELEGATE_WRITE:
            self.write = open_write_delegation4(self)
            self.write.unpack()
            self.arm = self.write
        else:
            raise BadDiscriminant(self.delegation_type, self)
            

class OPEN4resok:
    # XDR definition:
    # struct OPEN4resok {
    #     stateid4 stateid;
    #     change_info4 cinfo;
    #     uint32_t rflags;
    #     bitmap4 attrset;
    #     open_delegation4 delegation;
    # };
    def __init__(self, ncl, stateid=None, cinfo=None, rflags=None, attrset=None, delegation=None):
        init_type_class(self, ncl)
        self.stateid = stateid
        self.cinfo = cinfo
        self.rflags = rflags
        self.attrset = attrset
        self.delegation = delegation

    def __repr__(self):
        s = " stateid=%s cinfo=%s rflags=%s attrset=%s delegation=%s" % (str(self.stateid), str(self.cinfo), str(self.rflags), str(self.attrset), str(self.delegation))
        if len(s) > 70: s = s[:70] + "..."
        return "<OPEN4resok:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.stateid, self.cinfo, self.rflags, self.attrset, self.delegation)
        self.stateid.pack()
        self.cinfo.pack()
        self.packer.pack_uint32_t(self.rflags)
        self.packer.pack_bitmap4(self.attrset)
        self.delegation.pack()

    def unpack(self):
        self.stateid = stateid4(self)
        self.stateid.unpack()
        self.cinfo = change_info4(self)
        self.cinfo.unpack()
        self.rflags = self.unpacker.unpack_uint32_t()
        self.attrset = self.unpacker.unpack_bitmap4()
        self.delegation = open_delegation4(self)
        self.delegation.unpack()

class OPEN4res:
    # XDR definition:
    # union OPEN4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         OPEN4resok    resok4;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, resok4=None):
        init_type_class(self, ncl)
        self.status = status
        self.resok4 = resok4
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s resok4=%s" % (str(self.status), str(self.resok4))
        if len(s) > 70: s = s[:70] + "..."
        return "<OPEN4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.resok4)
            self.resok4.pack()
            self.arm = self.resok4
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.resok4 = OPEN4resok(self)
            self.resok4.unpack()
            self.arm = self.resok4
        else:
            pass
            

class OPENATTR4args:
    # XDR definition:
    # struct OPENATTR4args {
    #     bool createdir;
    # };
    def __init__(self, ncl, createdir=None):
        init_type_class(self, ncl)
        self.createdir = createdir

    def __repr__(self):
        s = " createdir=%s" % (str(self.createdir))
        if len(s) > 70: s = s[:70] + "..."
        return "<OPENATTR4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.createdir)
        self.packer.pack_bool(self.createdir)

    def unpack(self):
        self.createdir = self.unpacker.unpack_bool()

class OPENATTR4res:
    # XDR definition:
    # struct OPENATTR4res {
    #     nfsstat4 status;
    # };
    def __init__(self, ncl, status=None):
        init_type_class(self, ncl)
        self.status = status

    def __repr__(self):
        s = " status=%s" % (str(self.status))
        if len(s) > 70: s = s[:70] + "..."
        return "<OPENATTR4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()

class OPEN_CONFIRM4args:
    # XDR definition:
    # struct OPEN_CONFIRM4args {
    #     stateid4 open_stateid;
    #     seqid4 seqid;
    # };
    def __init__(self, ncl, open_stateid=None, seqid=None):
        init_type_class(self, ncl)
        self.open_stateid = open_stateid
        self.seqid = seqid

    def __repr__(self):
        s = " open_stateid=%s seqid=%s" % (str(self.open_stateid), str(self.seqid))
        if len(s) > 70: s = s[:70] + "..."
        return "<OPEN_CONFIRM4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.open_stateid, self.seqid)
        self.open_stateid.pack()
        self.packer.pack_seqid4(self.seqid)

    def unpack(self):
        self.open_stateid = stateid4(self)
        self.open_stateid.unpack()
        self.seqid = self.unpacker.unpack_seqid4()

class OPEN_CONFIRM4resok:
    # XDR definition:
    # struct OPEN_CONFIRM4resok {
    #     stateid4 open_stateid;
    # };
    def __init__(self, ncl, open_stateid=None):
        init_type_class(self, ncl)
        self.open_stateid = open_stateid

    def __repr__(self):
        s = " open_stateid=%s" % (str(self.open_stateid))
        if len(s) > 70: s = s[:70] + "..."
        return "<OPEN_CONFIRM4resok:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.open_stateid)
        self.open_stateid.pack()

    def unpack(self):
        self.open_stateid = stateid4(self)
        self.open_stateid.unpack()

class OPEN_CONFIRM4res:
    # XDR definition:
    # union OPEN_CONFIRM4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         OPEN_CONFIRM4resok    resok4;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, resok4=None):
        init_type_class(self, ncl)
        self.status = status
        self.resok4 = resok4
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s resok4=%s" % (str(self.status), str(self.resok4))
        if len(s) > 70: s = s[:70] + "..."
        return "<OPEN_CONFIRM4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.resok4)
            self.resok4.pack()
            self.arm = self.resok4
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.resok4 = OPEN_CONFIRM4resok(self)
            self.resok4.unpack()
            self.arm = self.resok4
        else:
            pass
            

class OPEN_DOWNGRADE4args:
    # XDR definition:
    # struct OPEN_DOWNGRADE4args {
    #     stateid4 open_stateid;
    #     seqid4 seqid;
    #     uint32_t share_access;
    #     uint32_t share_deny;
    # };
    def __init__(self, ncl, open_stateid=None, seqid=None, share_access=None, share_deny=None):
        init_type_class(self, ncl)
        self.open_stateid = open_stateid
        self.seqid = seqid
        self.share_access = share_access
        self.share_deny = share_deny

    def __repr__(self):
        s = " open_stateid=%s seqid=%s share_access=%s share_deny=%s" % (str(self.open_stateid), str(self.seqid), str(self.share_access), str(self.share_deny))
        if len(s) > 70: s = s[:70] + "..."
        return "<OPEN_DOWNGRADE4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.open_stateid, self.seqid, self.share_access, self.share_deny)
        self.open_stateid.pack()
        self.packer.pack_seqid4(self.seqid)
        self.packer.pack_uint32_t(self.share_access)
        self.packer.pack_uint32_t(self.share_deny)

    def unpack(self):
        self.open_stateid = stateid4(self)
        self.open_stateid.unpack()
        self.seqid = self.unpacker.unpack_seqid4()
        self.share_access = self.unpacker.unpack_uint32_t()
        self.share_deny = self.unpacker.unpack_uint32_t()

class OPEN_DOWNGRADE4resok:
    # XDR definition:
    # struct OPEN_DOWNGRADE4resok {
    #     stateid4 open_stateid;
    # };
    def __init__(self, ncl, open_stateid=None):
        init_type_class(self, ncl)
        self.open_stateid = open_stateid

    def __repr__(self):
        s = " open_stateid=%s" % (str(self.open_stateid))
        if len(s) > 70: s = s[:70] + "..."
        return "<OPEN_DOWNGRADE4resok:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.open_stateid)
        self.open_stateid.pack()

    def unpack(self):
        self.open_stateid = stateid4(self)
        self.open_stateid.unpack()

class OPEN_DOWNGRADE4res:
    # XDR definition:
    # union OPEN_DOWNGRADE4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         OPEN_DOWNGRADE4resok    resok4;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, resok4=None):
        init_type_class(self, ncl)
        self.status = status
        self.resok4 = resok4
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s resok4=%s" % (str(self.status), str(self.resok4))
        if len(s) > 70: s = s[:70] + "..."
        return "<OPEN_DOWNGRADE4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.resok4)
            self.resok4.pack()
            self.arm = self.resok4
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.resok4 = OPEN_DOWNGRADE4resok(self)
            self.resok4.unpack()
            self.arm = self.resok4
        else:
            pass
            

class PUTFH4args:
    # XDR definition:
    # struct PUTFH4args {
    #     nfs_fh4 object;
    # };
    def __init__(self, ncl, object=None):
        init_type_class(self, ncl)
        self.object = object

    def __repr__(self):
        s = " object=%s" % (str(self.object))
        if len(s) > 70: s = s[:70] + "..."
        return "<PUTFH4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.object)
        self.packer.pack_nfs_fh4(self.object)

    def unpack(self):
        self.object = self.unpacker.unpack_nfs_fh4()

class PUTFH4res:
    # XDR definition:
    # struct PUTFH4res {
    #     nfsstat4 status;
    # };
    def __init__(self, ncl, status=None):
        init_type_class(self, ncl)
        self.status = status

    def __repr__(self):
        s = " status=%s" % (str(self.status))
        if len(s) > 70: s = s[:70] + "..."
        return "<PUTFH4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()

class PUTPUBFH4res:
    # XDR definition:
    # struct PUTPUBFH4res {
    #     nfsstat4 status;
    # };
    def __init__(self, ncl, status=None):
        init_type_class(self, ncl)
        self.status = status

    def __repr__(self):
        s = " status=%s" % (str(self.status))
        if len(s) > 70: s = s[:70] + "..."
        return "<PUTPUBFH4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()

class PUTROOTFH4res:
    # XDR definition:
    # struct PUTROOTFH4res {
    #     nfsstat4 status;
    # };
    def __init__(self, ncl, status=None):
        init_type_class(self, ncl)
        self.status = status

    def __repr__(self):
        s = " status=%s" % (str(self.status))
        if len(s) > 70: s = s[:70] + "..."
        return "<PUTROOTFH4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()

class READ4args:
    # XDR definition:
    # struct READ4args {
    #     stateid4 stateid;
    #     offset4 offset;
    #     count4 count;
    # };
    def __init__(self, ncl, stateid=None, offset=None, count=None):
        init_type_class(self, ncl)
        self.stateid = stateid
        self.offset = offset
        self.count = count

    def __repr__(self):
        s = " stateid=%s offset=%s count=%s" % (str(self.stateid), str(self.offset), str(self.count))
        if len(s) > 70: s = s[:70] + "..."
        return "<READ4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.stateid, self.offset, self.count)
        self.stateid.pack()
        self.packer.pack_offset4(self.offset)
        self.packer.pack_count4(self.count)

    def unpack(self):
        self.stateid = stateid4(self)
        self.stateid.unpack()
        self.offset = self.unpacker.unpack_offset4()
        self.count = self.unpacker.unpack_count4()

class READ4resok:
    # XDR definition:
    # struct READ4resok {
    #     bool eof;
    #     opaque data<>;
    # };
    def __init__(self, ncl, eof=None, data=None):
        init_type_class(self, ncl)
        self.eof = eof
        self.data = data

    def __repr__(self):
        s = " eof=%s data=%s" % (str(self.eof), str(self.data))
        if len(s) > 70: s = s[:70] + "..."
        return "<READ4resok:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.eof, self.data)
        self.packer.pack_bool(self.eof)
        self.packer.pack_opaque(self.data)

    def unpack(self):
        self.eof = self.unpacker.unpack_bool()
        self.data = self.unpacker.unpack_opaque()

class READ4res:
    # XDR definition:
    # union READ4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         READ4resok    resok4;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, resok4=None):
        init_type_class(self, ncl)
        self.status = status
        self.resok4 = resok4
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s resok4=%s" % (str(self.status), str(self.resok4))
        if len(s) > 70: s = s[:70] + "..."
        return "<READ4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.resok4)
            self.resok4.pack()
            self.arm = self.resok4
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.resok4 = READ4resok(self)
            self.resok4.unpack()
            self.arm = self.resok4
        else:
            pass
            

class READDIR4args:
    # XDR definition:
    # struct READDIR4args {
    #     nfs_cookie4 cookie;
    #     verifier4 cookieverf;
    #     count4 dircount;
    #     count4 maxcount;
    #     bitmap4 attr_request;
    # };
    def __init__(self, ncl, cookie=None, cookieverf=None, dircount=None, maxcount=None, attr_request=None):
        init_type_class(self, ncl)
        self.cookie = cookie
        self.cookieverf = cookieverf
        self.dircount = dircount
        self.maxcount = maxcount
        self.attr_request = attr_request

    def __repr__(self):
        s = " cookie=%s cookieverf=%s dircount=%s maxcount=%s attr_request=%s" % (str(self.cookie), str(self.cookieverf), str(self.dircount), str(self.maxcount), str(self.attr_request))
        if len(s) > 70: s = s[:70] + "..."
        return "<READDIR4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.cookie, self.cookieverf, self.dircount, self.maxcount, self.attr_request)
        self.packer.pack_nfs_cookie4(self.cookie)
        self.packer.pack_verifier4(self.cookieverf)
        self.packer.pack_count4(self.dircount)
        self.packer.pack_count4(self.maxcount)
        self.packer.pack_bitmap4(self.attr_request)

    def unpack(self):
        self.cookie = self.unpacker.unpack_nfs_cookie4()
        self.cookieverf = self.unpacker.unpack_verifier4()
        self.dircount = self.unpacker.unpack_count4()
        self.maxcount = self.unpacker.unpack_count4()
        self.attr_request = self.unpacker.unpack_bitmap4()

class entry4:
    # XDR definition:
    # struct entry4 {
    #     nfs_cookie4 cookie;
    #     component4 name;
    #     fattr4 attrs;
    #     entry4 nextentry<1>;
    # };
    def __init__(self, ncl, cookie=None, name=None, attrs=None, nextentry=None):
        init_type_class(self, ncl)
        self.cookie = cookie
        self.name = name
        self.attrs = attrs
        self.nextentry = nextentry

    def __repr__(self):
        s = " cookie=%s name=%s attrs=%s nextentry=%s" % (str(self.cookie), str(self.name), str(self.attrs), str(self.nextentry))
        if len(s) > 70: s = s[:70] + "..."
        return "<entry4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.cookie, self.name, self.attrs, self.nextentry)
        self.packer.pack_nfs_cookie4(self.cookie)
        self.packer.pack_component4(self.name)
        self.attrs.pack()
        pack_objarray(self, self.nextentry)

    def unpack(self):
        self.cookie = self.unpacker.unpack_nfs_cookie4()
        self.name = self.unpacker.unpack_component4()
        self.attrs = fattr4(self)
        self.attrs.unpack()
        self.nextentry = unpack_objarray(self, entry4)

class dirlist4:
    # XDR definition:
    # struct dirlist4 {
    #     entry4 entries<1>;
    #     bool eof;
    # };
    def __init__(self, ncl, entries=None, eof=None):
        init_type_class(self, ncl)
        self.entries = entries
        self.eof = eof

    def __repr__(self):
        s = " entries=%s eof=%s" % (str(self.entries), str(self.eof))
        if len(s) > 70: s = s[:70] + "..."
        return "<dirlist4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.entries, self.eof)
        pack_objarray(self, self.entries)
        self.packer.pack_bool(self.eof)

    def unpack(self):
        self.entries = unpack_objarray(self, entry4)
        self.eof = self.unpacker.unpack_bool()

class READDIR4resok:
    # XDR definition:
    # struct READDIR4resok {
    #     verifier4 cookieverf;
    #     dirlist4 reply;
    # };
    def __init__(self, ncl, cookieverf=None, reply=None):
        init_type_class(self, ncl)
        self.cookieverf = cookieverf
        self.reply = reply

    def __repr__(self):
        s = " cookieverf=%s reply=%s" % (str(self.cookieverf), str(self.reply))
        if len(s) > 70: s = s[:70] + "..."
        return "<READDIR4resok:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.cookieverf, self.reply)
        self.packer.pack_verifier4(self.cookieverf)
        self.reply.pack()

    def unpack(self):
        self.cookieverf = self.unpacker.unpack_verifier4()
        self.reply = dirlist4(self)
        self.reply.unpack()

class READDIR4res:
    # XDR definition:
    # union READDIR4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         READDIR4resok    resok4;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, resok4=None):
        init_type_class(self, ncl)
        self.status = status
        self.resok4 = resok4
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s resok4=%s" % (str(self.status), str(self.resok4))
        if len(s) > 70: s = s[:70] + "..."
        return "<READDIR4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.resok4)
            self.resok4.pack()
            self.arm = self.resok4
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.resok4 = READDIR4resok(self)
            self.resok4.unpack()
            self.arm = self.resok4
        else:
            pass
            

class READLINK4resok:
    # XDR definition:
    # struct READLINK4resok {
    #     linktext4 link;
    # };
    def __init__(self, ncl, link=None):
        init_type_class(self, ncl)
        self.link = link

    def __repr__(self):
        s = " link=%s" % (str(self.link))
        if len(s) > 70: s = s[:70] + "..."
        return "<READLINK4resok:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.link)
        self.packer.pack_linktext4(self.link)

    def unpack(self):
        self.link = self.unpacker.unpack_linktext4()

class READLINK4res:
    # XDR definition:
    # union READLINK4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         READLINK4resok    resok4;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, resok4=None):
        init_type_class(self, ncl)
        self.status = status
        self.resok4 = resok4
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s resok4=%s" % (str(self.status), str(self.resok4))
        if len(s) > 70: s = s[:70] + "..."
        return "<READLINK4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.resok4)
            self.resok4.pack()
            self.arm = self.resok4
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.resok4 = READLINK4resok(self)
            self.resok4.unpack()
            self.arm = self.resok4
        else:
            pass
            

class REMOVE4args:
    # XDR definition:
    # struct REMOVE4args {
    #     component4 target;
    # };
    def __init__(self, ncl, target=None):
        init_type_class(self, ncl)
        self.target = target

    def __repr__(self):
        s = " target=%s" % (str(self.target))
        if len(s) > 70: s = s[:70] + "..."
        return "<REMOVE4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.target)
        self.packer.pack_component4(self.target)

    def unpack(self):
        self.target = self.unpacker.unpack_component4()

class REMOVE4resok:
    # XDR definition:
    # struct REMOVE4resok {
    #     change_info4 cinfo;
    # };
    def __init__(self, ncl, cinfo=None):
        init_type_class(self, ncl)
        self.cinfo = cinfo

    def __repr__(self):
        s = " cinfo=%s" % (str(self.cinfo))
        if len(s) > 70: s = s[:70] + "..."
        return "<REMOVE4resok:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.cinfo)
        self.cinfo.pack()

    def unpack(self):
        self.cinfo = change_info4(self)
        self.cinfo.unpack()

class REMOVE4res:
    # XDR definition:
    # union REMOVE4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         REMOVE4resok    resok4;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, resok4=None):
        init_type_class(self, ncl)
        self.status = status
        self.resok4 = resok4
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s resok4=%s" % (str(self.status), str(self.resok4))
        if len(s) > 70: s = s[:70] + "..."
        return "<REMOVE4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.resok4)
            self.resok4.pack()
            self.arm = self.resok4
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.resok4 = REMOVE4resok(self)
            self.resok4.unpack()
            self.arm = self.resok4
        else:
            pass
            

class RENAME4args:
    # XDR definition:
    # struct RENAME4args {
    #     component4 oldname;
    #     component4 newname;
    # };
    def __init__(self, ncl, oldname=None, newname=None):
        init_type_class(self, ncl)
        self.oldname = oldname
        self.newname = newname

    def __repr__(self):
        s = " oldname=%s newname=%s" % (str(self.oldname), str(self.newname))
        if len(s) > 70: s = s[:70] + "..."
        return "<RENAME4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.oldname, self.newname)
        self.packer.pack_component4(self.oldname)
        self.packer.pack_component4(self.newname)

    def unpack(self):
        self.oldname = self.unpacker.unpack_component4()
        self.newname = self.unpacker.unpack_component4()

class RENAME4resok:
    # XDR definition:
    # struct RENAME4resok {
    #     change_info4 source_cinfo;
    #     change_info4 target_cinfo;
    # };
    def __init__(self, ncl, source_cinfo=None, target_cinfo=None):
        init_type_class(self, ncl)
        self.source_cinfo = source_cinfo
        self.target_cinfo = target_cinfo

    def __repr__(self):
        s = " source_cinfo=%s target_cinfo=%s" % (str(self.source_cinfo), str(self.target_cinfo))
        if len(s) > 70: s = s[:70] + "..."
        return "<RENAME4resok:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.source_cinfo, self.target_cinfo)
        self.source_cinfo.pack()
        self.target_cinfo.pack()

    def unpack(self):
        self.source_cinfo = change_info4(self)
        self.source_cinfo.unpack()
        self.target_cinfo = change_info4(self)
        self.target_cinfo.unpack()

class RENAME4res:
    # XDR definition:
    # union RENAME4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         RENAME4resok    resok4;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, resok4=None):
        init_type_class(self, ncl)
        self.status = status
        self.resok4 = resok4
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s resok4=%s" % (str(self.status), str(self.resok4))
        if len(s) > 70: s = s[:70] + "..."
        return "<RENAME4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.resok4)
            self.resok4.pack()
            self.arm = self.resok4
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.resok4 = RENAME4resok(self)
            self.resok4.unpack()
            self.arm = self.resok4
        else:
            pass
            

class RENEW4args:
    # XDR definition:
    # struct RENEW4args {
    #     clientid4 clientid;
    # };
    def __init__(self, ncl, clientid=None):
        init_type_class(self, ncl)
        self.clientid = clientid

    def __repr__(self):
        s = " clientid=%s" % (str(self.clientid))
        if len(s) > 70: s = s[:70] + "..."
        return "<RENEW4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.clientid)
        self.packer.pack_clientid4(self.clientid)

    def unpack(self):
        self.clientid = self.unpacker.unpack_clientid4()

class RENEW4res:
    # XDR definition:
    # struct RENEW4res {
    #     nfsstat4 status;
    # };
    def __init__(self, ncl, status=None):
        init_type_class(self, ncl)
        self.status = status

    def __repr__(self):
        s = " status=%s" % (str(self.status))
        if len(s) > 70: s = s[:70] + "..."
        return "<RENEW4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()

class RESTOREFH4res:
    # XDR definition:
    # struct RESTOREFH4res {
    #     nfsstat4 status;
    # };
    def __init__(self, ncl, status=None):
        init_type_class(self, ncl)
        self.status = status

    def __repr__(self):
        s = " status=%s" % (str(self.status))
        if len(s) > 70: s = s[:70] + "..."
        return "<RESTOREFH4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()

class SAVEFH4res:
    # XDR definition:
    # struct SAVEFH4res {
    #     nfsstat4 status;
    # };
    def __init__(self, ncl, status=None):
        init_type_class(self, ncl)
        self.status = status

    def __repr__(self):
        s = " status=%s" % (str(self.status))
        if len(s) > 70: s = s[:70] + "..."
        return "<SAVEFH4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()

class SECINFO4args:
    # XDR definition:
    # struct SECINFO4args {
    #     component4 name;
    # };
    def __init__(self, ncl, name=None):
        init_type_class(self, ncl)
        self.name = name

    def __repr__(self):
        s = " name=%s" % (str(self.name))
        if len(s) > 70: s = s[:70] + "..."
        return "<SECINFO4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.name)
        self.packer.pack_component4(self.name)

    def unpack(self):
        self.name = self.unpacker.unpack_component4()

class rpcsec_gss_info:
    # XDR definition:
    # struct rpcsec_gss_info {
    #     sec_oid4 oid;
    #     qop4 qop;
    #     rpc_gss_svc_t service;
    # };
    def __init__(self, ncl, oid=None, qop=None, service=None):
        init_type_class(self, ncl)
        self.oid = oid
        self.qop = qop
        self.service = service

    def __repr__(self):
        s = " oid=%s qop=%s service=%s" % (str(self.oid), str(self.qop), str(self.service))
        if len(s) > 70: s = s[:70] + "..."
        return "<rpcsec_gss_info:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.oid, self.qop, self.service)
        self.packer.pack_sec_oid4(self.oid)
        self.packer.pack_qop4(self.qop)
        self.packer.pack_rpc_gss_svc_t(self.service)

    def unpack(self):
        self.oid = self.unpacker.unpack_sec_oid4()
        self.qop = self.unpacker.unpack_qop4()
        self.service = self.unpacker.unpack_rpc_gss_svc_t()

class secinfo4:
    # XDR definition:
    # union secinfo4 switch (uint32_t flavor) {
    #     case RPCSEC_GSS:
    #         rpcsec_gss_info    flavor_info;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, flavor=None, flavor_info=None):
        init_type_class(self, ncl)
        self.flavor = flavor
        self.flavor_info = flavor_info
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " flavor=%s flavor_info=%s" % (str(self.flavor), str(self.flavor_info))
        if len(s) > 70: s = s[:70] + "..."
        return "<secinfo4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.flavor)
        self.packer.pack_uint32_t(self.flavor)
        if self.flavor == RPCSEC_GSS:
            assert_not_none(self, self.flavor_info)
            self.flavor_info.pack()
            self.arm = self.flavor_info
        else:
            pass
            

    def unpack(self):
        self.flavor = self.unpacker.unpack_uint32_t()
        if self.flavor == RPCSEC_GSS:
            self.flavor_info = rpcsec_gss_info(self)
            self.flavor_info.unpack()
            self.arm = self.flavor_info
        else:
            pass
            

class SECINFO4res:
    # XDR definition:
    # union SECINFO4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         SECINFO4resok    resok4;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, resok4=None):
        init_type_class(self, ncl)
        self.status = status
        self.resok4 = resok4
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s resok4=%s" % (str(self.status), str(self.resok4))
        if len(s) > 70: s = s[:70] + "..."
        return "<SECINFO4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.resok4)
            self.packer.pack_SECINFO4resok(self.resok4)
            self.arm = self.resok4
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.resok4 = self.unpacker.unpack_SECINFO4resok()
            self.arm = self.resok4
        else:
            pass
            

class SETATTR4args:
    # XDR definition:
    # struct SETATTR4args {
    #     stateid4 stateid;
    #     fattr4 obj_attributes;
    # };
    def __init__(self, ncl, stateid=None, obj_attributes=None):
        init_type_class(self, ncl)
        self.stateid = stateid
        self.obj_attributes = obj_attributes

    def __repr__(self):
        s = " stateid=%s obj_attributes=%s" % (str(self.stateid), str(self.obj_attributes))
        if len(s) > 70: s = s[:70] + "..."
        return "<SETATTR4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.stateid, self.obj_attributes)
        self.stateid.pack()
        self.obj_attributes.pack()

    def unpack(self):
        self.stateid = stateid4(self)
        self.stateid.unpack()
        self.obj_attributes = fattr4(self)
        self.obj_attributes.unpack()

class SETATTR4res:
    # XDR definition:
    # struct SETATTR4res {
    #     nfsstat4 status;
    #     bitmap4 attrsset;
    # };
    def __init__(self, ncl, status=None, attrsset=None):
        init_type_class(self, ncl)
        self.status = status
        self.attrsset = attrsset

    def __repr__(self):
        s = " status=%s attrsset=%s" % (str(self.status), str(self.attrsset))
        if len(s) > 70: s = s[:70] + "..."
        return "<SETATTR4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status, self.attrsset)
        self.packer.pack_nfsstat4(self.status)
        self.packer.pack_bitmap4(self.attrsset)

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        self.attrsset = self.unpacker.unpack_bitmap4()

class SETCLIENTID4args:
    # XDR definition:
    # struct SETCLIENTID4args {
    #     nfs_client_id4 client;
    #     cb_client4 callback;
    # };
    def __init__(self, ncl, client=None, callback=None):
        init_type_class(self, ncl)
        self.client = client
        self.callback = callback

    def __repr__(self):
        s = " client=%s callback=%s" % (str(self.client), str(self.callback))
        if len(s) > 70: s = s[:70] + "..."
        return "<SETCLIENTID4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.client, self.callback)
        self.client.pack()
        self.callback.pack()

    def unpack(self):
        self.client = nfs_client_id4(self)
        self.client.unpack()
        self.callback = cb_client4(self)
        self.callback.unpack()

class SETCLIENTID4resok:
    # XDR definition:
    # struct SETCLIENTID4resok {
    #     clientid4 clientid;
    # };
    def __init__(self, ncl, clientid=None):
        init_type_class(self, ncl)
        self.clientid = clientid

    def __repr__(self):
        s = " clientid=%s" % (str(self.clientid))
        if len(s) > 70: s = s[:70] + "..."
        return "<SETCLIENTID4resok:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.clientid)
        self.packer.pack_clientid4(self.clientid)

    def unpack(self):
        self.clientid = self.unpacker.unpack_clientid4()

class SETCLIENTID4res:
    # XDR definition:
    # union SETCLIENTID4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         SETCLIENTID4resok    resok4;
    #     case NFS4ERR_CLID_INUSE:
    #         clientaddr4    client_using;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, resok4=None, client_using=None):
        init_type_class(self, ncl)
        self.status = status
        self.resok4 = resok4
        self.client_using = client_using
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s resok4=%s client_using=%s" % (str(self.status), str(self.resok4), str(self.client_using))
        if len(s) > 70: s = s[:70] + "..."
        return "<SETCLIENTID4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.resok4)
            self.resok4.pack()
            self.arm = self.resok4
        elif self.status == NFS4ERR_CLID_INUSE:
            assert_not_none(self, self.client_using)
            self.client_using.pack()
            self.arm = self.client_using
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.resok4 = SETCLIENTID4resok(self)
            self.resok4.unpack()
            self.arm = self.resok4
        elif self.status == NFS4ERR_CLID_INUSE:
            self.client_using = clientaddr4(self)
            self.client_using.unpack()
            self.arm = self.client_using
        else:
            pass
            

class SETCLIENTID_CONFIRM4args:
    # XDR definition:
    # struct SETCLIENTID_CONFIRM4args {
    #     clientid4 clientid;
    # };
    def __init__(self, ncl, clientid=None):
        init_type_class(self, ncl)
        self.clientid = clientid

    def __repr__(self):
        s = " clientid=%s" % (str(self.clientid))
        if len(s) > 70: s = s[:70] + "..."
        return "<SETCLIENTID_CONFIRM4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.clientid)
        self.packer.pack_clientid4(self.clientid)

    def unpack(self):
        self.clientid = self.unpacker.unpack_clientid4()

class SETCLIENTID_CONFIRM4res:
    # XDR definition:
    # struct SETCLIENTID_CONFIRM4res {
    #     nfsstat4 status;
    # };
    def __init__(self, ncl, status=None):
        init_type_class(self, ncl)
        self.status = status

    def __repr__(self):
        s = " status=%s" % (str(self.status))
        if len(s) > 70: s = s[:70] + "..."
        return "<SETCLIENTID_CONFIRM4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()

class VERIFY4args:
    # XDR definition:
    # struct VERIFY4args {
    #     fattr4 obj_attributes;
    # };
    def __init__(self, ncl, obj_attributes=None):
        init_type_class(self, ncl)
        self.obj_attributes = obj_attributes

    def __repr__(self):
        s = " obj_attributes=%s" % (str(self.obj_attributes))
        if len(s) > 70: s = s[:70] + "..."
        return "<VERIFY4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.obj_attributes)
        self.obj_attributes.pack()

    def unpack(self):
        self.obj_attributes = fattr4(self)
        self.obj_attributes.unpack()

class VERIFY4res:
    # XDR definition:
    # struct VERIFY4res {
    #     nfsstat4 status;
    # };
    def __init__(self, ncl, status=None):
        init_type_class(self, ncl)
        self.status = status

    def __repr__(self):
        s = " status=%s" % (str(self.status))
        if len(s) > 70: s = s[:70] + "..."
        return "<VERIFY4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()

class WRITE4args:
    # XDR definition:
    # struct WRITE4args {
    #     stateid4 stateid;
    #     offset4 offset;
    #     stable_how4 stable;
    #     opaque data<>;
    # };
    def __init__(self, ncl, stateid=None, offset=None, stable=None, data=None):
        init_type_class(self, ncl)
        self.stateid = stateid
        self.offset = offset
        self.stable = stable
        self.data = data

    def __repr__(self):
        s = " stateid=%s offset=%s stable=%s data=%s" % (str(self.stateid), str(self.offset), str(self.stable), str(self.data))
        if len(s) > 70: s = s[:70] + "..."
        return "<WRITE4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.stateid, self.offset, self.stable, self.data)
        self.stateid.pack()
        self.packer.pack_offset4(self.offset)
        self.packer.pack_stable_how4(self.stable)
        self.packer.pack_opaque(self.data)

    def unpack(self):
        self.stateid = stateid4(self)
        self.stateid.unpack()
        self.offset = self.unpacker.unpack_offset4()
        self.stable = self.unpacker.unpack_stable_how4()
        self.data = self.unpacker.unpack_opaque()

class WRITE4resok:
    # XDR definition:
    # struct WRITE4resok {
    #     count4 count;
    #     stable_how4 committed;
    #     verifier4 writeverf;
    # };
    def __init__(self, ncl, count=None, committed=None, writeverf=None):
        init_type_class(self, ncl)
        self.count = count
        self.committed = committed
        self.writeverf = writeverf

    def __repr__(self):
        s = " count=%s committed=%s writeverf=%s" % (str(self.count), str(self.committed), str(self.writeverf))
        if len(s) > 70: s = s[:70] + "..."
        return "<WRITE4resok:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.count, self.committed, self.writeverf)
        self.packer.pack_count4(self.count)
        self.packer.pack_stable_how4(self.committed)
        self.packer.pack_verifier4(self.writeverf)

    def unpack(self):
        self.count = self.unpacker.unpack_count4()
        self.committed = self.unpacker.unpack_stable_how4()
        self.writeverf = self.unpacker.unpack_verifier4()

class WRITE4res:
    # XDR definition:
    # union WRITE4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         WRITE4resok    resok4;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, resok4=None):
        init_type_class(self, ncl)
        self.status = status
        self.resok4 = resok4
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s resok4=%s" % (str(self.status), str(self.resok4))
        if len(s) > 70: s = s[:70] + "..."
        return "<WRITE4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.resok4)
            self.resok4.pack()
            self.arm = self.resok4
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.resok4 = WRITE4resok(self)
            self.resok4.unpack()
            self.arm = self.resok4
        else:
            pass
            

class nfs_argop4:
    # XDR definition:
    # union nfs_argop4 switch (nfs_opnum4 argop) {
    #     case OP_ACCESS:
    #         ACCESS4args    opaccess;
    #     case OP_CLOSE:
    #         CLOSE4args    opclose;
    #     case OP_COMMIT:
    #         COMMIT4args    opcommit;
    #     case OP_CREATE:
    #         CREATE4args    opcreate;
    #     case OP_DELEGPURGE:
    #         DELEGPURGE4args    opdelegpurge;
    #     case OP_DELEGRETURN:
    #         DELEGRETURN4args    opdelegreturn;
    #     case OP_GETATTR:
    #         GETATTR4args    opgetattr;
    #     case OP_GETFH:
    #             void;
    #     case OP_LINK:
    #         LINK4args    oplink;
    #     case OP_LOCK:
    #         LOCK4args    oplock;
    #     case OP_LOCKT:
    #         LOCKT4args    oplockt;
    #     case OP_LOCKU:
    #         LOCKU4args    oplocku;
    #     case OP_LOOKUP:
    #         LOOKUP4args    oplookup;
    #     case OP_LOOKUPP:
    #             void;
    #     case OP_NVERIFY:
    #         NVERIFY4args    opnverify;
    #     case OP_OPEN:
    #         OPEN4args    opopen;
    #     case OP_OPENATTR:
    #         OPENATTR4args    opopenattr;
    #     case OP_OPEN_CONFIRM:
    #         OPEN_CONFIRM4args    opopen_confirm;
    #     case OP_OPEN_DOWNGRADE:
    #         OPEN_DOWNGRADE4args    opopen_downgrade;
    #     case OP_PUTFH:
    #         PUTFH4args    opputfh;
    #     case OP_PUTPUBFH:
    #             void;
    #     case OP_PUTROOTFH:
    #             void;
    #     case OP_READ:
    #         READ4args    opread;
    #     case OP_READDIR:
    #         READDIR4args    opreaddir;
    #     case OP_READLINK:
    #             void;
    #     case OP_REMOVE:
    #         REMOVE4args    opremove;
    #     case OP_RENAME:
    #         RENAME4args    oprename;
    #     case OP_RENEW:
    #         RENEW4args    oprenew;
    #     case OP_RESTOREFH:
    #             void;
    #     case OP_SAVEFH:
    #             void;
    #     case OP_SECINFO:
    #         SECINFO4args    opsecinfo;
    #     case OP_SETATTR:
    #         SETATTR4args    opsetattr;
    #     case OP_SETCLIENTID:
    #         SETCLIENTID4args    opsetclientid;
    #     case OP_SETCLIENTID_CONFIRM:
    #         SETCLIENTID_CONFIRM4args    opsetclientid_confirm;
    #     case OP_VERIFY:
    #         VERIFY4args    opverify;
    #     case OP_WRITE:
    #         WRITE4args    opwrite;
    # };
    def __init__(self, ncl, argop=None, opaccess=None, opclose=None, opcommit=None, opcreate=None, opdelegpurge=None, opdelegreturn=None, opgetattr=None, oplink=None, oplock=None, oplockt=None, oplocku=None, oplookup=None, opnverify=None, opopen=None, opopenattr=None, opopen_confirm=None, opopen_downgrade=None, opputfh=None, opread=None, opreaddir=None, opremove=None, oprename=None, oprenew=None, opsecinfo=None, opsetattr=None, opsetclientid=None, opsetclientid_confirm=None, opverify=None, opwrite=None):
        init_type_class(self, ncl)
        self.argop = argop
        self.opaccess = opaccess
        self.opclose = opclose
        self.opcommit = opcommit
        self.opcreate = opcreate
        self.opdelegpurge = opdelegpurge
        self.opdelegreturn = opdelegreturn
        self.opgetattr = opgetattr
        self.oplink = oplink
        self.oplock = oplock
        self.oplockt = oplockt
        self.oplocku = oplocku
        self.oplookup = oplookup
        self.opnverify = opnverify
        self.opopen = opopen
        self.opopenattr = opopenattr
        self.opopen_confirm = opopen_confirm
        self.opopen_downgrade = opopen_downgrade
        self.opputfh = opputfh
        self.opread = opread
        self.opreaddir = opreaddir
        self.opremove = opremove
        self.oprename = oprename
        self.oprenew = oprenew
        self.opsecinfo = opsecinfo
        self.opsetattr = opsetattr
        self.opsetclientid = opsetclientid
        self.opsetclientid_confirm = opsetclientid_confirm
        self.opverify = opverify
        self.opwrite = opwrite
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " argop=%s opaccess=%s opclose=%s opcommit=%s opcreate=%s opdelegpurge=%s opdelegreturn=%s opgetattr=%s oplink=%s oplock=%s oplockt=%s oplocku=%s oplookup=%s opnverify=%s opopen=%s opopenattr=%s opopen_confirm=%s opopen_downgrade=%s opputfh=%s opread=%s opreaddir=%s opremove=%s oprename=%s oprenew=%s opsecinfo=%s opsetattr=%s opsetclientid=%s opsetclientid_confirm=%s opverify=%s opwrite=%s" % (str(self.argop), str(self.opaccess), str(self.opclose), str(self.opcommit), str(self.opcreate), str(self.opdelegpurge), str(self.opdelegreturn), str(self.opgetattr), str(self.oplink), str(self.oplock), str(self.oplockt), str(self.oplocku), str(self.oplookup), str(self.opnverify), str(self.opopen), str(self.opopenattr), str(self.opopen_confirm), str(self.opopen_downgrade), str(self.opputfh), str(self.opread), str(self.opreaddir), str(self.opremove), str(self.oprename), str(self.oprenew), str(self.opsecinfo), str(self.opsetattr), str(self.opsetclientid), str(self.opsetclientid_confirm), str(self.opverify), str(self.opwrite))
        if len(s) > 70: s = s[:70] + "..."
        return "<nfs_argop4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.argop)
        self.packer.pack_nfs_opnum4(self.argop)
        if self.argop == OP_ACCESS:
            assert_not_none(self, self.opaccess)
            self.opaccess.pack()
            self.arm = self.opaccess
        elif self.argop == OP_CLOSE:
            assert_not_none(self, self.opclose)
            self.opclose.pack()
            self.arm = self.opclose
        elif self.argop == OP_COMMIT:
            assert_not_none(self, self.opcommit)
            self.opcommit.pack()
            self.arm = self.opcommit
        elif self.argop == OP_CREATE:
            assert_not_none(self, self.opcreate)
            self.opcreate.pack()
            self.arm = self.opcreate
        elif self.argop == OP_DELEGPURGE:
            assert_not_none(self, self.opdelegpurge)
            self.opdelegpurge.pack()
            self.arm = self.opdelegpurge
        elif self.argop == OP_DELEGRETURN:
            assert_not_none(self, self.opdelegreturn)
            self.opdelegreturn.pack()
            self.arm = self.opdelegreturn
        elif self.argop == OP_GETATTR:
            assert_not_none(self, self.opgetattr)
            self.opgetattr.pack()
            self.arm = self.opgetattr
        elif self.argop == OP_GETFH:
            pass
        elif self.argop == OP_LINK:
            assert_not_none(self, self.oplink)
            self.oplink.pack()
            self.arm = self.oplink
        elif self.argop == OP_LOCK:
            assert_not_none(self, self.oplock)
            self.oplock.pack()
            self.arm = self.oplock
        elif self.argop == OP_LOCKT:
            assert_not_none(self, self.oplockt)
            self.oplockt.pack()
            self.arm = self.oplockt
        elif self.argop == OP_LOCKU:
            assert_not_none(self, self.oplocku)
            self.oplocku.pack()
            self.arm = self.oplocku
        elif self.argop == OP_LOOKUP:
            assert_not_none(self, self.oplookup)
            self.oplookup.pack()
            self.arm = self.oplookup
        elif self.argop == OP_LOOKUPP:
            pass
        elif self.argop == OP_NVERIFY:
            assert_not_none(self, self.opnverify)
            self.opnverify.pack()
            self.arm = self.opnverify
        elif self.argop == OP_OPEN:
            assert_not_none(self, self.opopen)
            self.opopen.pack()
            self.arm = self.opopen
        elif self.argop == OP_OPENATTR:
            assert_not_none(self, self.opopenattr)
            self.opopenattr.pack()
            self.arm = self.opopenattr
        elif self.argop == OP_OPEN_CONFIRM:
            assert_not_none(self, self.opopen_confirm)
            self.opopen_confirm.pack()
            self.arm = self.opopen_confirm
        elif self.argop == OP_OPEN_DOWNGRADE:
            assert_not_none(self, self.opopen_downgrade)
            self.opopen_downgrade.pack()
            self.arm = self.opopen_downgrade
        elif self.argop == OP_PUTFH:
            assert_not_none(self, self.opputfh)
            self.opputfh.pack()
            self.arm = self.opputfh
        elif self.argop == OP_PUTPUBFH:
            pass
        elif self.argop == OP_PUTROOTFH:
            pass
        elif self.argop == OP_READ:
            assert_not_none(self, self.opread)
            self.opread.pack()
            self.arm = self.opread
        elif self.argop == OP_READDIR:
            assert_not_none(self, self.opreaddir)
            self.opreaddir.pack()
            self.arm = self.opreaddir
        elif self.argop == OP_READLINK:
            pass
        elif self.argop == OP_REMOVE:
            assert_not_none(self, self.opremove)
            self.opremove.pack()
            self.arm = self.opremove
        elif self.argop == OP_RENAME:
            assert_not_none(self, self.oprename)
            self.oprename.pack()
            self.arm = self.oprename
        elif self.argop == OP_RENEW:
            assert_not_none(self, self.oprenew)
            self.oprenew.pack()
            self.arm = self.oprenew
        elif self.argop == OP_RESTOREFH:
            pass
        elif self.argop == OP_SAVEFH:
            pass
        elif self.argop == OP_SECINFO:
            assert_not_none(self, self.opsecinfo)
            self.opsecinfo.pack()
            self.arm = self.opsecinfo
        elif self.argop == OP_SETATTR:
            assert_not_none(self, self.opsetattr)
            self.opsetattr.pack()
            self.arm = self.opsetattr
        elif self.argop == OP_SETCLIENTID:
            assert_not_none(self, self.opsetclientid)
            self.opsetclientid.pack()
            self.arm = self.opsetclientid
        elif self.argop == OP_SETCLIENTID_CONFIRM:
            assert_not_none(self, self.opsetclientid_confirm)
            self.opsetclientid_confirm.pack()
            self.arm = self.opsetclientid_confirm
        elif self.argop == OP_VERIFY:
            assert_not_none(self, self.opverify)
            self.opverify.pack()
            self.arm = self.opverify
        elif self.argop == OP_WRITE:
            assert_not_none(self, self.opwrite)
            self.opwrite.pack()
            self.arm = self.opwrite
        else:
            raise BadDiscriminant(self.argop, self)
            

    def unpack(self):
        self.argop = self.unpacker.unpack_nfs_opnum4()
        if self.argop == OP_ACCESS:
            self.opaccess = ACCESS4args(self)
            self.opaccess.unpack()
            self.arm = self.opaccess
        elif self.argop == OP_CLOSE:
            self.opclose = CLOSE4args(self)
            self.opclose.unpack()
            self.arm = self.opclose
        elif self.argop == OP_COMMIT:
            self.opcommit = COMMIT4args(self)
            self.opcommit.unpack()
            self.arm = self.opcommit
        elif self.argop == OP_CREATE:
            self.opcreate = CREATE4args(self)
            self.opcreate.unpack()
            self.arm = self.opcreate
        elif self.argop == OP_DELEGPURGE:
            self.opdelegpurge = DELEGPURGE4args(self)
            self.opdelegpurge.unpack()
            self.arm = self.opdelegpurge
        elif self.argop == OP_DELEGRETURN:
            self.opdelegreturn = DELEGRETURN4args(self)
            self.opdelegreturn.unpack()
            self.arm = self.opdelegreturn
        elif self.argop == OP_GETATTR:
            self.opgetattr = GETATTR4args(self)
            self.opgetattr.unpack()
            self.arm = self.opgetattr
        elif self.argop == OP_GETFH:
            pass
        elif self.argop == OP_LINK:
            self.oplink = LINK4args(self)
            self.oplink.unpack()
            self.arm = self.oplink
        elif self.argop == OP_LOCK:
            self.oplock = LOCK4args(self)
            self.oplock.unpack()
            self.arm = self.oplock
        elif self.argop == OP_LOCKT:
            self.oplockt = LOCKT4args(self)
            self.oplockt.unpack()
            self.arm = self.oplockt
        elif self.argop == OP_LOCKU:
            self.oplocku = LOCKU4args(self)
            self.oplocku.unpack()
            self.arm = self.oplocku
        elif self.argop == OP_LOOKUP:
            self.oplookup = LOOKUP4args(self)
            self.oplookup.unpack()
            self.arm = self.oplookup
        elif self.argop == OP_LOOKUPP:
            pass
        elif self.argop == OP_NVERIFY:
            self.opnverify = NVERIFY4args(self)
            self.opnverify.unpack()
            self.arm = self.opnverify
        elif self.argop == OP_OPEN:
            self.opopen = OPEN4args(self)
            self.opopen.unpack()
            self.arm = self.opopen
        elif self.argop == OP_OPENATTR:
            self.opopenattr = OPENATTR4args(self)
            self.opopenattr.unpack()
            self.arm = self.opopenattr
        elif self.argop == OP_OPEN_CONFIRM:
            self.opopen_confirm = OPEN_CONFIRM4args(self)
            self.opopen_confirm.unpack()
            self.arm = self.opopen_confirm
        elif self.argop == OP_OPEN_DOWNGRADE:
            self.opopen_downgrade = OPEN_DOWNGRADE4args(self)
            self.opopen_downgrade.unpack()
            self.arm = self.opopen_downgrade
        elif self.argop == OP_PUTFH:
            self.opputfh = PUTFH4args(self)
            self.opputfh.unpack()
            self.arm = self.opputfh
        elif self.argop == OP_PUTPUBFH:
            pass
        elif self.argop == OP_PUTROOTFH:
            pass
        elif self.argop == OP_READ:
            self.opread = READ4args(self)
            self.opread.unpack()
            self.arm = self.opread
        elif self.argop == OP_READDIR:
            self.opreaddir = READDIR4args(self)
            self.opreaddir.unpack()
            self.arm = self.opreaddir
        elif self.argop == OP_READLINK:
            pass
        elif self.argop == OP_REMOVE:
            self.opremove = REMOVE4args(self)
            self.opremove.unpack()
            self.arm = self.opremove
        elif self.argop == OP_RENAME:
            self.oprename = RENAME4args(self)
            self.oprename.unpack()
            self.arm = self.oprename
        elif self.argop == OP_RENEW:
            self.oprenew = RENEW4args(self)
            self.oprenew.unpack()
            self.arm = self.oprenew
        elif self.argop == OP_RESTOREFH:
            pass
        elif self.argop == OP_SAVEFH:
            pass
        elif self.argop == OP_SECINFO:
            self.opsecinfo = SECINFO4args(self)
            self.opsecinfo.unpack()
            self.arm = self.opsecinfo
        elif self.argop == OP_SETATTR:
            self.opsetattr = SETATTR4args(self)
            self.opsetattr.unpack()
            self.arm = self.opsetattr
        elif self.argop == OP_SETCLIENTID:
            self.opsetclientid = SETCLIENTID4args(self)
            self.opsetclientid.unpack()
            self.arm = self.opsetclientid
        elif self.argop == OP_SETCLIENTID_CONFIRM:
            self.opsetclientid_confirm = SETCLIENTID_CONFIRM4args(self)
            self.opsetclientid_confirm.unpack()
            self.arm = self.opsetclientid_confirm
        elif self.argop == OP_VERIFY:
            self.opverify = VERIFY4args(self)
            self.opverify.unpack()
            self.arm = self.opverify
        elif self.argop == OP_WRITE:
            self.opwrite = WRITE4args(self)
            self.opwrite.unpack()
            self.arm = self.opwrite
        else:
            raise BadDiscriminant(self.argop, self)
            

class nfs_resop4:
    # XDR definition:
    # union nfs_resop4 switch (nfs_opnum4 resop) {
    #     case OP_ACCESS:
    #         ACCESS4res    opaccess;
    #     case OP_CLOSE:
    #         CLOSE4res    opclose;
    #     case OP_COMMIT:
    #         COMMIT4res    opcommit;
    #     case OP_CREATE:
    #         CREATE4res    opcreate;
    #     case OP_DELEGPURGE:
    #         DELEGPURGE4res    opdelegpurge;
    #     case OP_DELEGRETURN:
    #         DELEGRETURN4res    opdelegreturn;
    #     case OP_GETATTR:
    #         GETATTR4res    opgetattr;
    #     case OP_GETFH:
    #         GETFH4res    opgetfh;
    #     case OP_LINK:
    #         LINK4res    oplink;
    #     case OP_LOCK:
    #         LOCK4res    oplock;
    #     case OP_LOCKT:
    #         LOCKT4res    oplockt;
    #     case OP_LOCKU:
    #         LOCKU4res    oplocku;
    #     case OP_LOOKUP:
    #         LOOKUP4res    oplookup;
    #     case OP_LOOKUPP:
    #         LOOKUPP4res    oplookupp;
    #     case OP_NVERIFY:
    #         NVERIFY4res    opnverify;
    #     case OP_OPEN:
    #         OPEN4res    opopen;
    #     case OP_OPENATTR:
    #         OPENATTR4res    opopenattr;
    #     case OP_OPEN_CONFIRM:
    #         OPEN_CONFIRM4res    opopen_confirm;
    #     case OP_OPEN_DOWNGRADE:
    #         OPEN_DOWNGRADE4res    opopen_downgrade;
    #     case OP_PUTFH:
    #         PUTFH4res    opputfh;
    #     case OP_PUTPUBFH:
    #         PUTPUBFH4res    opputpubfh;
    #     case OP_PUTROOTFH:
    #         PUTROOTFH4res    opputrootfh;
    #     case OP_READ:
    #         READ4res    opread;
    #     case OP_READDIR:
    #         READDIR4res    opreaddir;
    #     case OP_READLINK:
    #         READLINK4res    opreadlink;
    #     case OP_REMOVE:
    #         REMOVE4res    opremove;
    #     case OP_RENAME:
    #         RENAME4res    oprename;
    #     case OP_RENEW:
    #         RENEW4res    oprenew;
    #     case OP_RESTOREFH:
    #         RESTOREFH4res    oprestorefh;
    #     case OP_SAVEFH:
    #         SAVEFH4res    opsavefh;
    #     case OP_SECINFO:
    #         SECINFO4res    opsecinfo;
    #     case OP_SETATTR:
    #         SETATTR4res    opsetattr;
    #     case OP_SETCLIENTID:
    #         SETCLIENTID4res    opsetclientid;
    #     case OP_SETCLIENTID_CONFIRM:
    #         SETCLIENTID_CONFIRM4res    opsetclientid_confirm;
    #     case OP_VERIFY:
    #         VERIFY4res    opverify;
    #     case OP_WRITE:
    #         WRITE4res    opwrite;
    # };
    def __init__(self, ncl, resop=None, opaccess=None, opclose=None, opcommit=None, opcreate=None, opdelegpurge=None, opdelegreturn=None, opgetattr=None, opgetfh=None, oplink=None, oplock=None, oplockt=None, oplocku=None, oplookup=None, oplookupp=None, opnverify=None, opopen=None, opopenattr=None, opopen_confirm=None, opopen_downgrade=None, opputfh=None, opputpubfh=None, opputrootfh=None, opread=None, opreaddir=None, opreadlink=None, opremove=None, oprename=None, oprenew=None, oprestorefh=None, opsavefh=None, opsecinfo=None, opsetattr=None, opsetclientid=None, opsetclientid_confirm=None, opverify=None, opwrite=None):
        init_type_class(self, ncl)
        self.resop = resop
        self.opaccess = opaccess
        self.opclose = opclose
        self.opcommit = opcommit
        self.opcreate = opcreate
        self.opdelegpurge = opdelegpurge
        self.opdelegreturn = opdelegreturn
        self.opgetattr = opgetattr
        self.opgetfh = opgetfh
        self.oplink = oplink
        self.oplock = oplock
        self.oplockt = oplockt
        self.oplocku = oplocku
        self.oplookup = oplookup
        self.oplookupp = oplookupp
        self.opnverify = opnverify
        self.opopen = opopen
        self.opopenattr = opopenattr
        self.opopen_confirm = opopen_confirm
        self.opopen_downgrade = opopen_downgrade
        self.opputfh = opputfh
        self.opputpubfh = opputpubfh
        self.opputrootfh = opputrootfh
        self.opread = opread
        self.opreaddir = opreaddir
        self.opreadlink = opreadlink
        self.opremove = opremove
        self.oprename = oprename
        self.oprenew = oprenew
        self.oprestorefh = oprestorefh
        self.opsavefh = opsavefh
        self.opsecinfo = opsecinfo
        self.opsetattr = opsetattr
        self.opsetclientid = opsetclientid
        self.opsetclientid_confirm = opsetclientid_confirm
        self.opverify = opverify
        self.opwrite = opwrite
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " resop=%s opaccess=%s opclose=%s opcommit=%s opcreate=%s opdelegpurge=%s opdelegreturn=%s opgetattr=%s opgetfh=%s oplink=%s oplock=%s oplockt=%s oplocku=%s oplookup=%s oplookupp=%s opnverify=%s opopen=%s opopenattr=%s opopen_confirm=%s opopen_downgrade=%s opputfh=%s opputpubfh=%s opputrootfh=%s opread=%s opreaddir=%s opreadlink=%s opremove=%s oprename=%s oprenew=%s oprestorefh=%s opsavefh=%s opsecinfo=%s opsetattr=%s opsetclientid=%s opsetclientid_confirm=%s opverify=%s opwrite=%s" % (str(self.resop), str(self.opaccess), str(self.opclose), str(self.opcommit), str(self.opcreate), str(self.opdelegpurge), str(self.opdelegreturn), str(self.opgetattr), str(self.opgetfh), str(self.oplink), str(self.oplock), str(self.oplockt), str(self.oplocku), str(self.oplookup), str(self.oplookupp), str(self.opnverify), str(self.opopen), str(self.opopenattr), str(self.opopen_confirm), str(self.opopen_downgrade), str(self.opputfh), str(self.opputpubfh), str(self.opputrootfh), str(self.opread), str(self.opreaddir), str(self.opreadlink), str(self.opremove), str(self.oprename), str(self.oprenew), str(self.oprestorefh), str(self.opsavefh), str(self.opsecinfo), str(self.opsetattr), str(self.opsetclientid), str(self.opsetclientid_confirm), str(self.opverify), str(self.opwrite))
        if len(s) > 70: s = s[:70] + "..."
        return "<nfs_resop4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.resop)
        self.packer.pack_nfs_opnum4(self.resop)
        if self.resop == OP_ACCESS:
            assert_not_none(self, self.opaccess)
            self.opaccess.pack()
            self.arm = self.opaccess
        elif self.resop == OP_CLOSE:
            assert_not_none(self, self.opclose)
            self.opclose.pack()
            self.arm = self.opclose
        elif self.resop == OP_COMMIT:
            assert_not_none(self, self.opcommit)
            self.opcommit.pack()
            self.arm = self.opcommit
        elif self.resop == OP_CREATE:
            assert_not_none(self, self.opcreate)
            self.opcreate.pack()
            self.arm = self.opcreate
        elif self.resop == OP_DELEGPURGE:
            assert_not_none(self, self.opdelegpurge)
            self.opdelegpurge.pack()
            self.arm = self.opdelegpurge
        elif self.resop == OP_DELEGRETURN:
            assert_not_none(self, self.opdelegreturn)
            self.opdelegreturn.pack()
            self.arm = self.opdelegreturn
        elif self.resop == OP_GETATTR:
            assert_not_none(self, self.opgetattr)
            self.opgetattr.pack()
            self.arm = self.opgetattr
        elif self.resop == OP_GETFH:
            assert_not_none(self, self.opgetfh)
            self.opgetfh.pack()
            self.arm = self.opgetfh
        elif self.resop == OP_LINK:
            assert_not_none(self, self.oplink)
            self.oplink.pack()
            self.arm = self.oplink
        elif self.resop == OP_LOCK:
            assert_not_none(self, self.oplock)
            self.oplock.pack()
            self.arm = self.oplock
        elif self.resop == OP_LOCKT:
            assert_not_none(self, self.oplockt)
            self.oplockt.pack()
            self.arm = self.oplockt
        elif self.resop == OP_LOCKU:
            assert_not_none(self, self.oplocku)
            self.oplocku.pack()
            self.arm = self.oplocku
        elif self.resop == OP_LOOKUP:
            assert_not_none(self, self.oplookup)
            self.oplookup.pack()
            self.arm = self.oplookup
        elif self.resop == OP_LOOKUPP:
            assert_not_none(self, self.oplookupp)
            self.oplookupp.pack()
            self.arm = self.oplookupp
        elif self.resop == OP_NVERIFY:
            assert_not_none(self, self.opnverify)
            self.opnverify.pack()
            self.arm = self.opnverify
        elif self.resop == OP_OPEN:
            assert_not_none(self, self.opopen)
            self.opopen.pack()
            self.arm = self.opopen
        elif self.resop == OP_OPENATTR:
            assert_not_none(self, self.opopenattr)
            self.opopenattr.pack()
            self.arm = self.opopenattr
        elif self.resop == OP_OPEN_CONFIRM:
            assert_not_none(self, self.opopen_confirm)
            self.opopen_confirm.pack()
            self.arm = self.opopen_confirm
        elif self.resop == OP_OPEN_DOWNGRADE:
            assert_not_none(self, self.opopen_downgrade)
            self.opopen_downgrade.pack()
            self.arm = self.opopen_downgrade
        elif self.resop == OP_PUTFH:
            assert_not_none(self, self.opputfh)
            self.opputfh.pack()
            self.arm = self.opputfh
        elif self.resop == OP_PUTPUBFH:
            assert_not_none(self, self.opputpubfh)
            self.opputpubfh.pack()
            self.arm = self.opputpubfh
        elif self.resop == OP_PUTROOTFH:
            assert_not_none(self, self.opputrootfh)
            self.opputrootfh.pack()
            self.arm = self.opputrootfh
        elif self.resop == OP_READ:
            assert_not_none(self, self.opread)
            self.opread.pack()
            self.arm = self.opread
        elif self.resop == OP_READDIR:
            assert_not_none(self, self.opreaddir)
            self.opreaddir.pack()
            self.arm = self.opreaddir
        elif self.resop == OP_READLINK:
            assert_not_none(self, self.opreadlink)
            self.opreadlink.pack()
            self.arm = self.opreadlink
        elif self.resop == OP_REMOVE:
            assert_not_none(self, self.opremove)
            self.opremove.pack()
            self.arm = self.opremove
        elif self.resop == OP_RENAME:
            assert_not_none(self, self.oprename)
            self.oprename.pack()
            self.arm = self.oprename
        elif self.resop == OP_RENEW:
            assert_not_none(self, self.oprenew)
            self.oprenew.pack()
            self.arm = self.oprenew
        elif self.resop == OP_RESTOREFH:
            assert_not_none(self, self.oprestorefh)
            self.oprestorefh.pack()
            self.arm = self.oprestorefh
        elif self.resop == OP_SAVEFH:
            assert_not_none(self, self.opsavefh)
            self.opsavefh.pack()
            self.arm = self.opsavefh
        elif self.resop == OP_SECINFO:
            assert_not_none(self, self.opsecinfo)
            self.opsecinfo.pack()
            self.arm = self.opsecinfo
        elif self.resop == OP_SETATTR:
            assert_not_none(self, self.opsetattr)
            self.opsetattr.pack()
            self.arm = self.opsetattr
        elif self.resop == OP_SETCLIENTID:
            assert_not_none(self, self.opsetclientid)
            self.opsetclientid.pack()
            self.arm = self.opsetclientid
        elif self.resop == OP_SETCLIENTID_CONFIRM:
            assert_not_none(self, self.opsetclientid_confirm)
            self.opsetclientid_confirm.pack()
            self.arm = self.opsetclientid_confirm
        elif self.resop == OP_VERIFY:
            assert_not_none(self, self.opverify)
            self.opverify.pack()
            self.arm = self.opverify
        elif self.resop == OP_WRITE:
            assert_not_none(self, self.opwrite)
            self.opwrite.pack()
            self.arm = self.opwrite
        else:
            raise BadDiscriminant(self.resop, self)
            

    def unpack(self):
        self.resop = self.unpacker.unpack_nfs_opnum4()
        if self.resop == OP_ACCESS:
            self.opaccess = ACCESS4res(self)
            self.opaccess.unpack()
            self.arm = self.opaccess
        elif self.resop == OP_CLOSE:
            self.opclose = CLOSE4res(self)
            self.opclose.unpack()
            self.arm = self.opclose
        elif self.resop == OP_COMMIT:
            self.opcommit = COMMIT4res(self)
            self.opcommit.unpack()
            self.arm = self.opcommit
        elif self.resop == OP_CREATE:
            self.opcreate = CREATE4res(self)
            self.opcreate.unpack()
            self.arm = self.opcreate
        elif self.resop == OP_DELEGPURGE:
            self.opdelegpurge = DELEGPURGE4res(self)
            self.opdelegpurge.unpack()
            self.arm = self.opdelegpurge
        elif self.resop == OP_DELEGRETURN:
            self.opdelegreturn = DELEGRETURN4res(self)
            self.opdelegreturn.unpack()
            self.arm = self.opdelegreturn
        elif self.resop == OP_GETATTR:
            self.opgetattr = GETATTR4res(self)
            self.opgetattr.unpack()
            self.arm = self.opgetattr
        elif self.resop == OP_GETFH:
            self.opgetfh = GETFH4res(self)
            self.opgetfh.unpack()
            self.arm = self.opgetfh
        elif self.resop == OP_LINK:
            self.oplink = LINK4res(self)
            self.oplink.unpack()
            self.arm = self.oplink
        elif self.resop == OP_LOCK:
            self.oplock = LOCK4res(self)
            self.oplock.unpack()
            self.arm = self.oplock
        elif self.resop == OP_LOCKT:
            self.oplockt = LOCKT4res(self)
            self.oplockt.unpack()
            self.arm = self.oplockt
        elif self.resop == OP_LOCKU:
            self.oplocku = LOCKU4res(self)
            self.oplocku.unpack()
            self.arm = self.oplocku
        elif self.resop == OP_LOOKUP:
            self.oplookup = LOOKUP4res(self)
            self.oplookup.unpack()
            self.arm = self.oplookup
        elif self.resop == OP_LOOKUPP:
            self.oplookupp = LOOKUPP4res(self)
            self.oplookupp.unpack()
            self.arm = self.oplookupp
        elif self.resop == OP_NVERIFY:
            self.opnverify = NVERIFY4res(self)
            self.opnverify.unpack()
            self.arm = self.opnverify
        elif self.resop == OP_OPEN:
            self.opopen = OPEN4res(self)
            self.opopen.unpack()
            self.arm = self.opopen
        elif self.resop == OP_OPENATTR:
            self.opopenattr = OPENATTR4res(self)
            self.opopenattr.unpack()
            self.arm = self.opopenattr
        elif self.resop == OP_OPEN_CONFIRM:
            self.opopen_confirm = OPEN_CONFIRM4res(self)
            self.opopen_confirm.unpack()
            self.arm = self.opopen_confirm
        elif self.resop == OP_OPEN_DOWNGRADE:
            self.opopen_downgrade = OPEN_DOWNGRADE4res(self)
            self.opopen_downgrade.unpack()
            self.arm = self.opopen_downgrade
        elif self.resop == OP_PUTFH:
            self.opputfh = PUTFH4res(self)
            self.opputfh.unpack()
            self.arm = self.opputfh
        elif self.resop == OP_PUTPUBFH:
            self.opputpubfh = PUTPUBFH4res(self)
            self.opputpubfh.unpack()
            self.arm = self.opputpubfh
        elif self.resop == OP_PUTROOTFH:
            self.opputrootfh = PUTROOTFH4res(self)
            self.opputrootfh.unpack()
            self.arm = self.opputrootfh
        elif self.resop == OP_READ:
            self.opread = READ4res(self)
            self.opread.unpack()
            self.arm = self.opread
        elif self.resop == OP_READDIR:
            self.opreaddir = READDIR4res(self)
            self.opreaddir.unpack()
            self.arm = self.opreaddir
        elif self.resop == OP_READLINK:
            self.opreadlink = READLINK4res(self)
            self.opreadlink.unpack()
            self.arm = self.opreadlink
        elif self.resop == OP_REMOVE:
            self.opremove = REMOVE4res(self)
            self.opremove.unpack()
            self.arm = self.opremove
        elif self.resop == OP_RENAME:
            self.oprename = RENAME4res(self)
            self.oprename.unpack()
            self.arm = self.oprename
        elif self.resop == OP_RENEW:
            self.oprenew = RENEW4res(self)
            self.oprenew.unpack()
            self.arm = self.oprenew
        elif self.resop == OP_RESTOREFH:
            self.oprestorefh = RESTOREFH4res(self)
            self.oprestorefh.unpack()
            self.arm = self.oprestorefh
        elif self.resop == OP_SAVEFH:
            self.opsavefh = SAVEFH4res(self)
            self.opsavefh.unpack()
            self.arm = self.opsavefh
        elif self.resop == OP_SECINFO:
            self.opsecinfo = SECINFO4res(self)
            self.opsecinfo.unpack()
            self.arm = self.opsecinfo
        elif self.resop == OP_SETATTR:
            self.opsetattr = SETATTR4res(self)
            self.opsetattr.unpack()
            self.arm = self.opsetattr
        elif self.resop == OP_SETCLIENTID:
            self.opsetclientid = SETCLIENTID4res(self)
            self.opsetclientid.unpack()
            self.arm = self.opsetclientid
        elif self.resop == OP_SETCLIENTID_CONFIRM:
            self.opsetclientid_confirm = SETCLIENTID_CONFIRM4res(self)
            self.opsetclientid_confirm.unpack()
            self.arm = self.opsetclientid_confirm
        elif self.resop == OP_VERIFY:
            self.opverify = VERIFY4res(self)
            self.opverify.unpack()
            self.arm = self.opverify
        elif self.resop == OP_WRITE:
            self.opwrite = WRITE4res(self)
            self.opwrite.unpack()
            self.arm = self.opwrite
        else:
            raise BadDiscriminant(self.resop, self)
            

class COMPOUND4args:
    # XDR definition:
    # struct COMPOUND4args {
    #     utf8string tag;
    #     uint32_t minorversion;
    #     nfs_argop4 argarray<>;
    # };
    def __init__(self, ncl, tag=None, minorversion=None, argarray=None):
        init_type_class(self, ncl)
        self.tag = tag
        self.minorversion = minorversion
        self.argarray = argarray

    def __repr__(self):
        s = " tag=%s minorversion=%s argarray=%s" % (str(self.tag), str(self.minorversion), str(self.argarray))
        if len(s) > 70: s = s[:70] + "..."
        return "<COMPOUND4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.tag, self.minorversion, self.argarray)
        self.packer.pack_utf8string(self.tag)
        self.packer.pack_uint32_t(self.minorversion)
        pack_objarray(self, self.argarray)

    def unpack(self):
        self.tag = self.unpacker.unpack_utf8string()
        self.minorversion = self.unpacker.unpack_uint32_t()
        self.argarray = unpack_objarray(self, nfs_argop4)

class COMPOUND4res:
    # XDR definition:
    # struct COMPOUND4res {
    #     nfsstat4 status;
    #     utf8string tag;
    #     nfs_resop4 resarray<>;
    # };
    def __init__(self, ncl, status=None, tag=None, resarray=None):
        init_type_class(self, ncl)
        self.status = status
        self.tag = tag
        self.resarray = resarray

    def __repr__(self):
        s = " status=%s tag=%s resarray=%s" % (str(self.status), str(self.tag), str(self.resarray))
        if len(s) > 70: s = s[:70] + "..."
        return "<COMPOUND4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status, self.tag, self.resarray)
        self.packer.pack_nfsstat4(self.status)
        self.packer.pack_utf8string(self.tag)
        pack_objarray(self, self.resarray)

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        self.tag = self.unpacker.unpack_utf8string()
        self.resarray = unpack_objarray(self, nfs_resop4)

class CB_GETATTR4args:
    # XDR definition:
    # struct CB_GETATTR4args {
    #     nfs_fh4 fh;
    #     bitmap4 attr_request;
    # };
    def __init__(self, ncl, fh=None, attr_request=None):
        init_type_class(self, ncl)
        self.fh = fh
        self.attr_request = attr_request

    def __repr__(self):
        s = " fh=%s attr_request=%s" % (str(self.fh), str(self.attr_request))
        if len(s) > 70: s = s[:70] + "..."
        return "<CB_GETATTR4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.fh, self.attr_request)
        self.packer.pack_nfs_fh4(self.fh)
        self.packer.pack_bitmap4(self.attr_request)

    def unpack(self):
        self.fh = self.unpacker.unpack_nfs_fh4()
        self.attr_request = self.unpacker.unpack_bitmap4()

class CB_GETATTR4resok:
    # XDR definition:
    # struct CB_GETATTR4resok {
    #     fattr4 obj_attributes;
    # };
    def __init__(self, ncl, obj_attributes=None):
        init_type_class(self, ncl)
        self.obj_attributes = obj_attributes

    def __repr__(self):
        s = " obj_attributes=%s" % (str(self.obj_attributes))
        if len(s) > 70: s = s[:70] + "..."
        return "<CB_GETATTR4resok:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.obj_attributes)
        self.obj_attributes.pack()

    def unpack(self):
        self.obj_attributes = fattr4(self)
        self.obj_attributes.unpack()

class CB_GETATTR4res:
    # XDR definition:
    # union CB_GETATTR4res switch (nfsstat4 status) {
    #     case NFS4_OK:
    #         CB_GETATTR4resok    resok4;
    #     default:
    #         void;
    # };
    def __init__(self, ncl, status=None, resok4=None):
        init_type_class(self, ncl)
        self.status = status
        self.resok4 = resok4
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " status=%s resok4=%s" % (str(self.status), str(self.resok4))
        if len(s) > 70: s = s[:70] + "..."
        return "<CB_GETATTR4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)
        if self.status == NFS4_OK:
            assert_not_none(self, self.resok4)
            self.resok4.pack()
            self.arm = self.resok4
        else:
            pass
            

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        if self.status == NFS4_OK:
            self.resok4 = CB_GETATTR4resok(self)
            self.resok4.unpack()
            self.arm = self.resok4
        else:
            pass
            

class CB_RECALL4args:
    # XDR definition:
    # struct CB_RECALL4args {
    #     stateid4 stateid;
    #     bool truncate;
    #     nfs_fh4 fh;
    # };
    def __init__(self, ncl, stateid=None, truncate=None, fh=None):
        init_type_class(self, ncl)
        self.stateid = stateid
        self.truncate = truncate
        self.fh = fh

    def __repr__(self):
        s = " stateid=%s truncate=%s fh=%s" % (str(self.stateid), str(self.truncate), str(self.fh))
        if len(s) > 70: s = s[:70] + "..."
        return "<CB_RECALL4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.stateid, self.truncate, self.fh)
        self.stateid.pack()
        self.packer.pack_bool(self.truncate)
        self.packer.pack_nfs_fh4(self.fh)

    def unpack(self):
        self.stateid = stateid4(self)
        self.stateid.unpack()
        self.truncate = self.unpacker.unpack_bool()
        self.fh = self.unpacker.unpack_nfs_fh4()

class CB_RECALL4res:
    # XDR definition:
    # struct CB_RECALL4res {
    #     nfsstat4 status;
    # };
    def __init__(self, ncl, status=None):
        init_type_class(self, ncl)
        self.status = status

    def __repr__(self):
        s = " status=%s" % (str(self.status))
        if len(s) > 70: s = s[:70] + "..."
        return "<CB_RECALL4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status)
        self.packer.pack_nfsstat4(self.status)

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()

class nfs_cb_argop4:
    # XDR definition:
    # union nfs_cb_argop4 switch (unsigned argop) {
    #     case OP_CB_GETATTR:
    #         CB_GETATTR4args    opcbgetattr;
    #     case OP_CB_RECALL:
    #         CB_RECALL4args    opcbrecall;
    # };
    def __init__(self, ncl, argop=None, opcbgetattr=None, opcbrecall=None):
        init_type_class(self, ncl)
        self.argop = argop
        self.opcbgetattr = opcbgetattr
        self.opcbrecall = opcbrecall
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " argop=%s opcbgetattr=%s opcbrecall=%s" % (str(self.argop), str(self.opcbgetattr), str(self.opcbrecall))
        if len(s) > 70: s = s[:70] + "..."
        return "<nfs_cb_argop4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.argop)
        self.packer.pack_unsigned(self.argop)
        if self.argop == OP_CB_GETATTR:
            assert_not_none(self, self.opcbgetattr)
            self.opcbgetattr.pack()
            self.arm = self.opcbgetattr
        elif self.argop == OP_CB_RECALL:
            assert_not_none(self, self.opcbrecall)
            self.opcbrecall.pack()
            self.arm = self.opcbrecall
        else:
            raise BadDiscriminant(self.argop, self)
            

    def unpack(self):
        self.argop = self.unpacker.unpack_unsigned()
        if self.argop == OP_CB_GETATTR:
            self.opcbgetattr = CB_GETATTR4args(self)
            self.opcbgetattr.unpack()
            self.arm = self.opcbgetattr
        elif self.argop == OP_CB_RECALL:
            self.opcbrecall = CB_RECALL4args(self)
            self.opcbrecall.unpack()
            self.arm = self.opcbrecall
        else:
            raise BadDiscriminant(self.argop, self)
            

class nfs_cb_resop4:
    # XDR definition:
    # union nfs_cb_resop4 switch (unsigned resop) {
    #     case OP_CB_GETATTR:
    #         CB_GETATTR4res    opcbgetattr;
    #     case OP_CB_RECALL:
    #         CB_RECALL4res    opcbrecall;
    # };
    def __init__(self, ncl, resop=None, opcbgetattr=None, opcbrecall=None):
        init_type_class(self, ncl)
        self.resop = resop
        self.opcbgetattr = opcbgetattr
        self.opcbrecall = opcbrecall
        # Shortcut to current arm
        self.arm = None

    def __repr__(self):
        s = " resop=%s opcbgetattr=%s opcbrecall=%s" % (str(self.resop), str(self.opcbgetattr), str(self.opcbrecall))
        if len(s) > 70: s = s[:70] + "..."
        return "<nfs_cb_resop4:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.resop)
        self.packer.pack_unsigned(self.resop)
        if self.resop == OP_CB_GETATTR:
            assert_not_none(self, self.opcbgetattr)
            self.opcbgetattr.pack()
            self.arm = self.opcbgetattr
        elif self.resop == OP_CB_RECALL:
            assert_not_none(self, self.opcbrecall)
            self.opcbrecall.pack()
            self.arm = self.opcbrecall
        else:
            raise BadDiscriminant(self.resop, self)
            

    def unpack(self):
        self.resop = self.unpacker.unpack_unsigned()
        if self.resop == OP_CB_GETATTR:
            self.opcbgetattr = CB_GETATTR4res(self)
            self.opcbgetattr.unpack()
            self.arm = self.opcbgetattr
        elif self.resop == OP_CB_RECALL:
            self.opcbrecall = CB_RECALL4res(self)
            self.opcbrecall.unpack()
            self.arm = self.opcbrecall
        else:
            raise BadDiscriminant(self.resop, self)
            

class CB_COMPOUND4args:
    # XDR definition:
    # struct CB_COMPOUND4args {
    #     utf8string tag;
    #     uint32_t minorversion;
    #     nfs_cb_argop4 argarray<>;
    # };
    def __init__(self, ncl, tag=None, minorversion=None, argarray=None):
        init_type_class(self, ncl)
        self.tag = tag
        self.minorversion = minorversion
        self.argarray = argarray

    def __repr__(self):
        s = " tag=%s minorversion=%s argarray=%s" % (str(self.tag), str(self.minorversion), str(self.argarray))
        if len(s) > 70: s = s[:70] + "..."
        return "<CB_COMPOUND4args:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.tag, self.minorversion, self.argarray)
        self.packer.pack_utf8string(self.tag)
        self.packer.pack_uint32_t(self.minorversion)
        pack_objarray(self, self.argarray)

    def unpack(self):
        self.tag = self.unpacker.unpack_utf8string()
        self.minorversion = self.unpacker.unpack_uint32_t()
        self.argarray = unpack_objarray(self, nfs_cb_argop4)

class CB_COMPOUND4res:
    # XDR definition:
    # struct CB_COMPOUND4res {
    #     nfsstat4 status;
    #     utf8string tag;
    #     nfs_cb_resop4 resarray<>;
    # };
    def __init__(self, ncl, status=None, tag=None, resarray=None):
        init_type_class(self, ncl)
        self.status = status
        self.tag = tag
        self.resarray = resarray

    def __repr__(self):
        s = " status=%s tag=%s resarray=%s" % (str(self.status), str(self.tag), str(self.resarray))
        if len(s) > 70: s = s[:70] + "..."
        return "<CB_COMPOUND4res:%s>" % s

    def pack(self, dummy=None):
        assert_not_none(self, self.status, self.tag, self.resarray)
        self.packer.pack_nfsstat4(self.status)
        self.packer.pack_utf8string(self.tag)
        pack_objarray(self, self.resarray)

    def unpack(self):
        self.status = self.unpacker.unpack_nfsstat4()
        self.tag = self.unpacker.unpack_utf8string()
        self.resarray = unpack_objarray(self, nfs_cb_resop4)

